<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.8">
  <compounddef id="group__filesystem" kind="group">
    <compoundname>filesystem</compoundname>
    <title>FAT File System</title>
    <innerfile refid="diskio_8h">diskio.h</innerfile>
    <innerfile refid="ff_8h">ff.h</innerfile>
    <innerclass refid="struct_d_i_r" prot="public">DIR</innerclass>
    <innerclass refid="struct_f_a_t_f_s" prot="public">FATFS</innerclass>
    <innerclass refid="struct_f_i_l" prot="public">FIL</innerclass>
    <innerclass refid="struct_f_i_l_i_n_f_o" prot="public">FILINFO</innerclass>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__filesystem_1ga09cdaa6f36fa409bdf002727bff98eb1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="diskio_8h_1adba6790898ce4029c20a34b898ce73c1" kindref="member">DSTATUS</ref></type>
        <definition>DSTATUS disk_initialize</definition>
        <argsstring>(BYTE pdrv)</argsstring>
        <name>disk_initialize</name>
        <param>
          <type><ref refid="integer_8h_1a4ae1dab0fb4b072a66584546209e7d58" kindref="member">BYTE</ref></type>
          <declname>pdrv</declname>
        </param>
        <briefdescription>
<para>The disk_initialize function initializes the storage device. </para>        </briefdescription>
        <detaileddescription>
<para>This function initializes the storage device and put it ready to generic read/write. When the function succeeded, STA_NOINIT flag in the return value is cleared. <linebreak/>
 <bold>Application program MUST NOT call this function, or FAT structure on the volume can be broken. To re-initialize the file system, use <ref refid="group__filesystem_1ga16a934c2bbfa2160295810adc49d5509" kindref="member">f_mount()</ref> function instead.</bold> This function is called at volume mount process by FatFs module to manage the media change. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">pdrv</parametername>
</parameternamelist>
<parameterdescription>
<para>Physical drive number to identify the target device. Always zero at single drive system. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>This</parametername>
</parameternamelist>
<parameterdescription>
<para>function returns the current drive status flags as the result. For details of the drive status, refer to the <ref refid="group__filesystem_1ga8348ac5ee6d709420c02e45c111f4793" kindref="member">disk_status()</ref> function. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Common/Docs/ff.dox" line="1307" column="1" bodyfile="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/diskio.c" bodystart="63" bodyend="93"/>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1gab00fa450a811dbdabe3c655c1a36fab4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__filesystem_1gaacdfef1dad6565f65c26d12fe0ea4b2b" kindref="member">DRESULT</ref></type>
        <definition>DRESULT disk_ioctl</definition>
        <argsstring>(BYTE pdrv, BYTE cmd, void *buff)</argsstring>
        <name>disk_ioctl</name>
        <param>
          <type><ref refid="integer_8h_1a4ae1dab0fb4b072a66584546209e7d58" kindref="member">BYTE</ref></type>
          <declname>pdrv</declname>
        </param>
        <param>
          <type><ref refid="integer_8h_1a4ae1dab0fb4b072a66584546209e7d58" kindref="member">BYTE</ref></type>
          <declname>cmd</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>buff</declname>
        </param>
        <briefdescription>
<para>The disk_ioctl function cntrols device specific features and miscellaneous functions other than generic read/write. </para>        </briefdescription>
        <detaileddescription>
<para>The FatFs module requires only five device independent commands described below. <linebreak/>
 <linebreak/>
<center> <bold> Standard ioctl command used by FatFs: </bold> </center> <table rows="6" cols="2"><row>
<entry thead="yes"><para>Command </para></entry><entry thead="yes"><para>Description  </para></entry></row>
<row>
<entry thead="no"><para>CTRL_SYNC </para></entry><entry thead="no"><para>Make sure that the device has finished pending write process. If the disk I/O module has a write back cache, the dirty buffers must be written back to the media immediately. Nothing to do for this command if each write operation to the media is completed within the <ref refid="group__filesystem_1gac03220b2c8a090b4f76eb2c9407b84fb" kindref="member">disk_write()</ref> function. </para></entry></row>
<row>
<entry thead="no"><para>GET_SECTOR_COUNT </para></entry><entry thead="no"><para>Returns number of available sectors on the drive into the DWORD variable pointed by buff. This command is used by only <ref refid="group__filesystem_1ga799aff9594e708c8be357281cf85428b" kindref="member">f_mkfs()</ref> and <ref refid="group__filesystem_1ga0c1bd3e3872abbda0e256e7c73da9f3b" kindref="member">f_fdisk()</ref> function to determine the volume/partition size to be created. Required at _USE_MKFS == 1 or _MULTI_PARTITION == 1. </para></entry></row>
<row>
<entry thead="no"><para>GET_SECTOR_SIZE </para></entry><entry thead="no"><para>Returns sector size of the media into the WORD variable pointed by buff. Valid return values of this command are 512, 1024, 2048 and 4096. This command is required only at variable sector size configuration, _MAX_SS &gt; _MIN_SS. At fixed sector size configuration, _MAX_SS == _MIN_SS, this command is not used and the device must work at that sector size. </para></entry></row>
<row>
<entry thead="no"><para>GET_BLOCK_SIZE </para></entry><entry thead="no"><para>Returns erase block size of the flash memory media in unit of sector into the DWORD variable pointed by buff. The allowable value is from 1 to 32768 in power of 2. Return 1 if the erase block size is unknown or non flash memory media. This command is used by only <ref refid="group__filesystem_1ga799aff9594e708c8be357281cf85428b" kindref="member">f_mkfs()</ref> function and it attempts to align data area to the erase block boundary. Required at _USE_MKFS == 1. </para></entry></row>
<row>
<entry thead="no"><para>CTRL_TRIM </para></entry><entry thead="no"><para>Informs the device the data on the block of sectors that specified by DWORD array {&lt;start sector&gt;=&quot;&quot;&gt;, &lt;end sector&gt;=&quot;&quot;&gt;} pointed by buff is no longer needed and it may be erased. This is an identical command to Trim of ATA device. When this feature is not supported or not a flash memory device, nothing to do for this command. The FatFs does not check the result code and the file function is not affected even if the sector block was not erased well. This command is called on removing a cluster chain and <ref refid="group__filesystem_1ga799aff9594e708c8be357281cf85428b" kindref="member">f_mkfs()</ref> function. Required at _USE_TRIM == 1. </para></entry></row>
</table>
</para><para>FatFs never uses any device dependent command nor user defined command. Following table shows an example of non-standard commands usable for some applications. <center> <bold> Example of optional ioctl command </bold> </center></para><para><table rows="13" cols="2"><row>
<entry thead="yes"><para>Command </para></entry><entry thead="yes"><para>Description  </para></entry></row>
<row>
<entry thead="no"><para>CTRL_FORMAT </para></entry><entry thead="no"><para>Create a physical format on the media. If buff is not null, it is pointer to the call-back function for progress notification. </para></entry></row>
<row>
<entry thead="no"><para>CTRL_POWER_IDLE </para></entry><entry thead="no"><para>Put the device idle state. STA_NOINIT in status flag may not be set if the device goes active state by generic read/write function. </para></entry></row>
<row>
<entry thead="no"><para>CTRL_POWER_OFF </para></entry><entry thead="no"><para>Put the device off state. Shut-down the power to the device and deinitialize the device interface if needed. STA_NOINIT in status flag must be set. The device goes active state by <ref refid="group__filesystem_1ga09cdaa6f36fa409bdf002727bff98eb1" kindref="member">disk_initialize()</ref> function. </para></entry></row>
<row>
<entry thead="no"><para>CTRL_LOCK </para></entry><entry thead="no"><para>Lock media eject mechanism. </para></entry></row>
<row>
<entry thead="no"><para>CTRL_UNLOCK </para></entry><entry thead="no"><para>Unlock media eject mechanism. </para></entry></row>
<row>
<entry thead="no"><para>MMC_GET_CSD </para></entry><entry thead="no"><para>Eject media cartridge. STA_NOINIT and STA_NODISK in status flag are set after the function succeeded. </para></entry></row>
<row>
<entry thead="no"><para>MMC_GET_CID </para></entry><entry thead="no"><para>Get card type. The type flags, bit0:MMCv3, bit1:SDv1, bit2:SDv2+ and bit3:LBA, is stored to a BYTE variable pointed by buff. (MMC/SDC specific command) </para></entry></row>
<row>
<entry thead="no"><para>MMC_GET_OCR </para></entry><entry thead="no"><para>Get OCR register into a 4-byte buffer pointed by buff. (MMC/SDC specific command) </para></entry></row>
<row>
<entry thead="no"><para>MMC_GET_SDSTAT </para></entry><entry thead="no"><para>Get SDSTATUS register into a 64-byte buffer pointed by buff. (SDC specific command) </para></entry></row>
<row>
<entry thead="no"><para>ATA_GET_REV </para></entry><entry thead="no"><para>Get the revision string into a 16-byte buffer pointed by buff. (ATA/CFC specific command) </para></entry></row>
<row>
<entry thead="no"><para>ATA_GET_MODEL </para></entry><entry thead="no"><para>Get the model string into a 40-byte buffer pointed by buff. (ATA/CFC specific command) </para></entry></row>
<row>
<entry thead="no"><para>ATA_GET_SN </para></entry><entry thead="no"><para>Get the serial number string into a 20-byte buffer pointed by buff. (ATA/CFC specific command) </para></entry></row>
</table>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">pdrv</parametername>
</parameternamelist>
<parameterdescription>
<para>Physical drive number to identify the target device. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">cmd</parametername>
</parameternamelist>
<parameterdescription>
<para>Command code. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="inout">buff</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the parameter depends on the command code. Do not care if no parameter to be passed. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>RES_OK(0)</parametername>
</parameternamelist>
<parameterdescription>
<para><linebreak/>
 The function succeeded. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>RES_ERROR</parametername>
</parameternamelist>
<parameterdescription>
<para><linebreak/>
 An error occured. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>RES_PARERR</parametername>
</parameternamelist>
<parameterdescription>
<para><linebreak/>
 The command code or parameter is invalid. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>RES_NOTRDY</parametername>
</parameternamelist>
<parameterdescription>
<para><linebreak/>
 The device has not been initialized. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The disk_ioctl function is not needed when _FS_READONLY == 1 and _MAX_SS == _MIN_SS. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Common/Docs/ff.dox" line="1423" column="1" bodyfile="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/diskio.c" bodystart="199" bodyend="229"/>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1ga075d27f59f550e2cee07d00abcff32e0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__filesystem_1gaacdfef1dad6565f65c26d12fe0ea4b2b" kindref="member">DRESULT</ref></type>
        <definition>DRESULT disk_read</definition>
        <argsstring>(BYTE pdrv, BYTE *buff, DWORD sector, UINT count)</argsstring>
        <name>disk_read</name>
        <param>
          <type><ref refid="integer_8h_1a4ae1dab0fb4b072a66584546209e7d58" kindref="member">BYTE</ref></type>
          <declname>pdrv</declname>
        </param>
        <param>
          <type><ref refid="integer_8h_1a4ae1dab0fb4b072a66584546209e7d58" kindref="member">BYTE</ref> *</type>
          <declname>buff</declname>
        </param>
        <param>
          <type><ref refid="integer_8h_1ad342ac907eb044443153a22f964bf0af" kindref="member">DWORD</ref></type>
          <declname>sector</declname>
        </param>
        <param>
          <type><ref refid="integer_8h_1a36cb3b01d81ffd844bbbfb54003e06ec" kindref="member">UINT</ref></type>
          <declname>count</declname>
        </param>
        <briefdescription>
<para>The disk_read function reads sector(s) from the storage device. </para>        </briefdescription>
        <detaileddescription>
<para>The data read/write operation to the storage devices is done in unit of sector. FatFs supports the sector size in range of from 512 to 4096 bytes. When FatFs is configured to fixed sector size (_MIN_SS == MAX_SS, this will be the most case), the read/write function must work at that sector size. If variable sector size is selected (_MIN_SS &lt; MAX_SS), FatFs inquires the sector size with <ref refid="group__filesystem_1gab00fa450a811dbdabe3c655c1a36fab4" kindref="member">disk_ioctl()</ref> after initialization. <linebreak/>
 The memory address specified by buff is not that always aligned to word boundary because the argument is defined as BYTE*. The misaligned read/write request can occure at direct transfer. If the bus architecture, especially DMA controller, does not allow misaligned memory access, it should be solved in this function. There are some workarounds described below to avoid this issue. <linebreak/>
<itemizedlist>
<listitem><para>Convert word transfer to byte transfer in this function if needed. - Recommended.</para></listitem><listitem><para>For <ref refid="group__filesystem_1gac4c3dcb6869ca252888eebabe39727b3" kindref="member">f_read()</ref>, avoid long read request that includes a whole of sector. - Direct transfer will never occure.</para></listitem><listitem><para>For f_read(fp, buff, btr, &amp;br), make sure that (((UINT)buff &amp; 3) == (<ref refid="ff_8h_1a5e1daca7ce13cdc277e42185f7f9124f" kindref="member">f_tell(fp)</ref> &amp; 3)) is true. - Word aligned direct transfer is guaranteed. <linebreak/>
 Generally, a multiple sector transfer request must not be split into single sector transactions to the storage device, or you will not get good read throughput. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">pdrv</parametername>
</parameternamelist>
<parameterdescription>
<para>Physical drive number to identify the target device. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">buff</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the byte array to store the read data. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">sector</parametername>
</parameternamelist>
<parameterdescription>
<para>Start sector number in 32-bit LBA. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">count</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of sectors to read in range of from 1 to 128.. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>RES_OK</parametername>
</parameternamelist>
<parameterdescription>
<para>(0) <linebreak/>
 The function succeeded. <linebreak/>
</para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>RES_ERROR</parametername>
</parameternamelist>
<parameterdescription>
<para><linebreak/>
 Any hard error occured during the read operation and could not recover it. <linebreak/>
</para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>RES_PARERR</parametername>
</parameternamelist>
<parameterdescription>
<para><linebreak/>
 Invalid parameter. <linebreak/>
</para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>RES_NOTRDY</parametername>
</parameternamelist>
<parameterdescription>
<para><linebreak/>
 The device has not been initialized. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para></listitem></itemizedlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Common/Docs/ff.dox" line="1338" column="1" bodyfile="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/diskio.c" bodystart="101" bodyend="141"/>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1ga8348ac5ee6d709420c02e45c111f4793" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="diskio_8h_1adba6790898ce4029c20a34b898ce73c1" kindref="member">DSTATUS</ref></type>
        <definition>DSTATUS disk_status</definition>
        <argsstring>(BYTE pdrv)</argsstring>
        <name>disk_status</name>
        <param>
          <type><ref refid="integer_8h_1a4ae1dab0fb4b072a66584546209e7d58" kindref="member">BYTE</ref></type>
          <declname>pdrv</declname>
        </param>
        <briefdescription>
<para>The disk_status function returns the current drive status. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">pdrv</parametername>
</parameternamelist>
<parameterdescription>
<para>Physical drive number to identify the target device. Always zero at single drive system. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>The</parametername>
</parameternamelist>
<parameterdescription>
<para>current drive status is returned in combination of status flags described below. FatFs refers only STA_NOINIT and STA_PROTECT. <linebreak/>
</para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>STA_NOINIT</parametername>
</parameternamelist>
<parameterdescription>
<para><linebreak/>
 Indicates that the device is not initialized. This flag is set on system reset, media removal or failure of <ref refid="group__filesystem_1ga09cdaa6f36fa409bdf002727bff98eb1" kindref="member">disk_initialize()</ref> function. It is cleared on <ref refid="group__filesystem_1ga09cdaa6f36fa409bdf002727bff98eb1" kindref="member">disk_initialize()</ref> function succeeded. Media change that occurs asynchronously must be captured and reflect it to the status flags, or auto-mount feature will not work correctly. If the system does not support media change detect feature, application program needs to force de-initialize the file system object with <ref refid="group__filesystem_1ga16a934c2bbfa2160295810adc49d5509" kindref="member">f_mount()</ref> function after the media change. <linebreak/>
</para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>STA_NODISK</parametername>
</parameternamelist>
<parameterdescription>
<para><linebreak/>
 Indicates that no medium in the drive. This is always cleared on fixed disk drive. Note that FatFs does not refer this flag. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>STA_PROTECT</parametername>
</parameternamelist>
<parameterdescription>
<para><linebreak/>
 Indicates that the medium is write protected. This is always cleared on the drives without write protect feature. Not valid if no medium in the drive. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Common/Docs/ff.dox" line="1294" column="1" bodyfile="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/diskio.c" bodystart="25" bodyend="55"/>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1gac03220b2c8a090b4f76eb2c9407b84fb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__filesystem_1gaacdfef1dad6565f65c26d12fe0ea4b2b" kindref="member">DRESULT</ref></type>
        <definition>DRESULT disk_write</definition>
        <argsstring>(BYTE drv, const BYTE *buff, DWORD sector, UINT count)</argsstring>
        <name>disk_write</name>
        <param>
          <type><ref refid="integer_8h_1a4ae1dab0fb4b072a66584546209e7d58" kindref="member">BYTE</ref></type>
          <declname>drv</declname>
        </param>
        <param>
          <type>const <ref refid="integer_8h_1a4ae1dab0fb4b072a66584546209e7d58" kindref="member">BYTE</ref> *</type>
          <declname>buff</declname>
        </param>
        <param>
          <type><ref refid="integer_8h_1ad342ac907eb044443153a22f964bf0af" kindref="member">DWORD</ref></type>
          <declname>sector</declname>
        </param>
        <param>
          <type><ref refid="integer_8h_1a36cb3b01d81ffd844bbbfb54003e06ec" kindref="member">UINT</ref></type>
          <declname>count</declname>
        </param>
        <briefdescription>
<para>The disk_write writes sector(s) to the storage device. </para>        </briefdescription>
        <detaileddescription>
<para>The specified memory address is not that always aligned to word boundary because the type of pointer is defined as BYTE*. For more information, refer to the description of <ref refid="group__filesystem_1ga075d27f59f550e2cee07d00abcff32e0" kindref="member">disk_read()</ref> function. <linebreak/>
 Generally, a multiple sector transfer request must not be split into single sector transactions to the storage device, or you will never get good write throughput. <linebreak/>
 FatFs expects delayed write feature of the disk functions. The write operation to the media need not to be completed due to write operation is in progress or only stored it into the cache buffer when return from this function. But data on the buff is invalid after return from this function. The write completion request is done by CTRL_SYNC command of <ref refid="group__filesystem_1gab00fa450a811dbdabe3c655c1a36fab4" kindref="member">disk_ioctl()</ref> function. Therefore, if delayed write feature is implemented, the write throughput may be improved. <linebreak/>
 Application program MUST NOT call this function, or FAT structure on the volume can be collapsed. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">pdrv</parametername>
</parameternamelist>
<parameterdescription>
<para>Physical drive number to identify the target device. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">buff</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the byte array to be written. The size of data to be written is sector size * count bytes. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">sector</parametername>
</parameternamelist>
<parameterdescription>
<para>Start sector number in 32-bit LBA. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">count</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of sectors to write in range of from 1 to 128. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>RES_OK(0)</parametername>
</parameternamelist>
<parameterdescription>
<para><linebreak/>
 The function succeeded. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>RES_ERROR</parametername>
</parameternamelist>
<parameterdescription>
<para><linebreak/>
 Any hard error occured during the write operation and could not recover it. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>RES_WRPRT</parametername>
</parameternamelist>
<parameterdescription>
<para><linebreak/>
 The medium is write protected. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>RES_PARERR</parametername>
</parameternamelist>
<parameterdescription>
<para><linebreak/>
 Invalid parameter. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>RES_NOTRDY</parametername>
</parameternamelist>
<parameterdescription>
<para><linebreak/>
 The device has not been initialized. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function is not needed when _FS_READONLY == 1. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Common/Docs/ff.dox" line="1371" column="1" bodyfile="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/diskio.c" bodystart="150" bodyend="190"/>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1ga53c7e9a7fb3c279254cd2d0445667e2f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__filesystem_1ga49d0171ecbd362cda5680a0d360db44c" kindref="member">FRESULT</ref></type>
        <definition>FRESULT f_chdir</definition>
        <argsstring>(const TCHAR *path)</argsstring>
        <name>f_chdir</name>
        <param>
          <type>const <ref refid="ff_8h_1a03bdb8ce5895c7e261aadc2529637546" kindref="member">TCHAR</ref> *</type>
          <declname>path</declname>
        </param>
        <briefdescription>
<para>The f_chdir function changes the current directory of a drive. </para>        </briefdescription>
        <detaileddescription>
<para>The <ref refid="group__filesystem_1ga53c7e9a7fb3c279254cd2d0445667e2f" kindref="member">f_chdir()</ref> function changes the current directory of the logical drive. The current directory of a drive is initialized to the root directory when the drive is auto-mounted. Note that the current directory is retained in the each file system object so that it also affects other tasks that using the volume. <linebreak/>
 Example: <programlisting><codeline><highlight class="normal">/*<sp/>Change<sp/>current<sp/>direcoty<sp/>of<sp/>the<sp/>current<sp/>drive<sp/>(dir1<sp/>under<sp/>root<sp/>dir)<sp/>*/</highlight></codeline>
<codeline><highlight class="normal">f_chdir(&quot;/dir1&quot;);</highlight></codeline>
<codeline><highlight class="normal">/*<sp/>Change<sp/>current<sp/>direcoty<sp/>of<sp/>drive<sp/>2<sp/>(parent<sp/>dir)<sp/>*/</highlight></codeline>
<codeline><highlight class="normal">f_chdir(&quot;2:..&quot;);</highlight></codeline>
</programlisting> <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">path</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the null-terminated string that specifies a directory to go. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>FR_OK</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_DISK_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INT_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_READY</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NO_PATH</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INVALID_NAME</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INVALID_DRIVE</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_ENABLED</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NO_FILESYSTEM</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_TIMEOUT</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_ENOUGH_CORE</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Available when _FS_RPATH &gt;= 1. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Common/Docs/ff.dox" line="880" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1ga13e5933f851b436890361189f64261cd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__filesystem_1ga49d0171ecbd362cda5680a0d360db44c" kindref="member">FRESULT</ref></type>
        <definition>FRESULT f_chdrive</definition>
        <argsstring>(const TCHAR *path)</argsstring>
        <name>f_chdrive</name>
        <param>
          <type>const <ref refid="ff_8h_1a03bdb8ce5895c7e261aadc2529637546" kindref="member">TCHAR</ref> *</type>
          <declname>path</declname>
        </param>
        <briefdescription>
<para>The f_chdrive function changes the current drive. </para>        </briefdescription>
        <detaileddescription>
<para>The <ref refid="group__filesystem_1ga13e5933f851b436890361189f64261cd" kindref="member">f_chdrive()</ref> function changes the current drive. The initial value of the current drive number is 0. Note that the current drive is retained in a static variable so that it also affects other tasks that using the file functions. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">path</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the logical drive number to be set as the current drive. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>FR_OK</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INVALID_DRIVE</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Available when _FS_RPATH &gt;= 1 and _VOLUMES &gt;= 2. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Common/Docs/ff.dox" line="894" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1ga9ee7e560eec8d82755c636ae41e702cd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__filesystem_1ga49d0171ecbd362cda5680a0d360db44c" kindref="member">FRESULT</ref></type>
        <definition>FRESULT f_chmod</definition>
        <argsstring>(const TCHAR *path, BYTE attr, BYTE mask)</argsstring>
        <name>f_chmod</name>
        <param>
          <type>const <ref refid="ff_8h_1a03bdb8ce5895c7e261aadc2529637546" kindref="member">TCHAR</ref> *</type>
          <declname>path</declname>
        </param>
        <param>
          <type><ref refid="integer_8h_1a4ae1dab0fb4b072a66584546209e7d58" kindref="member">BYTE</ref></type>
          <declname>attr</declname>
        </param>
        <param>
          <type><ref refid="integer_8h_1a4ae1dab0fb4b072a66584546209e7d58" kindref="member">BYTE</ref></type>
          <declname>mask</declname>
        </param>
        <briefdescription>
<para>The f_chmod function changes the attribute of a file or sub-directory. </para>        </briefdescription>
        <detaileddescription>
<para>The <ref refid="group__filesystem_1ga9ee7e560eec8d82755c636ae41e702cd" kindref="member">f_chmod()</ref> function changes the attribute of a file or sub-directory. <linebreak/>
 Example: <programlisting><codeline><highlight class="normal">/*<sp/>Set<sp/>read-only<sp/>flag,<sp/>clear<sp/>archive<sp/>flag<sp/>and<sp/>others<sp/>are<sp/>left<sp/>unchanged.<sp/>*/</highlight></codeline>
<codeline><highlight class="normal">f_chmod(&quot;file.txt&quot;,<sp/>AR_RDO,<sp/>AR_RDO<sp/>|<sp/>AR_ARC);</highlight></codeline>
</programlisting> <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">path</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the null-terminated string that specifies an object to be changed </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">attr</parametername>
</parameternamelist>
<parameterdescription>
<para>Attribute flags to be set in one or more combination of the following flags. The specified flags are set and others are cleard. <table rows="5" cols="2"><row>
<entry thead="yes"><para>Attribute </para></entry><entry thead="yes"><para>Description  </para></entry></row>
<row>
<entry thead="no"><para>AM_RDO </para></entry><entry thead="no"><para>Read only </para></entry></row>
<row>
<entry thead="no"><para>AM_ARC </para></entry><entry thead="no"><para>Archive </para></entry></row>
<row>
<entry thead="no"><para>AM_SYS </para></entry><entry thead="no"><para>System </para></entry></row>
<row>
<entry thead="no"><para>AM_HID </para></entry><entry thead="no"><para>Hidden </para></entry></row>
</table>
</para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">mask</parametername>
</parameternamelist>
<parameterdescription>
<para>Attribute mask that specifies which attribute is changed. The specified attributes are set or cleard and others are left unchanged. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>FR_OK</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_DISK_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INT_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_READY</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NO_FILE</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NO_PATH</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INVALID_NAME</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_WRITE_PROTECTED</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INVALID_DRIVE</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_ENABLED</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NO_FILESYSTEM</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_TIMEOUT</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_ENOUGH_CORE</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Available when _FS_READONLY == 0 and _FS_MINIMIZE == 0. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Common/Docs/ff.dox" line="764" column="1" bodyfile="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/ff.c" bodystart="3669" bodyend="3702"/>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1ga53882db20ef4323dcfd1874d7733ffc3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__filesystem_1ga49d0171ecbd362cda5680a0d360db44c" kindref="member">FRESULT</ref></type>
        <definition>FRESULT f_close</definition>
        <argsstring>(FIL *fp)</argsstring>
        <name>f_close</name>
        <param>
          <type><ref refid="struct_f_i_l" kindref="compound">FIL</ref> *</type>
          <declname>fp</declname>
        </param>
        <briefdescription>
<para>The f_close function closes an open file. </para>        </briefdescription>
        <detaileddescription>
<para>The <ref refid="group__filesystem_1ga53882db20ef4323dcfd1874d7733ffc3" kindref="member">f_close()</ref> function closes an open file object. If any data has been written to the file, the cached information of the file is written back to the volume. After the function succeeded, the file object is no longer valid and it can be discarded. <linebreak/>
 Note that if the file object is in read-only mode and _FS_LOCK option is not enabled, the file object can also be discarded without this process. However this is not recommended for future compatibility.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fp</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the open file object structure to be closed. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>FR_OK</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_DISK_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INT_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_READY</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INVALID_OBJECT</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_TIMEOUT</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Always available. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Common/Docs/ff.dox" line="240" column="1" bodyfile="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/ff.c" bodystart="2857" bodyend="2885"/>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1gab5f7376b6f3e3bcc7f5ff5497c8b7364" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__filesystem_1ga49d0171ecbd362cda5680a0d360db44c" kindref="member">FRESULT</ref></type>
        <definition>FRESULT f_closedir</definition>
        <argsstring>(DIR *dp)</argsstring>
        <name>f_closedir</name>
        <param>
          <type><ref refid="struct_d_i_r" kindref="compound">DIR</ref> *</type>
          <declname>dp</declname>
        </param>
        <briefdescription>
<para>The f_closedir function closes an open directory. </para>        </briefdescription>
        <detaileddescription>
<para>The <ref refid="group__filesystem_1gab5f7376b6f3e3bcc7f5ff5497c8b7364" kindref="member">f_closedir()</ref> function closes an open directory object. After the function succeeded, the directory object is no longer valid and it can be discarded. <linebreak/>
 Note that the directory object can also be discarded without this process if _FS_LOCK option is not enabled. However this is not recommended for future compatibility. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">dp</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the open directory object structure to be closed. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>FR_OK</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INT_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INVALID_OBJECT</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_TIMEOUT</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Available when _FS_MINIMIZE &lt;= 1. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Common/Docs/ff.dox" line="587" column="1" bodyfile="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/ff.c" bodystart="3243" bodyend="3266"/>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1gaf0878582b1255b693b29dca3c6ecccf1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int f_eof</definition>
        <argsstring>(FIL *fp)</argsstring>
        <name>f_eof</name>
        <param>
          <type><ref refid="struct_f_i_l" kindref="compound">FIL</ref> *</type>
          <declname>fp</declname>
        </param>
        <briefdescription>
<para>The f_eof function tests for end-of-file on a file. </para>        </briefdescription>
        <detaileddescription>
<para>In this revision, this function is implemented as a macro. <linebreak/>
 #define <ref refid="ff_8h_1a970cdd8970a3a94967ad64cfc5d4c161" kindref="member">f_eof(fp)</ref> ((int)((fp)-&gt;fptr == (fp)-&gt;fsize)) <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fp</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the open file object structure. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>The</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="group__filesystem_1gaf0878582b1255b693b29dca3c6ecccf1" kindref="member">f_eof()</ref> function returns a non-zero value if the read/write pointer has reached end of the file; otherwise it returns a zero. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Always available. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Common/Docs/ff.dox" line="1251" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1gad3c6dd79ef26a59629a6c8f6afe71fbf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int f_error</definition>
        <argsstring>(FIL *fp)</argsstring>
        <name>f_error</name>
        <param>
          <type><ref refid="struct_f_i_l" kindref="compound">FIL</ref> *</type>
          <declname>fp</declname>
        </param>
        <briefdescription>
<para>The f_error tests for an error on a file. </para>        </briefdescription>
        <detaileddescription>
<para>In this revision, this function is implemented as a macro. #define <ref refid="ff_8h_1a25cbdabeed318802cf0e9db6671a33b7" kindref="member">f_error(fp)</ref> ((fp)-&gt;flag) <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fp</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the open file object structure. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>Returns</parametername>
</parameternamelist>
<parameterdescription>
<para>a non-zero value if a hard error has occured; otherwise it returns a zero. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Always available. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Common/Docs/ff.dox" line="1275" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1ga0c1bd3e3872abbda0e256e7c73da9f3b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__filesystem_1ga49d0171ecbd362cda5680a0d360db44c" kindref="member">FRESULT</ref></type>
        <definition>FRESULT f_fdisk</definition>
        <argsstring>(BYTE pdrv, const DWORD part[], void *work)</argsstring>
        <name>f_fdisk</name>
        <param>
          <type><ref refid="integer_8h_1a4ae1dab0fb4b072a66584546209e7d58" kindref="member">BYTE</ref></type>
          <declname>pdrv</declname>
        </param>
        <param>
          <type>const <ref refid="integer_8h_1ad342ac907eb044443153a22f964bf0af" kindref="member">DWORD</ref></type>
          <declname>part</declname>
          <array>[]</array>
        </param>
        <param>
          <type>void *</type>
          <declname>work</declname>
        </param>
        <briefdescription>
<para>The f_fdisk fucntion divides a physical drive. </para>        </briefdescription>
        <detaileddescription>
<para>The <ref refid="group__filesystem_1ga0c1bd3e3872abbda0e256e7c73da9f3b" kindref="member">f_fdisk()</ref> function creates a partition table into the MBR of the physical drive. The partitioning rule is in generic FDISK format, so that it can create upto four primary partitions. Logical volumes in the extended partition is not supported. The part[] with four items specifies how to divide the physical drive. The first item specifies the size of first primary partition and fourth item specifies the fourth primary partition. If the value is less than or equal to 100, it specifies percentage of the partition in the entire disk space. If it is larger than 100, it specifies the partition size in unit of sector. <linebreak/>
 Example: <programlisting><codeline><highlight class="normal">/*<sp/>Volume<sp/>management<sp/>table<sp/>defined<sp/>by<sp/>user<sp/>(required<sp/>when<sp/>_MULTI_PARTITION<sp/>==<sp/>1)<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PARTITION<sp/>VolToPart[]<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>{0,<sp/>1},<sp/><sp/><sp/><sp/>/*<sp/>Logical<sp/>drive<sp/>0<sp/>==&gt;<sp/>Physical<sp/>drive<sp/>0,<sp/>1st<sp/>partition<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>{0,<sp/>2},<sp/><sp/><sp/><sp/>/*<sp/>Logical<sp/>drive<sp/>1<sp/>==&gt;<sp/>Physical<sp/>drive<sp/>0,<sp/>2nd<sp/>partition<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>{1,<sp/>0}<sp/><sp/><sp/><sp/><sp/>/*<sp/>Logical<sp/>drive<sp/>2<sp/>==&gt;<sp/>Physical<sp/>drive<sp/>1,<sp/>auto<sp/>detection<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/>};</highlight></codeline>
<codeline><highlight class="normal">/*<sp/>Initialize<sp/>a<sp/>brand-new<sp/>disk<sp/>drive<sp/>mapped<sp/>to<sp/>physical<sp/>drive<sp/>0<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>FATFS<sp/>fs;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>DWORD<sp/>plist[]<sp/>=<sp/>{50,<sp/>50,<sp/>0,<sp/>0};<sp/><sp/>/*<sp/>Divide<sp/>drive<sp/>into<sp/>two<sp/>partitions<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>BYTE<sp/>work[_MAX_SS];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>f_fdisk(0,<sp/>plist,<sp/>work);<sp/><sp/><sp/><sp/>/*<sp/>Divide<sp/>physical<sp/>drive<sp/>0<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>f_mount(&amp;fs,<sp/>&quot;0:&quot;,<sp/>0);<sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>Register<sp/>work<sp/>area<sp/>to<sp/>the<sp/>logical<sp/>drive<sp/>0<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>f_mkfs(&quot;0:&quot;,<sp/>0,<sp/>0);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>Create<sp/>FAT<sp/>volume<sp/>on<sp/>the<sp/>logical<sp/>drive<sp/>0.<sp/>2nd<sp/>argument<sp/>is<sp/>ignored.<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>f_mount(0,<sp/>&quot;0:&quot;,<sp/>0);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>Unregister<sp/>work<sp/>area<sp/>from<sp/>the<sp/>logical<sp/>drive<sp/>0<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>f_mount(&amp;fs,<sp/>&quot;1:&quot;,<sp/>0);<sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>Register<sp/>a<sp/>work<sp/>area<sp/>to<sp/>the<sp/>logical<sp/>drive<sp/>1<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>f_mkfs(&quot;1:&quot;,<sp/>0,<sp/>0);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>Create<sp/>FAT<sp/>volume<sp/>on<sp/>the<sp/>logical<sp/>drive<sp/>1.<sp/>2nd<sp/>argument<sp/>is<sp/>ignored.<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>f_mount(0,<sp/>&quot;1:&quot;,<sp/>0);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>Unregister<sp/>work<sp/>area<sp/>from<sp/>the<sp/>logical<sp/>drive<sp/>1<sp/>*/</highlight></codeline>
</programlisting> <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">pdrv</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the physical drive to be divided. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">part[]</parametername>
</parameternamelist>
<parameterdescription>
<para>Partition map table. It must have four items. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">work</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the function work area. The size must be at least _MAX_SS bytes. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>FR_OK</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_DISK_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_READY</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_WRITE_PROTECTED</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INVALID_PARAMETER</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Available when _FS_READOLNY == 0, _USE_MKFS == 1 and _MULTI_PARTITION == 1. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Common/Docs/ff.dox" line="1132" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1ga6c0c4cd695704aa6d952c90be81d9849" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__filesystem_1ga49d0171ecbd362cda5680a0d360db44c" kindref="member">FRESULT</ref></type>
        <definition>FRESULT f_forward</definition>
        <argsstring>(FIL *fp, UINT(*func)(const BYTE *, UINT), UINT btf, UINT *bf)</argsstring>
        <name>f_forward</name>
        <param>
          <type><ref refid="struct_f_i_l" kindref="compound">FIL</ref> *</type>
          <declname>fp</declname>
        </param>
        <param>
          <type><ref refid="integer_8h_1a36cb3b01d81ffd844bbbfb54003e06ec" kindref="member">UINT</ref>(*)(const <ref refid="integer_8h_1a4ae1dab0fb4b072a66584546209e7d58" kindref="member">BYTE</ref> *, <ref refid="integer_8h_1a36cb3b01d81ffd844bbbfb54003e06ec" kindref="member">UINT</ref>)</type>
          <declname>func</declname>
        </param>
        <param>
          <type><ref refid="integer_8h_1a36cb3b01d81ffd844bbbfb54003e06ec" kindref="member">UINT</ref></type>
          <declname>btf</declname>
        </param>
        <param>
          <type><ref refid="integer_8h_1a36cb3b01d81ffd844bbbfb54003e06ec" kindref="member">UINT</ref> *</type>
          <declname>bf</declname>
        </param>
        <briefdescription>
<para>The f_forward function reads the file data and forward it to the data streaming device. </para>        </briefdescription>
        <detaileddescription>
<para>The <ref refid="group__filesystem_1ga6c0c4cd695704aa6d952c90be81d9849" kindref="member">f_forward()</ref> function reads the data from the file and forward it to the outgoing stream without data buffer. This is suitable for small memory system because it does not require any data buffer at application module. The file pointer of the file object increases in number of bytes forwarded. In case of *bf is less than btf without error, it means the requested bytes could not be transferred due to end of file or stream goes busy during data transfer. <linebreak/>
 Examples(Audio playback): <programlisting><codeline><highlight class="normal">/*------------------------------------------------------------------------*/</highlight></codeline>
<codeline><highlight class="normal">/*<sp/>Sample<sp/>code<sp/>of<sp/>data<sp/>transfer<sp/>function<sp/>to<sp/>be<sp/>called<sp/>back<sp/>from<sp/>f_forward<sp/>*/</highlight></codeline>
<codeline><highlight class="normal">/*------------------------------------------------------------------------*/</highlight></codeline>
<codeline><highlight class="normal">UINT<sp/>out_stream<sp/>(<sp/><sp/><sp/>/*<sp/>Returns<sp/>number<sp/>of<sp/>bytes<sp/>sent<sp/>or<sp/>stream<sp/>status<sp/>*/</highlight></codeline>
<codeline><highlight class="normal">const<sp/>BYTE<sp/>*p,<sp/><sp/>/*<sp/>Pointer<sp/>to<sp/>the<sp/>data<sp/>block<sp/>to<sp/>be<sp/>sent<sp/>*/</highlight></codeline>
<codeline><highlight class="normal">UINT<sp/>btf<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>&gt;0:<sp/>Transfer<sp/>call<sp/>(Number<sp/>of<sp/>bytes<sp/>to<sp/>be<sp/>sent).<sp/>0:<sp/>Sense<sp/>call<sp/>*/</highlight></codeline>
<codeline><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">UINT<sp/>cnt<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/>if<sp/>(btf<sp/>==<sp/>0)<sp/>{<sp/><sp/><sp/><sp/><sp/>/*<sp/>Sense<sp/>call<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>/*<sp/>Return<sp/>stream<sp/>status<sp/>(0:<sp/>Busy,<sp/>1:<sp/>Ready)<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>/*<sp/>When<sp/>once<sp/>it<sp/>returned<sp/>ready<sp/>to<sp/>sense<sp/>call,<sp/>it<sp/>must<sp/>accept<sp/>a<sp/>byte<sp/>at<sp/>least<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>/*<sp/>at<sp/>subsequent<sp/>transfer<sp/>call,<sp/>or<sp/>f_forward<sp/>will<sp/>fail<sp/>with<sp/>FR_INT_ERR.<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>if<sp/>(FIFO_READY)<sp/>cnt<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/>else<sp/>{<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>Transfer<sp/>call<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>do<sp/>{<sp/><sp/><sp/><sp/>/*<sp/>Repeat<sp/>while<sp/>there<sp/>is<sp/>any<sp/>data<sp/>to<sp/>be<sp/>sent<sp/>and<sp/>the<sp/>stream<sp/>is<sp/>ready<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FIFO_PORT<sp/>=<sp/>*p++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cnt++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>}<sp/>while<sp/>(cnt<sp/>&lt;<sp/>btf<sp/>&amp;&amp;<sp/>FIFO_READY);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>cnt;</highlight></codeline>
<codeline><highlight class="normal"><sp/>}</highlight></codeline>
<codeline><highlight class="normal">/*------------------------------------------------------------------------*/</highlight></codeline>
<codeline><highlight class="normal">/*<sp/>Sample<sp/>code<sp/>using<sp/>f_forward<sp/>function<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal">/*------------------------------------------------------------------------*/</highlight></codeline>
<codeline><highlight class="normal">FRESULT<sp/>play_file<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>char<sp/>*fn<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>Pointer<sp/>to<sp/>the<sp/>audio<sp/>file<sp/>name<sp/>to<sp/>be<sp/>played<sp/>*/</highlight></codeline>
<codeline><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">FRESULT<sp/>rc;</highlight></codeline>
<codeline><highlight class="normal"><sp/>FIL<sp/>fil;</highlight></codeline>
<codeline><highlight class="normal"><sp/>UINT<sp/>dmy;</highlight></codeline>
<codeline><highlight class="normal"><sp/>/*<sp/>Open<sp/>the<sp/>audio<sp/>file<sp/>in<sp/>read<sp/>only<sp/>mode<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/>rc<sp/>=<sp/>f_open(&amp;fil,<sp/>fn,<sp/>FA_READ);</highlight></codeline>
<codeline><highlight class="normal"><sp/>if<sp/>(rc)<sp/>return<sp/>rc;</highlight></codeline>
<codeline><highlight class="normal"><sp/>/*<sp/>Repeat<sp/>until<sp/>the<sp/>file<sp/>pointer<sp/>reaches<sp/>end<sp/>of<sp/>the<sp/>file<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/>while<sp/>(rc<sp/>==<sp/>FR_OK<sp/>&amp;&amp;<sp/>fil.fptr<sp/>&lt;<sp/>fil.fsize)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>/*<sp/>any<sp/>other<sp/>processes...<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/>/*<sp/>Fill<sp/>output<sp/>stream<sp/>periodicaly<sp/>or<sp/>on-demand<sp/>*/<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/>rc<sp/>=<sp/>f_forward(&amp;fil,<sp/>out_stream,<sp/>1000,<sp/>&amp;dmy);</highlight></codeline>
<codeline><highlight class="normal"><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/>/*<sp/>Close<sp/>the<sp/>file<sp/>and<sp/>return<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/>f_close(&amp;fil);</highlight></codeline>
<codeline><highlight class="normal"><sp/>return<sp/>rc;</highlight></codeline>
<codeline><highlight class="normal"><sp/>}</highlight></codeline>
</programlisting> <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fp</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the open file object </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">func</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the user-defined data streaming function. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">btf</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of bytes to forward in range of UINT. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">bf</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the UINT variable to return number of bytes forwarded. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>FR_OK</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_DISK_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INT_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_READY</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INVALID_OBJECT</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_TIMEOUT</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Available when _USE_FORWARD == 1 and _FS_TINY == 1. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Common/Docs/ff.dox" line="482" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1gacb865a03dbac0031ac5cb8a031f7b71c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__filesystem_1ga49d0171ecbd362cda5680a0d360db44c" kindref="member">FRESULT</ref></type>
        <definition>FRESULT f_getcwd</definition>
        <argsstring>(TCHAR *buff, UINT len)</argsstring>
        <name>f_getcwd</name>
        <param>
          <type><ref refid="ff_8h_1a03bdb8ce5895c7e261aadc2529637546" kindref="member">TCHAR</ref> *</type>
          <declname>buff</declname>
        </param>
        <param>
          <type><ref refid="integer_8h_1a36cb3b01d81ffd844bbbfb54003e06ec" kindref="member">UINT</ref></type>
          <declname>len</declname>
        </param>
        <briefdescription>
<para>The f_getcwd function retrieves the current directory. </para>        </briefdescription>
        <detaileddescription>
<para>The <ref refid="group__filesystem_1gacb865a03dbac0031ac5cb8a031f7b71c" kindref="member">f_getcwd()</ref> function retrieves full path name of the current directory of the current drive. When _VOLUMES is larger than 1, a logical drive number is added to top of the path name. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">buff</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the buffer to receive the current directory string. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">len</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the buffer in unit of TCHAR. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>FR_OK</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_DISK_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INT_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_READY</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_ENABLED</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NO_FILESYSTEM</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_TIMEOUT</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_ENOUGH_CORE</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Available when _FS_RPATH == 2. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Common/Docs/ff.dox" line="916" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1ga0ff39f75a87cbda9cd6ea65d83f16cec" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__filesystem_1ga49d0171ecbd362cda5680a0d360db44c" kindref="member">FRESULT</ref></type>
        <definition>FRESULT f_getfree</definition>
        <argsstring>(const TCHAR *path, DWORD *nclst, FATFS **fatfs)</argsstring>
        <name>f_getfree</name>
        <param>
          <type>const <ref refid="ff_8h_1a03bdb8ce5895c7e261aadc2529637546" kindref="member">TCHAR</ref> *</type>
          <declname>path</declname>
        </param>
        <param>
          <type><ref refid="integer_8h_1ad342ac907eb044443153a22f964bf0af" kindref="member">DWORD</ref> *</type>
          <declname>nclst</declname>
        </param>
        <param>
          <type><ref refid="struct_f_a_t_f_s" kindref="compound">FATFS</ref> **</type>
          <declname>fatfs</declname>
        </param>
        <briefdescription>
<para>The f_getfree function gets number of the free clusters on the volume. </para>        </briefdescription>
        <detaileddescription>
<para>The <ref refid="group__filesystem_1ga0ff39f75a87cbda9cd6ea65d83f16cec" kindref="member">f_getfree()</ref> function gets number of free clusters on the volume. The member csize in the file system object indicates number of sectors per cluster, so that the free space in unit of sector can be calcurated with this information. When FSINFO structure on the FAT32 volume is not in sync, this function can return an incorrect free cluster count. To avoid this problem, FatFs can be forced full FAT scan by _FS_NOFSINFO option. <linebreak/>
 Example: <programlisting><codeline><highlight class="normal"><sp/><sp/><sp/>FATFS<sp/>*fs;</highlight></codeline>
<codeline><highlight class="normal">DWORD<sp/>fre_clust,<sp/>fre_sect,<sp/>tot_sect;</highlight></codeline>
<codeline><highlight class="normal"><sp/>/*<sp/>Get<sp/>volume<sp/>information<sp/>and<sp/>free<sp/>clusters<sp/>of<sp/>drive<sp/>1<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/>res<sp/>=<sp/>f_getfree(&quot;1:&quot;,<sp/>&amp;fre_clust,<sp/>&amp;fs);</highlight></codeline>
<codeline><highlight class="normal"><sp/>if<sp/>(res)<sp/>die(res);</highlight></codeline>
<codeline><highlight class="normal"><sp/>/*<sp/>Get<sp/>total<sp/>sectors<sp/>and<sp/>free<sp/>sectors<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/>tot_sect<sp/>=<sp/>(fs-&gt;n_fatent<sp/>-<sp/>2)<sp/>*<sp/>fs-&gt;csize;</highlight></codeline>
<codeline><highlight class="normal"><sp/>fre_sect<sp/>=<sp/>fre_clust<sp/>*<sp/>fs-&gt;csize;</highlight></codeline>
<codeline><highlight class="normal"><sp/>/*<sp/>Print<sp/>the<sp/>free<sp/>space<sp/>(assuming<sp/>512<sp/>bytes/sector)<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/>printf(&quot;%10lu<sp/>KiB<sp/>total<sp/>drive<sp/>space.\n%10lu<sp/>KiB<sp/>available.\n&quot;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tot_sect<sp/>/<sp/>2,<sp/>fre_sect<sp/>/<sp/>2);</highlight></codeline>
</programlisting> <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">path</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the null-terminated string that specifies the logical drive. A null-string means the default drive. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">nclst</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the DWORD variable to store number of free clusters. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">fatfs</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to pointer that to store a pointer to the corresponding file system object. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>FR_OK</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_DISK_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INT_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_READY</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INVALID_DRIVE</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_ENABLED</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NO_FILESYSTEM</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_TIMEOUT</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Available when _FS_READONLY == 0 and _FS_MINIMIZE == 0. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Common/Docs/ff.dox" line="956" column="1" bodyfile="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/ff.c" bodystart="3404" bodyend="3461"/>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1gac4ff40a674bcbfe40d81b1e8e54befc6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__filesystem_1ga49d0171ecbd362cda5680a0d360db44c" kindref="member">FRESULT</ref></type>
        <definition>FRESULT f_getlabel</definition>
        <argsstring>(const TCHAR *path, TCHAR *label, DWORD *vsn)</argsstring>
        <name>f_getlabel</name>
        <param>
          <type>const <ref refid="ff_8h_1a03bdb8ce5895c7e261aadc2529637546" kindref="member">TCHAR</ref> *</type>
          <declname>path</declname>
        </param>
        <param>
          <type><ref refid="ff_8h_1a03bdb8ce5895c7e261aadc2529637546" kindref="member">TCHAR</ref> *</type>
          <declname>label</declname>
        </param>
        <param>
          <type><ref refid="integer_8h_1ad342ac907eb044443153a22f964bf0af" kindref="member">DWORD</ref> *</type>
          <declname>vsn</declname>
        </param>
        <briefdescription>
<para>The f_getlabel function returns volume label and volume serial number of a drive. <linebreak/>
 Example: </para>        </briefdescription>
        <detaileddescription>
<para><programlisting><codeline><highlight class="normal">char<sp/>str[12];</highlight></codeline>
<codeline><highlight class="normal">/*<sp/>Get<sp/>volume<sp/>label<sp/>of<sp/>the<sp/>default<sp/>drive<sp/>*/</highlight></codeline>
<codeline><highlight class="normal">f_getlabel(&quot;&quot;,<sp/>str,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal">/*<sp/>Get<sp/>volume<sp/>label<sp/>of<sp/>the<sp/>drive<sp/>2<sp/>*/</highlight></codeline>
<codeline><highlight class="normal">f_getlabel(&quot;2:&quot;,<sp/>str,<sp/>0);</highlight></codeline>
</programlisting> <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">path</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the null-terminated string that specifies the logical drive. Null-string specifies the default drive. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">label</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the buffer to store the volume label. The buffer size must be at least 12 items. If the volume has no label, a null-string will be returned. Set null pointer if this information is not needed. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">vsn</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the DWORD variable to store the volume serial number. Set null pointer if this information is not needed. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>FR_OK</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_DISK_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INT_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_READY</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INVALID_DRIVE</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_ENABLED</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NO_FILESYSTEM</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_TIMEOUT</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Available when _USE_LABEL == 1. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Common/Docs/ff.dox" line="989" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1ga0fa54bd310785ecdaed19dda8f60dac5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="ff_8h_1a03bdb8ce5895c7e261aadc2529637546" kindref="member">TCHAR</ref> *</type>
        <definition>TCHAR* f_gets</definition>
        <argsstring>(TCHAR *buff, int len, FIL *fp)</argsstring>
        <name>f_gets</name>
        <param>
          <type><ref refid="ff_8h_1a03bdb8ce5895c7e261aadc2529637546" kindref="member">TCHAR</ref> *</type>
          <declname>buff</declname>
        </param>
        <param>
          <type>int</type>
          <declname>len</declname>
        </param>
        <param>
          <type><ref refid="struct_f_i_l" kindref="compound">FIL</ref> *</type>
          <declname>fp</declname>
        </param>
        <briefdescription>
<para>The f_gets reads a string from the file. </para>        </briefdescription>
        <detaileddescription>
<para>The <ref refid="group__filesystem_1ga0fa54bd310785ecdaed19dda8f60dac5" kindref="member">f_gets()</ref> function is a wrapper function of <ref refid="group__filesystem_1gac4c3dcb6869ca252888eebabe39727b3" kindref="member">f_read()</ref> function. The read operation continues until a &apos;<linebreak/>
&apos; is stored, reached end of the file or the buffer is filled with len - 1 characters. The read string is terminated with a &apos;\0&apos;. When no character to read or any error occured during read operation, it returns a null pointer. The status of EOF and error can be examined with <ref refid="group__filesystem_1gaf0878582b1255b693b29dca3c6ecccf1" kindref="member">f_eof()</ref> and <ref refid="group__filesystem_1gad3c6dd79ef26a59629a6c8f6afe71fbf" kindref="member">f_error()</ref> macros. <linebreak/>
 When FatFs is configured to Unicode API (_LFN_UNICODE == 1), data types on the srting fuctions, <ref refid="group__filesystem_1ga62a35ee79e4913c1e31ac706241be7da" kindref="member">f_putc()</ref>, <ref refid="group__filesystem_1ga9443c00129414fbfc16a5a13ad876ced" kindref="member">f_puts()</ref>, <ref refid="group__filesystem_1ga49cccab38cd84e2d3357fef2d1df21f9" kindref="member">f_printf()</ref> and <ref refid="group__filesystem_1ga0fa54bd310785ecdaed19dda8f60dac5" kindref="member">f_gets()</ref>, is also switched to Unicode. The character encoding on the file to be read/written via those functions is selected by _STRF_ENCODE option. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">buff</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to read buffer to store the read string. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">len</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the read buffer in unit of character. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fp</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the open file object structure. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>When</parametername>
</parameternamelist>
<parameterdescription>
<para>the function succeeded, buff will be returuned. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Available when _USE_STRFUNC is 1 or 2. When it is set to 2, &apos;&apos;s contained in the file are stripped out. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Common/Docs/ff.dox" line="1153" column="1" bodyfile="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/ff.c" bodystart="4382" bodyend="4450"/>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1ga5df0ac672ada972e89ef4b003e57f964" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__filesystem_1ga49d0171ecbd362cda5680a0d360db44c" kindref="member">FRESULT</ref></type>
        <definition>FRESULT f_lseek</definition>
        <argsstring>(FIL *fp, DWORD ofs)</argsstring>
        <name>f_lseek</name>
        <param>
          <type><ref refid="struct_f_i_l" kindref="compound">FIL</ref> *</type>
          <declname>fp</declname>
        </param>
        <param>
          <type><ref refid="integer_8h_1ad342ac907eb044443153a22f964bf0af" kindref="member">DWORD</ref></type>
          <declname>ofs</declname>
        </param>
        <briefdescription>
<para>The f_lseek function moves the file read/write pointer of an open file object. It can also be used to expand the file size (cluster pre-allocation). </para>        </briefdescription>
        <detaileddescription>
<para>The <ref refid="group__filesystem_1ga5df0ac672ada972e89ef4b003e57f964" kindref="member">f_lseek()</ref> function moves the file read/write pointer of an open file. The offset can be specified in only origin from top of the file. When an offset beyond the file size is specified at write mode, the file size is expanded to the specified offset. The file data in the expanded area is undefined because no data is written to the file. This is suitable to pre-allocate a cluster chain quickly, for fast write operation. After the <ref refid="group__filesystem_1ga5df0ac672ada972e89ef4b003e57f964" kindref="member">f_lseek()</ref> function succeeded, the current read/write pointer should be checked in order to make sure the read/write pointer has been moved correctry. In case of the current read/write pointer is not the expected value, either of followings has been occured. <linebreak/>
 <itemizedlist>
<listitem><para><computeroutput>End</computeroutput> of file. The specified ofs was clipped at end of the file because the file has been opened in read-only mode. </para></listitem>
<listitem><para><computeroutput>Disk</computeroutput> full. There is insufficient free space on the volume to expand the file. <linebreak/>
 Fast seek feature is enabled when _USE_FASTSEEK is set to 1 and the member cltbl in the file object is not NULL. This feature enables fast backward/long seek operations without FAT access by using CLMT (cluster link map table). The fast seek feature is also applied to <ref refid="group__filesystem_1gac4c3dcb6869ca252888eebabe39727b3" kindref="member">f_read()</ref>/f_write() function, however, the file size cannot be expanded by <ref refid="group__filesystem_1gae6a4dfae8a9e308bdb2283a37ef680f2" kindref="member">f_write()</ref>/f_lseek() function. <linebreak/>
 The CLMT must be created in the user defined DWORD array prior to use the fast seek feature. To create the CLMT, set address of the DWORD array to the member cltbl in the file object, set the array size in unit of items into the first item and call the <ref refid="group__filesystem_1ga5df0ac672ada972e89ef4b003e57f964" kindref="member">f_lseek()</ref> function with ofs = CREATE_LINKMAP. After the function succeeded and CLMT is created, no FAT access is occured at subsequent <ref refid="group__filesystem_1gac4c3dcb6869ca252888eebabe39727b3" kindref="member">f_read()</ref>/f_write()/f_lseek() function to the file. If the function failed with FR_NOT_ENOUGH_CORE, the given array size is insufficient for the file and number of items required is returned into the first item of the array. The required array size is (number of fragments + 1) * 2 items. For example, when the file is fragmented in 5, 12 items will be required for the CLMT. <linebreak/>
 Examples: <programlisting><codeline><highlight class="normal"><sp/><sp/><sp/>/*<sp/>Open<sp/>file<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>fp<sp/>=<sp/>malloc(sizeof<sp/>(FIL));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>res<sp/>=<sp/>f_open(fp,<sp/>&quot;file.dat&quot;,<sp/>FA_READ|FA_WRITE);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>if<sp/>(res)<sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>Move<sp/>to<sp/>offset<sp/>of<sp/>5000<sp/>from<sp/>top<sp/>of<sp/>the<sp/>file<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>res<sp/>=<sp/>f_lseek(fp,<sp/>5000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>/*<sp/>Move<sp/>to<sp/>end<sp/>of<sp/>the<sp/>file<sp/>to<sp/>append<sp/>data<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>res<sp/>=<sp/>f_lseek(fp,<sp/>f_size(fp));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>/*<sp/>Forward<sp/>3000<sp/>bytes<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>res<sp/>=<sp/>f_lseek(fp,<sp/>f_tell(fp)<sp/>+<sp/>3000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>/*<sp/>Rewind<sp/>2000<sp/>bytes<sp/>(take<sp/>care<sp/>on<sp/>wraparound)<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>res<sp/>=<sp/>f_lseek(fp,<sp/>f_tell(fp)<sp/>-<sp/>2000);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>/*<sp/>Cluster<sp/>pre-allocation<sp/>(to<sp/>prevent<sp/>buffer<sp/>overrun<sp/>on<sp/>streaming<sp/>write)<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>res<sp/>=<sp/>f_open(fp,<sp/>recfile,<sp/>FA_CREATE_NEW<sp/>|<sp/>FA_WRITE);<sp/><sp/><sp/>/*<sp/>Create<sp/>a<sp/>file<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>res<sp/>=<sp/>f_lseek(fp,<sp/>PRE_SIZE);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>Expand<sp/>file<sp/>size<sp/>(cluster<sp/>pre-allocation)<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>if<sp/>(res<sp/>||<sp/>f_tell(fp)<sp/>!=<sp/>PRE_SIZE)<sp/>...<sp/><sp/><sp/>/*<sp/>Check<sp/>if<sp/>the<sp/>file<sp/>has<sp/>been<sp/>expanded<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>res<sp/>=<sp/>f_lseek(fp,<sp/>DATA_START);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>Record<sp/>data<sp/>stream<sp/>WITHOUT<sp/>cluster<sp/>allocation<sp/>delay<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>...<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>DATA_START<sp/>and<sp/>write<sp/>block<sp/>size<sp/>should<sp/>be<sp/>aligned<sp/>to<sp/>sector<sp/>boundary<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>res<sp/>=<sp/>f_truncate(fp);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>Truncate<sp/>unused<sp/>area<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>res<sp/>=<sp/>f_lseek(fp,<sp/>0);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>Put<sp/>file<sp/>header<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>res<sp/>=<sp/>f_close(fp);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">/*<sp/>Using<sp/>fast<sp/>seek<sp/>feature<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>DWORD<sp/>clmt[SZ_TBL];<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>Cluster<sp/>link<sp/>map<sp/>table<sp/>buffer<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>res<sp/>=<sp/>f_lseek(fp,<sp/>ofs1);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>This<sp/>is<sp/>normal<sp/>seek<sp/>(cltbl<sp/>is<sp/>nulled<sp/>on<sp/>file<sp/>open)<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>fp-&gt;cltbl<sp/>=<sp/>clmt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>Enable<sp/>fast<sp/>seek<sp/>feature<sp/>(cltbl<sp/>!=<sp/>NULL)<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>clmt[0]<sp/>=<sp/>SZ_TBL;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>Set<sp/>table<sp/>size<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>res<sp/>=<sp/>f_lseek(fp,<sp/>CREATE_LINKMAP);<sp/><sp/><sp/><sp/><sp/>/*<sp/>Create<sp/>CLMT<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>res<sp/>=<sp/>f_lseek(fp,<sp/>ofs2);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>This<sp/>is<sp/>fast<sp/>seek<sp/>*/</highlight></codeline>
</programlisting> <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fp</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the open file object. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ofs</parametername>
</parameternamelist>
<parameterdescription>
<para>Byte offset from top of the file. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>FR_OK</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_DISK_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INT_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_READY</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INVALID_OBJECT</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_TIMEOUT</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Available when _FS_MINIMIZE &lt;= 2. </para></simplesect>
</para></listitem>
</itemizedlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Common/Docs/ff.dox" line="369" column="1" bodyfile="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/ff.c" bodystart="3029" bodyend="3178"/>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1ga4b4d38db58e89c526cfcf53200d719d0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__filesystem_1ga49d0171ecbd362cda5680a0d360db44c" kindref="member">FRESULT</ref></type>
        <definition>FRESULT f_mkdir</definition>
        <argsstring>(const TCHAR *path)</argsstring>
        <name>f_mkdir</name>
        <param>
          <type>const <ref refid="ff_8h_1a03bdb8ce5895c7e261aadc2529637546" kindref="member">TCHAR</ref> *</type>
          <declname>path</declname>
        </param>
        <briefdescription>
<para>The f_mkdir function creates a new directory. </para>        </briefdescription>
        <detaileddescription>
<para>This function creates a new directory. <linebreak/>
 Example: <programlisting><codeline><highlight class="normal">res<sp/>=<sp/>f_mkdir(&quot;sub1&quot;);</highlight></codeline>
<codeline><highlight class="normal">if<sp/>(res)<sp/>die(res);</highlight></codeline>
<codeline><highlight class="normal">res<sp/>=<sp/>f_mkdir(&quot;sub1/sub2&quot;);</highlight></codeline>
<codeline><highlight class="normal">if<sp/>(res)<sp/>die(res);</highlight></codeline>
<codeline><highlight class="normal">res<sp/>=<sp/>f_mkdir(&quot;sub1/sub2/sub3&quot;);</highlight></codeline>
<codeline><highlight class="normal">if<sp/>(res)<sp/>die(res);</highlight></codeline>
</programlisting> <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">path</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the null-terminated string that specifies the directory name to create. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>FR_OK</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_DISK_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INT_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_READY</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NO_PATH</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INVALID_NAME</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_DENIED</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_EXIST</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_WRITE_PROTECTED</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INVALID_DRIVE</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_ENABLED</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NO_FILESYSTEM</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_TIMEOUT</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_ENOUGH_CORE</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Available when _FS_READONLY == 0 and _FS_MINIMIZE == 0. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Common/Docs/ff.dox" line="695" column="1" bodyfile="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/ff.c" bodystart="3595" bodyend="3660"/>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1ga799aff9594e708c8be357281cf85428b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__filesystem_1ga49d0171ecbd362cda5680a0d360db44c" kindref="member">FRESULT</ref></type>
        <definition>FRESULT f_mkfs</definition>
        <argsstring>(const TCHAR *path, BYTE sfd, UINT au)</argsstring>
        <name>f_mkfs</name>
        <param>
          <type>const <ref refid="ff_8h_1a03bdb8ce5895c7e261aadc2529637546" kindref="member">TCHAR</ref> *</type>
          <declname>path</declname>
        </param>
        <param>
          <type><ref refid="integer_8h_1a4ae1dab0fb4b072a66584546209e7d58" kindref="member">BYTE</ref></type>
          <declname>sfd</declname>
        </param>
        <param>
          <type><ref refid="integer_8h_1a36cb3b01d81ffd844bbbfb54003e06ec" kindref="member">UINT</ref></type>
          <declname>au</declname>
        </param>
        <briefdescription>
<para>The f_mkfs fucntion creates an FAT file system on the logical drive. </para>        </briefdescription>
        <detaileddescription>
<para>The <ref refid="group__filesystem_1ga799aff9594e708c8be357281cf85428b" kindref="member">f_mkfs()</ref> function creates an FAT volume on the specified logical drive. When FDISK format is specified, a primary partition occupies entire space of the physical drive is created and then an FAT volume is created on the partition. When SFD format is specified, the FAT volume starts from the first sector of the physical drive. <linebreak/>
 If the logical drive is bound to the specific partition (1-4) by multiple partition feature (_MULTI_PARTITION), the FAT volume is created into the partition. In this case, the second argument sfd is ignored. The physical drive must have been partitioned with <ref refid="group__filesystem_1ga0c1bd3e3872abbda0e256e7c73da9f3b" kindref="member">f_fdisk()</ref> function or any other partitioning tools prior to create the FAT volume with this function. <linebreak/>
 Note that there are two partitioning rules, FDISK and SFD. The FDISK partitioning is usually used for harddisk, MMC, SDC, CFC and U Disk. It can divide a physical drive into one or more partitions with a partition table on the MBR. However Windows does not support multiple partition on the removable disk. The SFD is non-partitioned method. The FAT volume starts from the first sector on the physical drive without partition table. It is usually used for floppy disk, Microdrive, optical disk and any type of super-floppy media. <linebreak/>
 The FAT sub-type, FAT12/FAT16/FAT32, is determined by number of clusters on the volume and nothing else, according to the FAT specification issued by Microsoft. Thus which FAT sub-type is selected, is depends on the volume size and the specified cluster size. The cluster size affects read/write throughput and space usage efficiency. Larger cluster size increases the read/write throughput and decreases the space usage efficiency of the volume. <linebreak/>
 In case of the number of clusters gets near the FAT sub-type boundaries, the function can fail with FR_MKFS_ABORTED. <linebreak/>
 Example: <programlisting><codeline><highlight class="normal">/*<sp/>Format<sp/>the<sp/>default<sp/>drive<sp/>*/</highlight></codeline>
<codeline><highlight class="normal">int<sp/>main<sp/>(void)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/>FATFS<sp/>fs;<sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>File<sp/>system<sp/>object<sp/>(volume<sp/>work<sp/>area)<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/>FIL<sp/>fil;<sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>File<sp/>object<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/>FRESULT<sp/>res;<sp/><sp/><sp/>/*<sp/>API<sp/>result<sp/>code<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/>UINT<sp/>bw;<sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>Bytes<sp/>written<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/>/*<sp/>Register<sp/>work<sp/>area<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/>f_mount(&amp;fs,<sp/>&quot;&quot;,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/>/*<sp/>Create<sp/>FAT<sp/>volume<sp/>with<sp/>default<sp/>cluster<sp/>size<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/>res<sp/>=<sp/>f_mkfs(&quot;&quot;,<sp/>0,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/>if<sp/>(res)<sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/>/*<sp/>Create<sp/>a<sp/>file<sp/>as<sp/>new<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/>res<sp/>=<sp/>f_open(&amp;fil,<sp/>&quot;hello.txt&quot;,<sp/>FA_CREATE_NEW<sp/>|<sp/>FA_WRITE);</highlight></codeline>
<codeline><highlight class="normal"><sp/>if<sp/>(res)<sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/>/*<sp/>Write<sp/>a<sp/>message<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/>f_write(&amp;fil,<sp/>&quot;Hello,<sp/>World!\r\n&quot;,<sp/>15,<sp/>&amp;bw);</highlight></codeline>
<codeline><highlight class="normal"><sp/>if<sp/>(bw<sp/>!=<sp/>15)<sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/>/*<sp/>Close<sp/>the<sp/>file<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/>f_close(&amp;fil);</highlight></codeline>
<codeline><highlight class="normal"><sp/>/*<sp/>Unregister<sp/>work<sp/>area<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/>f_mount(0,<sp/>&quot;&quot;,<sp/>0);</highlight></codeline>
</programlisting> <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">path</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the null-terminated string that specifies the logical drive to be formatted. If there is no drive number, it means the default drive. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">sfd</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies partitioning rule (FDISK(0) or SFD(1)). This argument will be ignored on some case. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">au</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies size of the allocation unit (cluter) in number of bytes or sectors. When the value is from 1 to 128, it specifies number of sectors. When the value is &gt;= _MIN_SS, it specifies number of bytes. If any invalid value, zero or not power of 2, is given, the cluster size is automatically determined depends on the volume size. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>FR_OK</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_DISK_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_READY</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_WRITE_PROTECTED</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INVALID_DRIVE</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_ENABLED</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_MKFS_ABORTED</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INVALID_PARAMETER</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Available when _FS_READOLNY == 0 and _USE_MKFS == 1. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Common/Docs/ff.dox" line="1086" column="1" bodyfile="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/ff.c" bodystart="4063" bodyend="4300"/>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1ga16a934c2bbfa2160295810adc49d5509" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__filesystem_1ga49d0171ecbd362cda5680a0d360db44c" kindref="member">FRESULT</ref></type>
        <definition>FRESULT f_mount</definition>
        <argsstring>(FATFS *fs, const TCHAR *path, BYTE opt)</argsstring>
        <name>f_mount</name>
        <param>
          <type><ref refid="struct_f_a_t_f_s" kindref="compound">FATFS</ref> *</type>
          <declname>fs</declname>
        </param>
        <param>
          <type>const <ref refid="ff_8h_1a03bdb8ce5895c7e261aadc2529637546" kindref="member">TCHAR</ref> *</type>
          <declname>path</declname>
        </param>
        <param>
          <type><ref refid="integer_8h_1a4ae1dab0fb4b072a66584546209e7d58" kindref="member">BYTE</ref></type>
          <declname>opt</declname>
        </param>
        <briefdescription>
<para>The f_mount fucntion registers/unregisters file system object to the FatFs module. </para>        </briefdescription>
        <detaileddescription>
<para>The <ref refid="group__filesystem_1ga16a934c2bbfa2160295810adc49d5509" kindref="member">f_mount()</ref> function registers/unregisters a file system object used for the logical drive to the FatFs module as follows: <linebreak/>
 1.Determines the logical drive which specified by path. <linebreak/>
 2.Clears and unregisters the regsitered work area of the drive. <linebreak/>
 3.Clears and registers the new work area to the drive if fs is not NULL. <linebreak/>
 4.Performs volume mount process to the drive if forced mount is specified. <linebreak/>
 The file system object is the work area needed for each logical drive. It must be given to the logical drive with this function prior to use any other file functions except for <ref refid="group__filesystem_1ga0c1bd3e3872abbda0e256e7c73da9f3b" kindref="member">f_fdisk()</ref> function. To unregister a work area, specify a NULL to the fs, and then the work area can be discarded. <linebreak/>
 If forced mount is not specified, this function always succeeds regardless of the physical drive status due to delayed mount feature. It only clears (de-initializes) the given work area and registers its address to the internal table. No activity of the physical drive in this function. It can also be used to force de-initialized the registered work area of a logical drive. The volume mount processes, initialize the corresponding physical drive, find the FAT volume in it and initialize the work area, is performed in the subsequent file access functions when either or both of following condition is true. <linebreak/>
<itemizedlist>
<listitem><para>File system object is not initialized. It is cleared by <ref refid="group__filesystem_1ga16a934c2bbfa2160295810adc49d5509" kindref="member">f_mount()</ref>.</para></listitem><listitem><para>Physical drive is not initialized. It is de-initialized by system reset or media removal. <linebreak/>
 If the function with forced mount failed, it means that the file system object has been registered successfully but the volume is currently not ready to use. Mount process will also be attempted in subsequent file access functions. <linebreak/>
 If implementation of the disk I/O layer lacks media change detection, application program needs to perform a <ref refid="group__filesystem_1ga16a934c2bbfa2160295810adc49d5509" kindref="member">f_mount()</ref> after each media change to force cleared the file system object.</para></listitem></itemizedlist>
</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fs</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the new file system object to be registered. Null pointer unregisters the registered file system object. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">path</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the null-terminated string that specifies the logical drive. The string with no drive number means the default drive. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">opt</parametername>
</parameternamelist>
<parameterdescription>
<para>Initialization option.<itemizedlist>
<listitem><para>0: Do not mount now (to be mounted later),</para></listitem><listitem><para>1: Force mounted the volume to check if the FAT volume is available. </para></listitem></itemizedlist>
</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>FR_OK</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INVALID_DRIVE</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_DISK_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_READY</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NO_FILESYSTEM</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Always available. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Common/Docs/ff.dox" line="217" column="1" bodyfile="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/ff.c" bodystart="2402" bodyend="2440"/>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1gaefdef7126128d99d0b3bd82c28e54d80" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__filesystem_1ga49d0171ecbd362cda5680a0d360db44c" kindref="member">FRESULT</ref></type>
        <definition>FRESULT f_open</definition>
        <argsstring>(FIL *fp, const TCHAR *path, BYTE mode)</argsstring>
        <name>f_open</name>
        <param>
          <type><ref refid="struct_f_i_l" kindref="compound">FIL</ref> *</type>
          <declname>fp</declname>
        </param>
        <param>
          <type>const <ref refid="ff_8h_1a03bdb8ce5895c7e261aadc2529637546" kindref="member">TCHAR</ref> *</type>
          <declname>path</declname>
        </param>
        <param>
          <type><ref refid="integer_8h_1a4ae1dab0fb4b072a66584546209e7d58" kindref="member">BYTE</ref></type>
          <declname>mode</declname>
        </param>
        <briefdescription>
<para>The f_open function creates a file object to be used to access the file. </para>        </briefdescription>
        <detaileddescription>
<para>After <ref refid="group__filesystem_1gaefdef7126128d99d0b3bd82c28e54d80" kindref="member">f_open()</ref> function succeeded, the file object is valid. The file object is used for subsequent read/write functions to identify the file. To close an open file, use <ref refid="group__filesystem_1ga53882db20ef4323dcfd1874d7733ffc3" kindref="member">f_close()</ref> function. If the file is modified and not closed properly, the file data will be collapsed. <linebreak/>
 If duplicated file open is needed, read here carefully. However duplicated open of a file with write mode flag is always prohibited. <linebreak/>
 Before using any file function, a work area (file system object) must be registered to the logical drive with <ref refid="group__filesystem_1ga16a934c2bbfa2160295810adc49d5509" kindref="member">f_mount()</ref> function. All API functions except for <ref refid="group__filesystem_1ga0c1bd3e3872abbda0e256e7c73da9f3b" kindref="member">f_fdisk()</ref> function can work after this procedure. <linebreak/>
 Examples: <programlisting><codeline><highlight class="normal"><sp/>/*<sp/>Read<sp/>a<sp/>text<sp/>file<sp/>and<sp/>display<sp/>it<sp/>*/</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/>FATFS<sp/>FatFs;<sp/><sp/><sp/>/*<sp/>Work<sp/>area<sp/>(file<sp/>system<sp/>object)<sp/>for<sp/>logical<sp/>drive<sp/>*/</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/>int<sp/>main<sp/>(void)</highlight></codeline>
<codeline><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>FIL<sp/>fil;<sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>File<sp/>object<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>char<sp/>line[82];<sp/>/*<sp/>Line<sp/>buffer<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>FRESULT<sp/>fr;<sp/><sp/><sp/><sp/>/*<sp/>FatFs<sp/>return<sp/>code<sp/>*/</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>/*<sp/>Register<sp/>work<sp/>area<sp/>to<sp/>the<sp/>default<sp/>drive<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>f_mount(&amp;FatFs,<sp/>&quot;&quot;,<sp/>0);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>/*<sp/>Open<sp/>a<sp/>text<sp/>file<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>fr<sp/>=<sp/>f_open(&amp;fil,<sp/>&quot;message.txt&quot;,<sp/>FA_READ);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>if<sp/>(fr)<sp/>return<sp/>(int)fr;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>/*<sp/>Read<sp/>all<sp/>lines<sp/>and<sp/>display<sp/>it<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>while<sp/>(f_gets(line,<sp/>sizeof<sp/>line,<sp/>&amp;fil))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(line);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>/*<sp/>Close<sp/>the<sp/>file<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>f_close(&amp;fil);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>return<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> <programlisting><codeline><highlight class="normal">/*<sp/>Copy<sp/>a<sp/>file<sp/>&quot;file.bin&quot;<sp/>on<sp/>the<sp/>drive<sp/>1<sp/>to<sp/>drive<sp/>0<sp/>*/</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">int<sp/>main<sp/>(void)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>FATFS<sp/>fs[2];<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>Work<sp/>area<sp/>(file<sp/>system<sp/>object)<sp/>for<sp/>logical<sp/>drives<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>FIL<sp/>fsrc,<sp/>fdst;<sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>File<sp/>objects<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>BYTE<sp/>buffer[4096];<sp/><sp/><sp/>/*<sp/>File<sp/>copy<sp/>buffer<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>FRESULT<sp/>fr;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>FatFs<sp/>function<sp/>common<sp/>result<sp/>code<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>UINT<sp/>br,<sp/>bw;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>File<sp/>read/write<sp/>count<sp/>*/</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/*<sp/>Register<sp/>work<sp/>area<sp/>for<sp/>each<sp/>logical<sp/>drive<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>f_mount(&amp;fs[0],<sp/>&quot;0:&quot;,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>f_mount(&amp;fs[1],<sp/>&quot;1:&quot;,<sp/>0);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>/*<sp/>Open<sp/>source<sp/>file<sp/>on<sp/>the<sp/>drive<sp/>1<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>fr<sp/>=<sp/>f_open(&amp;fsrc,<sp/>&quot;1:file.bin&quot;,<sp/>FA_OPEN_EXISTING<sp/>|<sp/>FA_READ);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>if<sp/>(fr)<sp/>return<sp/>(int)fr;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>/*<sp/>Create<sp/>destination<sp/>file<sp/>on<sp/>the<sp/>drive<sp/>0<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>fr<sp/>=<sp/>f_open(&amp;fdst,<sp/>&quot;0:file.bin&quot;,<sp/>FA_CREATE_ALWAYS<sp/>|<sp/>FA_WRITE);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>if<sp/>(fr)<sp/>return<sp/>(int)fr;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>/*<sp/>Copy<sp/>source<sp/>to<sp/>destination<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>for<sp/>(;;)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fr<sp/>=<sp/>f_read(&amp;fsrc,<sp/>buffer,<sp/>sizeof<sp/>buffer,<sp/>&amp;br);<sp/><sp/>/*<sp/>Read<sp/>a<sp/>chunk<sp/>of<sp/>source<sp/>file<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(fr<sp/>||<sp/>br<sp/>==<sp/>0)<sp/>break;<sp/>/*<sp/>error<sp/>or<sp/>eof<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fr<sp/>=<sp/>f_write(&amp;fdst,<sp/>buffer,<sp/>br,<sp/>&amp;bw);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>Write<sp/>it<sp/>to<sp/>the<sp/>destination<sp/>file<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(fr<sp/>||<sp/>bw<sp/>&lt;<sp/>br)<sp/>break;<sp/>/*<sp/>error<sp/>or<sp/>disk<sp/>full<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>/*<sp/>Close<sp/>open<sp/>files<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>f_close(&amp;fsrc);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>f_close(&amp;fdst);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>/*<sp/>Unregister<sp/>work<sp/>area<sp/>prior<sp/>to<sp/>discard<sp/>it<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>f_mount(NULL,<sp/>&quot;0:&quot;,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>f_mount(NULL,<sp/>&quot;1:&quot;,<sp/>0);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>return<sp/>(int)fr;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">fp</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the blank file object structure to be created. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">path</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to a null-terminated string that specifies the file name to open or create. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">mode</parametername>
</parameternamelist>
<parameterdescription>
<para>Mode flags that specifies the type of access and open method for the file. It is specified by a combination of following flags.<linebreak/>
<table rows="7" cols="2"><row>
<entry thead="yes"><para>Value </para></entry><entry thead="yes"><para>Description  </para></entry></row>
<row>
<entry thead="no"><para>FA_READ </para></entry><entry thead="no"><para>Specifies read access to the object. Data can be read from the file. Combine with FA_WRITE for read-write access. </para></entry></row>
<row>
<entry thead="no"><para>FA_WRITE </para></entry><entry thead="no"><para>Specifies write access to the object. Data can be written to the file. Combine with FA_READ for read-write access. </para></entry></row>
<row>
<entry thead="no"><para>FA_OPEN_EXISTING </para></entry><entry thead="no"><para>Opens the file. The function fails if the file is not existing. (Default) . </para></entry></row>
<row>
<entry thead="no"><para>FA_OPEN_ALWAYS </para></entry><entry thead="no"><para>Opens the file if it is existing. If not, a new file is created. To append data to the file, use <ref refid="group__filesystem_1ga5df0ac672ada972e89ef4b003e57f964" kindref="member">f_lseek()</ref> function after file open in this method. </para></entry></row>
<row>
<entry thead="no"><para>FA_CREATE_NEW </para></entry><entry thead="no"><para>Creates a new file. The function fails with FR_EXIST if the file is existing. </para></entry></row>
<row>
<entry thead="no"><para>FA_CREATE_NEW </para></entry><entry thead="no"><para>Creates a new file. If the file is existing, it will be truncated and overwritten. <linebreak/>
 </para></entry></row>
</table>
</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>FR_OK</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_DISK_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INT_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_READY</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NO_FILE</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NO_PATH</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INVALID_NAME</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_DENIED</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_EXIST</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INVALID_OBJECT</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_WRITE_PROTECTED</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INVALID_DRIVE</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_ENABLED</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NO_FILESYSTEM</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_TIMEOUT</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_LOCKED</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_ENOUGH_CORE</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_TOO_MANY_OPEN_FILES</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Always available. The mode flags, FA_WRITE, FA_CREATE_ALWAYS, FA_CREATE_NEW and FA_OPEN_ALWAYS, are not available when _FS_READONLY == 1. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Common/Docs/ff.dox" line="175" column="1" bodyfile="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/ff.c" bodystart="2449" bodyend="2577"/>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1gab63b213c75f7335fbb63a1f3f70e5fc7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__filesystem_1ga49d0171ecbd362cda5680a0d360db44c" kindref="member">FRESULT</ref></type>
        <definition>FRESULT f_opendir</definition>
        <argsstring>(DIR *dp, const TCHAR *path)</argsstring>
        <name>f_opendir</name>
        <param>
          <type><ref refid="struct_d_i_r" kindref="compound">DIR</ref> *</type>
          <declname>dp</declname>
        </param>
        <param>
          <type>const <ref refid="ff_8h_1a03bdb8ce5895c7e261aadc2529637546" kindref="member">TCHAR</ref> *</type>
          <declname>path</declname>
        </param>
        <briefdescription>
<para>The f_opendir function opens a directory. </para>        </briefdescription>
        <detaileddescription>
<para>The <ref refid="group__filesystem_1gab63b213c75f7335fbb63a1f3f70e5fc7" kindref="member">f_opendir()</ref> function opens an exsisting directory and creates a directory object for subsequent <ref refid="group__filesystem_1gab39e82a110695de45f416f3149358012" kindref="member">f_readdir()</ref> function. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">dp</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the blank directory object to create a new one. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">path</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the null-terminated string that specifies the directory name to be opened. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>FR_OK</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_DISK_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INT_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_READY</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NO_PATH</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INVALID_NAME</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INVALID_OBJECT</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INVALID_DRIVE</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_ENABLED</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NO_FILESYSTEM</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_TIMEOUT</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_ENOUGH_CORE</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_TOO_MANY_OPEN_FILES</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Available when _FS_MINIMIZE &lt;= 1. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Common/Docs/ff.dox" line="570" column="1" bodyfile="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/ff.c" bodystart="3187" bodyend="3234"/>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1ga49cccab38cd84e2d3357fef2d1df21f9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int f_printf</definition>
        <argsstring>(FIL *fp, const TCHAR *fmt,...)</argsstring>
        <name>f_printf</name>
        <param>
          <type><ref refid="struct_f_i_l" kindref="compound">FIL</ref> *</type>
          <declname>fp</declname>
        </param>
        <param>
          <type>const <ref refid="ff_8h_1a03bdb8ce5895c7e261aadc2529637546" kindref="member">TCHAR</ref> *</type>
          <declname>fmt</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
<para>The f_printf function writes formatted string to the file. </para>        </briefdescription>
        <detaileddescription>
<para>The <ref refid="group__filesystem_1ga49cccab38cd84e2d3357fef2d1df21f9" kindref="member">f_printf()</ref> is a wrapper function of <ref refid="group__filesystem_1gae6a4dfae8a9e308bdb2283a37ef680f2" kindref="member">f_write()</ref>. The format control directive is a sub-set of standard library shown as follows:<itemizedlist>
<listitem><para>Type: c C s S d D u U x X b B</para></listitem><listitem><para>Size: l L</para></listitem><listitem><para>Flag: 0 - <linebreak/>
 Example: <programlisting><codeline><highlight class="normal">f_printf(&amp;fil,<sp/>&quot;%d&quot;,<sp/>1234);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>&quot;1234&quot;<sp/>*/</highlight></codeline>
<codeline><highlight class="normal">f_printf(&amp;fil,<sp/>&quot;%6d,%3d%%&quot;,<sp/>-200,<sp/>5);<sp/><sp/>/*<sp/>&quot;<sp/><sp/>-200,<sp/><sp/>5%&quot;<sp/>*/</highlight></codeline>
<codeline><highlight class="normal">f_printf(&amp;fil,<sp/>&quot;%ld&quot;,<sp/>12345L);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>&quot;12345&quot;<sp/>*/</highlight></codeline>
<codeline><highlight class="normal">f_printf(&amp;fil,<sp/>&quot;%06d&quot;,<sp/>25);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>&quot;000025&quot;<sp/>*/</highlight></codeline>
<codeline><highlight class="normal">f_printf(&amp;fil,<sp/>&quot;%06d&quot;,<sp/>-25);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>&quot;000-25&quot;<sp/>*/</highlight></codeline>
<codeline><highlight class="normal">f_printf(&amp;fil,<sp/>&quot;%-6d&quot;,<sp/>25);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>&quot;25<sp/><sp/><sp/><sp/>&quot;<sp/>*/</highlight></codeline>
<codeline><highlight class="normal">f_printf(&amp;fil,<sp/>&quot;%u&quot;,<sp/>-1);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>&quot;65535&quot;<sp/>or<sp/>&quot;4294967295&quot;<sp/>*/</highlight></codeline>
<codeline><highlight class="normal">f_printf(&amp;fil,<sp/>&quot;%04x&quot;,<sp/>0xAB3);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>&quot;0ab3&quot;<sp/>*/</highlight></codeline>
<codeline><highlight class="normal">f_printf(&amp;fil,<sp/>&quot;%08LX&quot;,<sp/>0x123ABCL);<sp/><sp/><sp/><sp/>/*<sp/>&quot;00123ABC&quot;<sp/>*/</highlight></codeline>
<codeline><highlight class="normal">f_printf(&amp;fil,<sp/>&quot;%016b&quot;,<sp/>0x550F);<sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>&quot;0101010100001111&quot;<sp/>*/</highlight></codeline>
<codeline><highlight class="normal">f_printf(&amp;fil,<sp/>&quot;%s&quot;,<sp/>&quot;String&quot;);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>&quot;String&quot;<sp/>*/</highlight></codeline>
<codeline><highlight class="normal">f_printf(&amp;fil,<sp/>&quot;%8s&quot;,<sp/>&quot;abc&quot;);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>&quot;<sp/><sp/><sp/><sp/><sp/>abc&quot;<sp/>*/</highlight></codeline>
<codeline><highlight class="normal">f_printf(&amp;fil,<sp/>&quot;%-8s&quot;,<sp/>&quot;abc&quot;);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>&quot;abc<sp/><sp/><sp/><sp/><sp/>&quot;<sp/>*/</highlight></codeline>
<codeline><highlight class="normal">f_printf(&amp;fil,<sp/>&quot;%c&quot;,<sp/>&apos;a&apos;);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>&quot;a&quot;<sp/>*/</highlight></codeline>
<codeline><highlight class="normal">f_printf(&amp;fil,<sp/>&quot;%f&quot;,<sp/>10.0);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>f_printf<sp/>lacks<sp/>floating<sp/>point<sp/>support<sp/>*/</highlight></codeline>
</programlisting> <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fp</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the open file object structure. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fmt</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the null terminated format string. The terminator charactor will not be written. ... Optional arguments... </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>When</parametername>
</parameternamelist>
<parameterdescription>
<para>the function succeeded, it returns number of characters written. When the function failed due to disk full or any error, an EOF (-1) will be returned. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Available when _FS_READONLY == 0 and _USE_STRFUNC is 1 or 2. When it is set to 2, &apos;<linebreak/>
&apos;s contained in the output are converted to &apos;&apos;+&apos;<linebreak/>
&apos;. <linebreak/>
 When FatFs is configured to Unicode API (_LFN_UNICODE == 1), data types on the srting fuctions, <ref refid="group__filesystem_1ga62a35ee79e4913c1e31ac706241be7da" kindref="member">f_putc()</ref>, <ref refid="group__filesystem_1ga9443c00129414fbfc16a5a13ad876ced" kindref="member">f_puts()</ref>, <ref refid="group__filesystem_1ga49cccab38cd84e2d3357fef2d1df21f9" kindref="member">f_printf()</ref> and <ref refid="group__filesystem_1ga0fa54bd310785ecdaed19dda8f60dac5" kindref="member">f_gets()</ref>, is also switched to Unicode. The character encoding on the file to be read/written via those functions is selected by _STRF_ENCODE option. </para></simplesect>
</para></listitem></itemizedlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Common/Docs/ff.dox" line="1225" column="1" bodyfile="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/ff.c" bodystart="4579" bodyend="4674"/>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1ga62a35ee79e4913c1e31ac706241be7da" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int f_putc</definition>
        <argsstring>(TCHAR chr, FIL *fp)</argsstring>
        <name>f_putc</name>
        <param>
          <type><ref refid="ff_8h_1a03bdb8ce5895c7e261aadc2529637546" kindref="member">TCHAR</ref></type>
          <declname>chr</declname>
        </param>
        <param>
          <type><ref refid="struct_f_i_l" kindref="compound">FIL</ref> *</type>
          <declname>fp</declname>
        </param>
        <briefdescription>
<para>The f_putc funciton puts a character to the file. </para>        </briefdescription>
        <detaileddescription>
<para>The <ref refid="group__filesystem_1ga62a35ee79e4913c1e31ac706241be7da" kindref="member">f_putc()</ref> function is a wrapper function of <ref refid="group__filesystem_1gae6a4dfae8a9e308bdb2283a37ef680f2" kindref="member">f_write()</ref> function. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">chr</parametername>
</parameternamelist>
<parameterdescription>
<para>A character to be put. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fp</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the open file object structuer. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>When</parametername>
</parameternamelist>
<parameterdescription>
<para>the character was written successfuly, it returns number of characters written. When the function failed due to disk full or any error, an EOF (-1) will be returned. <linebreak/>
 When FatFs is configured to Unicode API (_LFN_UNICODE == 1), character encoding on the string fuctions, <ref refid="group__filesystem_1ga62a35ee79e4913c1e31ac706241be7da" kindref="member">f_putc()</ref>, <ref refid="group__filesystem_1ga9443c00129414fbfc16a5a13ad876ced" kindref="member">f_puts()</ref>, <ref refid="group__filesystem_1ga49cccab38cd84e2d3357fef2d1df21f9" kindref="member">f_printf()</ref> and <ref refid="group__filesystem_1ga0fa54bd310785ecdaed19dda8f60dac5" kindref="member">f_gets()</ref>, is also switched to Unicode. The character encoding on the file to be read/written via those functions is selected by _STRF_ENCODE option. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Available when _FS_READONLY == 0 and _USE_STRFUNC is 1 or 2. When it is set to 2, a &apos;<linebreak/>
&apos; is converted to &apos;&apos;+&apos;<linebreak/>
&apos;. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Common/Docs/ff.dox" line="1171" column="1" bodyfile="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/ff.c" bodystart="4524" bodyend="4542"/>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1ga9443c00129414fbfc16a5a13ad876ced" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int f_puts</definition>
        <argsstring>(const TCHAR *str, FIL *fp)</argsstring>
        <name>f_puts</name>
        <param>
          <type>const <ref refid="ff_8h_1a03bdb8ce5895c7e261aadc2529637546" kindref="member">TCHAR</ref> *</type>
          <declname>str</declname>
        </param>
        <param>
          <type><ref refid="struct_f_i_l" kindref="compound">FIL</ref> *</type>
          <declname>fp</declname>
        </param>
        <briefdescription>
<para>The f_puts function writes a string to the file. </para>        </briefdescription>
        <detaileddescription>
<para>The <ref refid="group__filesystem_1ga9443c00129414fbfc16a5a13ad876ced" kindref="member">f_puts()</ref> function is a wrapper function of <ref refid="group__filesystem_1gae6a4dfae8a9e308bdb2283a37ef680f2" kindref="member">f_write()</ref> function. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">str</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the null terminated string to be written. The terminator character will not be written. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fp</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the open file object structure. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>When</parametername>
</parameternamelist>
<parameterdescription>
<para>the function succeeded, it returns number of characters written. When the write operation is aborted due to disk full or any error, an EOF (-1) will be returned. <linebreak/>
 When FatFs is configured to Unicode API (_LFN_UNICODE == 1), character encoding on the srting fuctions, <ref refid="group__filesystem_1ga62a35ee79e4913c1e31ac706241be7da" kindref="member">f_putc()</ref>, <ref refid="group__filesystem_1ga9443c00129414fbfc16a5a13ad876ced" kindref="member">f_puts()</ref>, <ref refid="group__filesystem_1ga49cccab38cd84e2d3357fef2d1df21f9" kindref="member">f_printf()</ref> and <ref refid="group__filesystem_1ga0fa54bd310785ecdaed19dda8f60dac5" kindref="member">f_gets()</ref>, is also switched to Unicode. The character encoding on the file to be read/written via those functions is selected by _STRF_ENCODE option. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Available when _FS_READONLY == 0 and _USE_STRFUNC is 1 or 2. When it is set to 2, &apos;<linebreak/>
&apos;s contained in the string are converted to &apos;&apos;+&apos;<linebreak/>
&apos;. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Common/Docs/ff.dox" line="1187" column="1" bodyfile="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/ff.c" bodystart="4551" bodyend="4570"/>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1gac4c3dcb6869ca252888eebabe39727b3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__filesystem_1ga49d0171ecbd362cda5680a0d360db44c" kindref="member">FRESULT</ref></type>
        <definition>FRESULT f_read</definition>
        <argsstring>(FIL *fp, void *buff, UINT btr, UINT *br)</argsstring>
        <name>f_read</name>
        <param>
          <type><ref refid="struct_f_i_l" kindref="compound">FIL</ref> *</type>
          <declname>fp</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>buff</declname>
        </param>
        <param>
          <type><ref refid="integer_8h_1a36cb3b01d81ffd844bbbfb54003e06ec" kindref="member">UINT</ref></type>
          <declname>btr</declname>
        </param>
        <param>
          <type><ref refid="integer_8h_1a36cb3b01d81ffd844bbbfb54003e06ec" kindref="member">UINT</ref> *</type>
          <declname>br</declname>
        </param>
        <briefdescription>
<para>The f_read function reads data from a file. </para>        </briefdescription>
        <detaileddescription>
<para>The file read/write pointer of the file object advances number of bytes read. After the function succeeded, *br should be checked to detect end of the file. In case of *br is less than btr, it means the read/write pointer reached end of the file during read operation.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fp</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the open file object. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">buff</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the buffer to store read data. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">btr</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of bytes to read in range of UINT type. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">br</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the UINT variable to return number of bytes read. The value is always valid after the function call regardless of the result. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>FR_OK</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_DISK_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INT_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_READY</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INVALID_OBJECT</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_TIMEOUT</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Always available. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Common/Docs/ff.dox" line="267" column="1" bodyfile="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/ff.c" bodystart="2586" bodyend="2677"/>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1gab39e82a110695de45f416f3149358012" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__filesystem_1ga49d0171ecbd362cda5680a0d360db44c" kindref="member">FRESULT</ref></type>
        <definition>FRESULT f_readdir</definition>
        <argsstring>(DIR *dp, FILINFO *fno)</argsstring>
        <name>f_readdir</name>
        <param>
          <type><ref refid="struct_d_i_r" kindref="compound">DIR</ref> *</type>
          <declname>dp</declname>
        </param>
        <param>
          <type><ref refid="struct_f_i_l_i_n_f_o" kindref="compound">FILINFO</ref> *</type>
          <declname>fno</declname>
        </param>
        <briefdescription>
<para>The f_readdir function reads directory entries. </para>        </briefdescription>
        <detaileddescription>
<para>The <ref refid="group__filesystem_1gab39e82a110695de45f416f3149358012" kindref="member">f_readdir()</ref> function reads directory items, file and directory, in sequence. All items in the directory can be read by calling <ref refid="group__filesystem_1gab39e82a110695de45f416f3149358012" kindref="member">f_readdir()</ref> function repeatedly. When relative path feature is enabled (_FS_RPATH &gt;= 1), dot entries (&quot;.&quot; and &quot;..&quot;) are not filtered out and they will appear in the read items. When all directory items have been read and no item to read, a null string is returned into the fname[] without any error. When a null pointer is given to the fno, the read index of the directory object is rewinded. <linebreak/>
 When LFN feature is enabled, lfname and lfsize in the file information structure must be initialized with valid value prior to use it. The lfname is a pointer to the LFN read buffer. The lfsize is size of the LFN read buffer in unit of TCHAR. If the LFN is not needed, set a null pointer to the lfname and the LFN is not returned. A null string will be returned into the LFN read buffer in case of following conditions. <linebreak/>
<itemizedlist>
<listitem><para>The directory item has no LFN information.</para></listitem><listitem><para>Either the size of read buffer or LFN working buffer is insufficient for the LFN.</para></listitem><listitem><para>The LFN contains any Unicode character that cannot be converted to OEM code. (not the case at Unicode API cfg.) <linebreak/>
 When the directory item has no LFN information, lower case characters can be contained in the fname[]. <linebreak/>
 Sample Code: <programlisting><codeline><highlight class="normal"><sp/>FRESULT<sp/>scan_files<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/>char*<sp/>path<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>Start<sp/>node<sp/>to<sp/>be<sp/>scanned<sp/>(also<sp/>used<sp/>as<sp/>work<sp/>area)<sp/>*/</highlight></codeline>
<codeline><highlight class="normal">)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>FRESULT<sp/>res;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>FILINFO<sp/>fno;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>DIR<sp/>dir;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>char<sp/>*fn;<sp/><sp/><sp/>/*<sp/>This<sp/>function<sp/>assumes<sp/>non-Unicode<sp/>configuration<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>#if<sp/>_USE_LFN</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>char<sp/>lfn[_MAX_LFN<sp/>+<sp/>1];<sp/><sp/><sp/>/*<sp/>Buffer<sp/>to<sp/>store<sp/>the<sp/>LFN<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>fno.lfname<sp/>=<sp/>lfn;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>fno.lfsize<sp/>=<sp/>sizeof<sp/>lfn;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res<sp/>=<sp/>f_opendir(&amp;dir,<sp/>path);<sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>Open<sp/>the<sp/>directory<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(res<sp/>==<sp/>FR_OK)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>strlen(path);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>for<sp/>(;;)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/>f_readdir(&amp;dir,<sp/>&amp;fno);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>Read<sp/>a<sp/>directory<sp/>item<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(res<sp/>!=<sp/>FR_OK<sp/>||<sp/>fno.fname[0]<sp/>==<sp/>0)<sp/>break;<sp/><sp/>/*<sp/>Break<sp/>on<sp/>error<sp/>or<sp/>end<sp/>of<sp/>dir<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(fno.fname[0]<sp/>==<sp/>&apos;.&apos;)<sp/>continue;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>Ignore<sp/>dot<sp/>entry<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>#if<sp/>_USE_LFN</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fn<sp/>=<sp/>*fno.lfname<sp/>?<sp/>fno.lfname<sp/>:<sp/>fno.fname;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fn<sp/>=<sp/>fno.fname;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(fno.fattrib<sp/>&amp;<sp/>AM_DIR)<sp/>{<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>It<sp/>is<sp/>a<sp/>directory<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sprintf(&amp;path[i],<sp/>&quot;/%s&quot;,<sp/>fn);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/>scan_files(path);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>path[i]<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(res<sp/>!=<sp/>FR_OK)<sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>It<sp/>is<sp/>a<sp/>file.<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(&quot;%s/%s\n&quot;,<sp/>path,<sp/>fn);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>f_closedir(&amp;dir)</highlight></codeline>
<codeline><highlight class="normal"><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>res;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">dp</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the open directory object. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">fno</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the file information structure to store the read item. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>FR_OK</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_DISK_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INT_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_READY</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INVALID_OBJECT</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_TIMEOUT</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_ENOUGH_CORE</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Available when _FS_MINIMIZE &lt;= 1. </para></simplesect>
</para></listitem></itemizedlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Common/Docs/ff.dox" line="660" column="1" bodyfile="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/ff.c" bodystart="3275" bodyend="3308"/>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1ga2d0ceea336edd9b05754c8684ea8a72f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__filesystem_1ga49d0171ecbd362cda5680a0d360db44c" kindref="member">FRESULT</ref></type>
        <definition>FRESULT f_rename</definition>
        <argsstring>(const TCHAR *old_name, const TCHAR *new_name)</argsstring>
        <name>f_rename</name>
        <param>
          <type>const <ref refid="ff_8h_1a03bdb8ce5895c7e261aadc2529637546" kindref="member">TCHAR</ref> *</type>
          <declname>old_name</declname>
        </param>
        <param>
          <type>const <ref refid="ff_8h_1a03bdb8ce5895c7e261aadc2529637546" kindref="member">TCHAR</ref> *</type>
          <declname>new_name</declname>
        </param>
        <briefdescription>
<para>Renames a file or sub-directory. </para>        </briefdescription>
        <detaileddescription>
<para>Renames a file or sub-directory and can also move it to other directory within the same logical drive. Do not rename open objects or directry table can be broken. <linebreak/>
 Example: <programlisting><codeline><highlight class="normal">/*<sp/>Rename<sp/>an<sp/>object<sp/>*/</highlight></codeline>
<codeline><highlight class="normal">f_rename(&quot;oldname.txt&quot;,<sp/>&quot;newname.txt&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">/*<sp/>Rename<sp/>and<sp/>move<sp/>an<sp/>object<sp/>to<sp/>other<sp/>directory<sp/>*/</highlight></codeline>
<codeline><highlight class="normal">f_rename(&quot;oldname.txt&quot;,<sp/>&quot;dir1/newname.txt&quot;);</highlight></codeline>
</programlisting> <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">old_name</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to a null-terminated string that specifies an existing file or sub-directory to be renamed. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">new_name</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to a null-terminated string that specifies the new object name. The drive number specified in this string is ignored and one determined by old_name is used instead. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>FR_OK</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_DISK_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INT_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_READY</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NO_FILE</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NO_PATH</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INVALID_NAME</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_DENIED</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_EXIST</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_EXIST</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_WRITE_PROTECTED</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INVALID_DRIVE</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_ENABLED</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NO_FILESYSTEM</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_TIMEOUT</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_LOCKED</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_ENOUGH_CORE</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Available when _FS_READONLY == 0 and _FS_MINIMIZE == 0. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Common/Docs/ff.dox" line="849" column="1" bodyfile="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/ff.c" bodystart="3711" bodyend="3780"/>
        <referencedby refid="group___f_o_t_a_1ga02aaeb14e249d60489d2f887a46f26bc" compoundref="_f_o_t_a_8c" startline="322" endline="368">FOTA_ValidateSdcardFw</referencedby>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1gaa82bca64e28bc0d656a7999dd0eadec7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__filesystem_1ga49d0171ecbd362cda5680a0d360db44c" kindref="member">FRESULT</ref></type>
        <definition>FRESULT f_setlabel</definition>
        <argsstring>(const TCHAR *label)</argsstring>
        <name>f_setlabel</name>
        <param>
          <type>const <ref refid="ff_8h_1a03bdb8ce5895c7e261aadc2529637546" kindref="member">TCHAR</ref> *</type>
          <declname>label</declname>
        </param>
        <briefdescription>
<para>The f_setlabel function sets/removes the label of a volume. </para>        </briefdescription>
        <detaileddescription>
<para>When the string has a drive number, the volume label will be set to the volume specified by the drive number. If not, the label will be set to the default drive. If the given string is a null-string, the volume label on the volume will be removed. The format of the volume label is similar to the short file name but there are some differences shown below:<itemizedlist>
<listitem><para>11 bytes or less in length as local character code. LFN extention is not applied to the volume label.</para></listitem><listitem><para>Cannot contain period.</para></listitem><listitem><para>Can contain spaces anywhere in the volume label. Trailing spaces are truncated off. <linebreak/>
 Example: <programlisting><codeline><highlight class="normal">/*<sp/>Set<sp/>volume<sp/>label<sp/>to<sp/>the<sp/>default<sp/>drive<sp/>*/</highlight></codeline>
<codeline><highlight class="normal">f_setlabel(&quot;DATA<sp/>DISK&quot;);</highlight></codeline>
<codeline><highlight class="normal">/*<sp/>Set<sp/>volume<sp/>label<sp/>to<sp/>the<sp/>drive<sp/>2<sp/>*/</highlight></codeline>
<codeline><highlight class="normal">f_setlabel(&quot;2:DISK<sp/>3<sp/>OF<sp/>4&quot;);</highlight></codeline>
<codeline><highlight class="normal">/*<sp/>Remove<sp/>volume<sp/>label<sp/>of<sp/>the<sp/>drive<sp/>2<sp/>*/</highlight></codeline>
<codeline><highlight class="normal">f_setlabel(&quot;2:&quot;);</highlight></codeline>
</programlisting> <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">label</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the null-terminated string that specifies the logical drive. Null-string specifies the default drive. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>FR_OK</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_DISK_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INT_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_READY</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INVALID_NAME</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_WRITE_PROTECTED</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INVALID_DRIVE</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_ENABLED</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NO_FILESYSTEM</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_TIMEOUT</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Available when _FS_READONLY == 0 and _USE_LABEL == 1. </para></simplesect>
</para></listitem></itemizedlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Common/Docs/ff.dox" line="1026" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1ga5c1a803b666f1cc92b2f9363d877a82e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="integer_8h_1ad342ac907eb044443153a22f964bf0af" kindref="member">DWORD</ref></type>
        <definition>DWORD f_size</definition>
        <argsstring>(FIL *fp)</argsstring>
        <name>f_size</name>
        <param>
          <type><ref refid="struct_f_i_l" kindref="compound">FIL</ref> *</type>
          <declname>fp</declname>
        </param>
        <briefdescription>
<para>The f_size function gets the size of a file. </para>        </briefdescription>
        <detaileddescription>
<para>In this revision, the <ref refid="group__filesystem_1ga5c1a803b666f1cc92b2f9363d877a82e" kindref="member">f_size()</ref> function is implemented as a macro.<linebreak/>
 #define <ref refid="ff_8h_1a26f33722c5bf1aa3cd6f0290a83eb2bc" kindref="member">f_size(fp)</ref> ((fp)-&gt;fsize) <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fp</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the open file object structure. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>Returns</parametername>
</parameternamelist>
<parameterdescription>
<para>the size of the file in unit of byte. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Always available. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Common/Docs/ff.dox" line="1263" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1gabe1f60daab5c7d11170c334fb832c798" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__filesystem_1ga49d0171ecbd362cda5680a0d360db44c" kindref="member">FRESULT</ref></type>
        <definition>FRESULT f_stat</definition>
        <argsstring>(const TCHAR *path, FILINFO *fno)</argsstring>
        <name>f_stat</name>
        <param>
          <type>const <ref refid="ff_8h_1a03bdb8ce5895c7e261aadc2529637546" kindref="member">TCHAR</ref> *</type>
          <declname>path</declname>
        </param>
        <param>
          <type><ref refid="struct_f_i_l_i_n_f_o" kindref="compound">FILINFO</ref> *</type>
          <declname>fno</declname>
        </param>
        <briefdescription>
<para>The f_stat function checks the existence of a file or sub-directory. </para>        </briefdescription>
        <detaileddescription>
<para>The <ref refid="group__filesystem_1gabe1f60daab5c7d11170c334fb832c798" kindref="member">f_stat()</ref> function checks the existence of a file or sub-directory. If not exist, the function returns with FR_NO_FILE. If exist, the function returns with FR_OK and the informations of the object, file size, timestamp, attribute and SFN, are stored to the file information structure. For details of the file information, refer to the <ref refid="struct_f_i_l_i_n_f_o" kindref="compound">FILINFO</ref> structure and <ref refid="group__filesystem_1gab39e82a110695de45f416f3149358012" kindref="member">f_readdir()</ref> function. <linebreak/>
 When LFN feature is enabled, lfname in the file information structure must be NULLed prior to use it. <linebreak/>
 Examples: <programlisting><codeline><highlight class="normal">FRESULT<sp/>fr;</highlight></codeline>
<codeline><highlight class="normal">FILINFO<sp/>fno;</highlight></codeline>
<codeline><highlight class="normal">printf(&quot;Test<sp/>for<sp/>&apos;file.txt&apos;...\n&quot;);</highlight></codeline>
<codeline><highlight class="normal">#if<sp/>_USE_LFN</highlight></codeline>
<codeline><highlight class="normal">fno.lfname<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal">fr<sp/>=<sp/>f_stat(&quot;file.txt&quot;,<sp/>&amp;fno);</highlight></codeline>
<codeline><highlight class="normal">switch<sp/>(fr)<sp/>{</highlight></codeline>
<codeline><highlight class="normal">case<sp/>FR_OK:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>printf(&quot;Size:<sp/>%u\n&quot;,<sp/>fno.fsize);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>printf(&quot;Timestamp:<sp/>%u/%02u/%02u,<sp/>%02u:%02u\n&quot;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(fno.fdate<sp/>&gt;&gt;<sp/>9)<sp/>+<sp/>1980,<sp/>fno.fdate<sp/>&gt;&gt;<sp/>5<sp/>&amp;<sp/>15,<sp/>fno.fdate<sp/>&amp;<sp/>31,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fno.ftime<sp/>&gt;&gt;<sp/>11,<sp/>fno.ftime<sp/>&gt;&gt;<sp/>5<sp/>&amp;<sp/>63);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>printf(&quot;Attributes:<sp/>%c%c%c%c%c\n&quot;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(fno.fattrib<sp/>&amp;<sp/>AM_DIR)<sp/>?<sp/>&apos;D&apos;<sp/>:<sp/>&apos;-&apos;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(fno.fattrib<sp/>&amp;<sp/>AM_RDO)<sp/>?<sp/>&apos;R&apos;<sp/>:<sp/>&apos;-&apos;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(fno.fattrib<sp/>&amp;<sp/>AM_HID)<sp/>?<sp/>&apos;H&apos;<sp/>:<sp/>&apos;-&apos;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(fno.fattrib<sp/>&amp;<sp/>AM_SYS)<sp/>?<sp/>&apos;S&apos;<sp/>:<sp/>&apos;-&apos;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(fno.fattrib<sp/>&amp;<sp/>AM_ARC)<sp/>?<sp/>&apos;A&apos;<sp/>:<sp/>&apos;-&apos;);</highlight></codeline>
<codeline><highlight class="normal"><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/>case<sp/>FR_NO_FILE:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>printf(&quot;It<sp/>is<sp/>not<sp/>exist.\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/>default:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>printf(&quot;An<sp/>error<sp/>occured.<sp/>(%d)\n&quot;,<sp/>fr);</highlight></codeline>
<codeline><highlight class="normal"><sp/>}</highlight></codeline>
</programlisting> <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">path</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the null-terminated string that specifies the object to get its information. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">fno</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the blank <ref refid="struct_f_i_l_i_n_f_o" kindref="compound">FILINFO</ref> structure to store the information of the object. Set null pointer if it is not needed. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>FR_OK</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_DISK_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INT_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_READY</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NO_FILE</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NO_PATH</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INVALID_NAME</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INVALID_DRIVE</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_ENABLED</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NO_FILESYSTEM</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_TIMEOUT</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_ENOUGH_CORE</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Available when _FS_MINIMIZE == 0. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Common/Docs/ff.dox" line="543" column="1" bodyfile="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/ff.c" bodystart="3369" bodyend="3395"/>
        <referencedby refid="group___f_o_t_a_1gaa17c22be08c000fec0331fab53040c26" compoundref="_f_o_t_a_8c" startline="371" endline="413">FOTA_UpdateSdcardFw</referencedby>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1gad69c7246b122ba56a134939ee0eaf847" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__filesystem_1ga49d0171ecbd362cda5680a0d360db44c" kindref="member">FRESULT</ref></type>
        <definition>FRESULT f_sync</definition>
        <argsstring>(FIL *fp)</argsstring>
        <name>f_sync</name>
        <param>
          <type><ref refid="struct_f_i_l" kindref="compound">FIL</ref> *</type>
          <declname>fp</declname>
        </param>
        <briefdescription>
<para>The f_sync function flushes the cached information of a writing file. </para>        </briefdescription>
        <detaileddescription>
<para>The <ref refid="group__filesystem_1gad69c7246b122ba56a134939ee0eaf847" kindref="member">f_sync()</ref> function performs the same process as <ref refid="group__filesystem_1ga53882db20ef4323dcfd1874d7733ffc3" kindref="member">f_close()</ref> function but the file is left opened and can continue read/write/seek operations to the file. This is suitable for the applications that open files for a long time in write mode, such as data logger. Performing <ref refid="group__filesystem_1gad69c7246b122ba56a134939ee0eaf847" kindref="member">f_sync()</ref> function of periodic or immediataly after <ref refid="group__filesystem_1gae6a4dfae8a9e308bdb2283a37ef680f2" kindref="member">f_write()</ref> function can minimize the risk of data loss due to a sudden blackout or an unintentional media removal. <linebreak/>
 However there is no sense in <ref refid="group__filesystem_1gad69c7246b122ba56a134939ee0eaf847" kindref="member">f_sync()</ref> function immediataly before <ref refid="group__filesystem_1ga53882db20ef4323dcfd1874d7733ffc3" kindref="member">f_close()</ref> function because it performs <ref refid="group__filesystem_1gad69c7246b122ba56a134939ee0eaf847" kindref="member">f_sync()</ref> function in it. In other words, the differnce between those functions is that the file object is invalidated or not. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fp</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the open file object to be flushed. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>FR_OK</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_DISK_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INT_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_READY</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INVALID_OBJECT</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_TIMEOUT</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Available when _FS_READONLY == 0. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Common/Docs/ff.dox" line="409" column="1" bodyfile="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/ff.c" bodystart="2809" bodyend="2846"/>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1ga091c830b8b17e19267dac539f9093128" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="integer_8h_1ad342ac907eb044443153a22f964bf0af" kindref="member">DWORD</ref></type>
        <definition>DWORD f_tell</definition>
        <argsstring>(FIL *fp)</argsstring>
        <name>f_tell</name>
        <param>
          <type><ref refid="struct_f_i_l" kindref="compound">FIL</ref> *</type>
          <declname>fp</declname>
        </param>
        <briefdescription>
<para>The f_tell function gets the current read/write pointer of a file. </para>        </briefdescription>
        <detaileddescription>
<para>In this revision, the <ref refid="group__filesystem_1ga091c830b8b17e19267dac539f9093128" kindref="member">f_tell()</ref> function is implemented as a macro. <linebreak/>
 #define <ref refid="ff_8h_1a5e1daca7ce13cdc277e42185f7f9124f" kindref="member">f_tell(fp)</ref> ((fp)-&gt;fptr) <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fp</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the open file object structure. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>Returns</parametername>
</parameternamelist>
<parameterdescription>
<para>current read/write pointer of the file. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Always available. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Common/Docs/ff.dox" line="1239" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1ga691a27b40c348f7c84b42e911636f38a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__filesystem_1ga49d0171ecbd362cda5680a0d360db44c" kindref="member">FRESULT</ref></type>
        <definition>FRESULT f_truncate</definition>
        <argsstring>(FIL *fp)</argsstring>
        <name>f_truncate</name>
        <param>
          <type><ref refid="struct_f_i_l" kindref="compound">FIL</ref> *</type>
          <declname>fp</declname>
        </param>
        <briefdescription>
<para>The f_truncate function truncates the file size. </para>        </briefdescription>
        <detaileddescription>
<para>The <ref refid="group__filesystem_1ga691a27b40c348f7c84b42e911636f38a" kindref="member">f_truncate()</ref> function truncates the file size to the current file read/write pointer. This function has no effect if the file read/write pointer is already pointing end of the file. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fp</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the open file object to be truncated. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>FR_OK</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_DISK_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INT_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_READY</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INVALID_OBJECT</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_TIMEOUT</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Available when _FS_READONLY == 0 and _FS_MINIMIZE == 0. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Common/Docs/ff.dox" line="388" column="1" bodyfile="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/ff.c" bodystart="3470" bodyend="3517"/>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1ga2858167fcd0bced48e9be434b3895efe" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__filesystem_1ga49d0171ecbd362cda5680a0d360db44c" kindref="member">FRESULT</ref></type>
        <definition>FRESULT f_unlink</definition>
        <argsstring>(const TCHAR *path)</argsstring>
        <name>f_unlink</name>
        <param>
          <type>const <ref refid="ff_8h_1a03bdb8ce5895c7e261aadc2529637546" kindref="member">TCHAR</ref> *</type>
          <declname>path</declname>
        </param>
        <briefdescription>
<para>The f_unlink function removes a file or sub-directory. </para>        </briefdescription>
        <detaileddescription>
<para>If condition of the object to be removed is applicable to the following terms, the function will be rejected. <linebreak/>
<itemizedlist>
<listitem><para>The file/sub-directory must not have read-only attribute (AM_RDO), or the function will be rejected with FR_DENIED.</para></listitem><listitem><para>The sub-directory must be empty and must not be current directory, or the function will be rejected with FR_DENIED.</para></listitem><listitem><para>The file/sub-directory must not be opened, or the FAT volume can be collapsed. It can be rejected with FR_LOCKED when file lock feature is enabled. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">path</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the null-terminated string that specifies an object to be removed. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>FR_OK</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_DISK_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INT_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_READY</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NO_FILE</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NO_PATH</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INVALID_NAME</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_DENIED</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_EXIST</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_WRITE_PROTECTED</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INVALID_DRIVE</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_ENABLED</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NO_FILESYSTEM</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_TIMEOUT</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_LOCKED</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_ENOUGH_CORE</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Available when _FS_READONLY == 0 and _FS_MINIMIZE == 0. </para></simplesect>
</para></listitem></itemizedlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Common/Docs/ff.dox" line="725" column="1" bodyfile="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/ff.c" bodystart="3526" bodyend="3586"/>
        <referencedby refid="group___f_o_t_a_1ga02aaeb14e249d60489d2f887a46f26bc" compoundref="_f_o_t_a_8c" startline="322" endline="368">FOTA_ValidateSdcardFw</referencedby>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1gaafaa718d1a487e12a8f0087173dba0b9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__filesystem_1ga49d0171ecbd362cda5680a0d360db44c" kindref="member">FRESULT</ref></type>
        <definition>FRESULT f_utime</definition>
        <argsstring>(const TCHAR *path, const FILINFO *fno)</argsstring>
        <name>f_utime</name>
        <param>
          <type>const <ref refid="ff_8h_1a03bdb8ce5895c7e261aadc2529637546" kindref="member">TCHAR</ref> *</type>
          <declname>path</declname>
        </param>
        <param>
          <type>const <ref refid="struct_f_i_l_i_n_f_o" kindref="compound">FILINFO</ref> *</type>
          <declname>fno</declname>
        </param>
        <briefdescription>
<para>The f_utime function changes the timestamp of a file or sub-directory. </para>        </briefdescription>
        <detaileddescription>
<para>The <ref refid="group__filesystem_1gaafaa718d1a487e12a8f0087173dba0b9" kindref="member">f_utime()</ref> function changes the timestamp of a file or sub-directory <linebreak/>
 Example: <programlisting><codeline><highlight class="normal">FRESULT<sp/>set_timestamp<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>char<sp/>*obj,<sp/><sp/><sp/><sp/><sp/>/*<sp/>Pointer<sp/>to<sp/>the<sp/>file<sp/>name<sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>year,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>month,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>mday,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>hour,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>min,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>sec</highlight></codeline>
<codeline><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>FILINFO<sp/>fno;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>fno.fdate<sp/>=<sp/>(WORD)(((year<sp/>-<sp/>1980)<sp/>*<sp/>512U)<sp/>|<sp/>month<sp/>*<sp/>32U<sp/>|<sp/>mday);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>fno.ftime<sp/>=<sp/>(WORD)(hour<sp/>*<sp/>2048U<sp/>|<sp/>min<sp/>*<sp/>32U<sp/>|<sp/>sec<sp/>/<sp/>2U);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>return<sp/>f_utime(obj,<sp/>&amp;fno);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">path</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the null-terminated string that specifies an object to be changed. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">fno</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the file information structure that has a timestamp to be set in member fdate and ftime. Do not care any other members. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>FR_OK</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_DISK_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INT_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_READY</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NO_FILE</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NO_PATH</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INVALID_NAME</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_WRITE_PROTECTED</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INVALID_DRIVE</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_ENABLED</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NO_FILESYSTEM</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_TIMEOUT</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_ENOUGH_CORE</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Available when _FS_READONLY == 0 and _FS_MINIMIZE == 0. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Common/Docs/ff.dox" line="810" column="1" bodyfile="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/ff.c" bodystart="3789" bodyend="3822"/>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1gae6a4dfae8a9e308bdb2283a37ef680f2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__filesystem_1ga49d0171ecbd362cda5680a0d360db44c" kindref="member">FRESULT</ref></type>
        <definition>FRESULT f_write</definition>
        <argsstring>(FIL *fp, const void *buff, UINT btw, UINT *bw)</argsstring>
        <name>f_write</name>
        <param>
          <type><ref refid="struct_f_i_l" kindref="compound">FIL</ref> *</type>
          <declname>fp</declname>
        </param>
        <param>
          <type>const void *</type>
          <declname>buff</declname>
        </param>
        <param>
          <type><ref refid="integer_8h_1a36cb3b01d81ffd844bbbfb54003e06ec" kindref="member">UINT</ref></type>
          <declname>btw</declname>
        </param>
        <param>
          <type><ref refid="integer_8h_1a36cb3b01d81ffd844bbbfb54003e06ec" kindref="member">UINT</ref> *</type>
          <declname>bw</declname>
        </param>
        <briefdescription>
<para>The f_write writes data to a file. </para>        </briefdescription>
        <detaileddescription>
<para>The read/write pointer of the file object advances number of bytes written. After the function succeeded, *bw should be checked to detect the disk full. In case of *bw is less than btw, it means the volume got full during the write operation. The function can take a time when the volume is full or close to full. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fp</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the open file object. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">buff</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the data to be written. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">btw</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies number of bytes to write in range of UINT type. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">bw</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the UINT variable to return the number of bytes written. The value is always valid after the function call regardless of the result. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>FR_OK</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_DISK_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INT_ERR</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_NOT_READY</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_INVALID_OBJECT</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FR_TIMEOUT</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Available when _FS_READONLY == 0. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Common/Docs/ff.dox" line="297" column="1" bodyfile="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/ff.c" bodystart="2687" bodyend="2800"/>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1gaf58b536abfd30f77213f4ecaf2ac52f5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="integer_8h_1ad342ac907eb044443153a22f964bf0af" kindref="member">DWORD</ref></type>
        <definition>DWORD get_fattime</definition>
        <argsstring>(void)</argsstring>
        <name>get_fattime</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
<para>The get_fattime function gets current time. </para>        </briefdescription>
        <detaileddescription>
<para>The <ref refid="group__filesystem_1gaf58b536abfd30f77213f4ecaf2ac52f5" kindref="member">get_fattime()</ref> function shall return any valid time even if the system does not support a real time clock. If a zero is returned, the file will not have a valid timestamp. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">pdrv</parametername>
</parameternamelist>
<parameterdescription>
<para>Physical drive number to identify the target device. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">buff</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the byte array to be written. The size of data to be written is sector size * count bytes. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">sector</parametername>
</parameternamelist>
<parameterdescription>
<para>Start sector number in 32-bit LBA. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">count</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of sectors to write in range of from 1 to 128. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>Currnet</parametername>
</parameternamelist>
<parameterdescription>
<para>time is returned with packed into a DWORD value. The bit field is as follows: <linebreak/>
 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bit31:25</parametername>
</parameternamelist>
<parameterdescription>
<para><linebreak/>
 Year origin from the 1980 (0..127) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bit24:21</parametername>
</parameternamelist>
<parameterdescription>
<para><linebreak/>
 Month (1..12) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bit20:16</parametername>
</parameternamelist>
<parameterdescription>
<para><linebreak/>
 Day of the month(1..31) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bit15:11</parametername>
</parameternamelist>
<parameterdescription>
<para><linebreak/>
 Hour (0..23) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bit10:5</parametername>
</parameternamelist>
<parameterdescription>
<para><linebreak/>
 Minute (0..59) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bit4:0</parametername>
</parameternamelist>
<parameterdescription>
<para><linebreak/>
 Second / 2 (0..29) </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function is not needed when _FS_READONLY == 1. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Common/Docs/ff.dox" line="1455" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="group__filesystem_1gaacdfef1dad6565f65c26d12fe0ea4b2b" prot="public" static="no">
        <name>DRESULT</name>
        <enumvalue id="diskio_8h_1gaacdfef1dad6565f65c26d12fe0ea4b2ba2ea4b6ef3fffc17dd1d38ab5c2837737" prot="public">
          <name>RES_OK</name>
          <initializer>= 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="diskio_8h_1gaacdfef1dad6565f65c26d12fe0ea4b2ba78011f5557679ec178fb40bd21e89840" prot="public">
          <name>RES_ERROR</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="diskio_8h_1gaacdfef1dad6565f65c26d12fe0ea4b2ba442a6d4393dc404827067bc4e981b322" prot="public">
          <name>RES_WRPRT</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="diskio_8h_1gaacdfef1dad6565f65c26d12fe0ea4b2baad64c27c69eb1ff39ae67c5f77bb2b1d" prot="public">
          <name>RES_NOTRDY</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="diskio_8h_1gaacdfef1dad6565f65c26d12fe0ea4b2baf4dcc07fd46310b5495fa8025c89a9f3" prot="public">
          <name>RES_PARERR</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/diskio.h" line="22" column="1" bodyfile="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/diskio.h" bodystart="22" bodyend="28"/>
      </memberdef>
      <memberdef kind="enum" id="group__filesystem_1ga49d0171ecbd362cda5680a0d360db44c" prot="public" static="no">
        <name>FRESULT</name>
        <enumvalue id="ff_8h_1ga49d0171ecbd362cda5680a0d360db44ca62fce5cd9df008f8fc85f99706bda5f1" prot="public">
          <name>FR_OK</name>
          <initializer>= 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="ff_8h_1ga49d0171ecbd362cda5680a0d360db44ca97dee4a6b485dc8f91f37486092dfe34" prot="public">
          <name>FR_DISK_ERR</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="ff_8h_1ga49d0171ecbd362cda5680a0d360db44cab6c9903af6e9bffbb7a288705f4a6a76" prot="public">
          <name>FR_INT_ERR</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="ff_8h_1ga49d0171ecbd362cda5680a0d360db44cac9894bed3e8632ede8d2712235fa8e45" prot="public">
          <name>FR_NOT_READY</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="ff_8h_1ga49d0171ecbd362cda5680a0d360db44ca97da8f98fc2e66d8fa7847f9ebb19b8c" prot="public">
          <name>FR_NO_FILE</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="ff_8h_1ga49d0171ecbd362cda5680a0d360db44cae4529c8cc8b59783d6efc9ba4f574532" prot="public">
          <name>FR_NO_PATH</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="ff_8h_1ga49d0171ecbd362cda5680a0d360db44ca83e45a4b579558c57192c0a391b9bb45" prot="public">
          <name>FR_INVALID_NAME</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="ff_8h_1ga49d0171ecbd362cda5680a0d360db44ca897e9f2dd7629a80f48af242d8bc1a3d" prot="public">
          <name>FR_DENIED</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="ff_8h_1ga49d0171ecbd362cda5680a0d360db44ca0d8f024d256df76e84782b95018a2450" prot="public">
          <name>FR_EXIST</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="ff_8h_1ga49d0171ecbd362cda5680a0d360db44ca3dec4eba481cdf5e99d7cd6009e6dcf8" prot="public">
          <name>FR_INVALID_OBJECT</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="ff_8h_1ga49d0171ecbd362cda5680a0d360db44cac3afbb423b1d4497229416812aff383b" prot="public">
          <name>FR_WRITE_PROTECTED</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="ff_8h_1ga49d0171ecbd362cda5680a0d360db44ca487844af77de15f6932a3b41ef3a2d65" prot="public">
          <name>FR_INVALID_DRIVE</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="ff_8h_1ga49d0171ecbd362cda5680a0d360db44cafc56605c68aaffab4a428339a8bd600d" prot="public">
          <name>FR_NOT_ENABLED</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="ff_8h_1ga49d0171ecbd362cda5680a0d360db44ca086154b5fee763f28c49fd0e2c1cb463" prot="public">
          <name>FR_NO_FILESYSTEM</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="ff_8h_1ga49d0171ecbd362cda5680a0d360db44ca4b02760f758f5b1a89f445244fe9fbca" prot="public">
          <name>FR_MKFS_ABORTED</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="ff_8h_1ga49d0171ecbd362cda5680a0d360db44ca3f8ca7e51af8b129d14328de7243c5d4" prot="public">
          <name>FR_TIMEOUT</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="ff_8h_1ga49d0171ecbd362cda5680a0d360db44ca7db5afaaa2af591bd4a208b2967075d7" prot="public">
          <name>FR_LOCKED</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="ff_8h_1ga49d0171ecbd362cda5680a0d360db44caf56a76a86602cbdeb2c4f3d00cfad21c" prot="public">
          <name>FR_NOT_ENOUGH_CORE</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="ff_8h_1ga49d0171ecbd362cda5680a0d360db44ca50dd3c3c274ccebb2cfbddde9d065bb9" prot="public">
          <name>FR_TOO_MANY_OPEN_FILES</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="ff_8h_1ga49d0171ecbd362cda5680a0d360db44ca3b89faeceab64db277d0fcdeaaa315d6" prot="public">
          <name>FR_INVALID_PARAMETER</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/ff.h" line="184" column="1" bodyfile="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/ff.h" bodystart="184" bodyend="205"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>FatFS Documentation. </para>    </briefdescription>
    <detaileddescription>
<sect1 id="group__filesystem_1fatfs_title">
<title>FatFs - Generic FAT File System Module</title>
<para>FatFs is a generic FAT file system module for small embedded systems. The FatFs is written in compliance with ANSI C and completely separated from the disk I/O layer. Therefore it is independent of hardware architecture. It can be incorporated into small microcontrollers with limited resource, such as AVR, 8051, PIC, ARM, Z80, 68k and etc.</para><para>Features:<itemizedlist>
<listitem><para>Windows compatible FAT file system.</para></listitem><listitem><para>Platform independent. Easy to port.</para></listitem><listitem><para>Very small footprint for code and work area.</para></listitem><listitem><para>Various configuration options:<itemizedlist>
<listitem><para>Multiple volumes (physical drives and partitions).</para></listitem><listitem><para>Multiple ANSI/OEM code pages including DBCS.</para></listitem><listitem><para>Long file name support in ANSI/OEM or Unicode.</para></listitem><listitem><para>RTOS support.</para></listitem><listitem><para>Multiple sector size support.</para></listitem><listitem><para>Read-only, minimized API, I/O buffer and etc..</para></listitem></itemizedlist>
</para></listitem></itemizedlist>
</para><para><image type="html" name="layers.jpg"></image>
</para></sect1>
<sect1 id="group__filesystem_1interface">
<title>Device Control Interface</title>
<para>Since the FatFs module is a file system layer, it is completely separated from physical devices, such as memory card, harddisk and any type of storage devices. FatFs access the storage device via a simple interface described below. The low level device control module is not a part of FatFs module. It is provided by implementer. Also sample implementations for some platforms are available in the downloads. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
