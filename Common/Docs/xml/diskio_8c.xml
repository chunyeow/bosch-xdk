<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.8">
  <compounddef id="diskio_8c" kind="file">
    <compoundname>diskio.c</compoundname>
    <includes refid="diskio_8h" local="yes">diskio.h</includes>
    <includes local="yes">usbdisk.h</includes>
    <includes local="yes">atadrive.h</includes>
    <includes local="yes">sdcard.h</includes>
    <incdepgraph>
      <node id="29011">
        <label>integer.h</label>
        <link refid="integer_8h"/>
      </node>
      <node id="29009">
        <label>SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/diskio.c</label>
        <link refid="diskio.c"/>
        <childnode refid="29010" relation="include">
        </childnode>
        <childnode refid="29012" relation="include">
        </childnode>
        <childnode refid="29013" relation="include">
        </childnode>
        <childnode refid="29014" relation="include">
        </childnode>
      </node>
      <node id="29010">
        <label>diskio.h</label>
        <link refid="diskio_8h"/>
        <childnode refid="29011" relation="include">
        </childnode>
      </node>
      <node id="29014">
        <label>sdcard.h</label>
      </node>
      <node id="29012">
        <label>usbdisk.h</label>
      </node>
      <node id="29013">
        <label>atadrive.h</label>
      </node>
    </incdepgraph>
      <sectiondef kind="define">
      <memberdef kind="define" id="diskio_8c_1a2c51f8df39130923660818986234711f" prot="public" static="no">
        <name>ATA</name>
        <initializer>0	/* Example: Map ATA harddisk to physical drive 0 */</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/diskio.c" line="16" column="9" bodyfile="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/diskio.c" bodystart="16" bodyend="-1"/>
        <referencedby refid="group__filesystem_1ga8348ac5ee6d709420c02e45c111f4793" compoundref="diskio_8c" startline="25" endline="55">disk_status</referencedby>
        <referencedby refid="group__filesystem_1ga09cdaa6f36fa409bdf002727bff98eb1" compoundref="diskio_8c" startline="63" endline="93">disk_initialize</referencedby>
        <referencedby refid="group__filesystem_1ga075d27f59f550e2cee07d00abcff32e0" compoundref="diskio_8c" startline="101" endline="141">disk_read</referencedby>
        <referencedby refid="group__filesystem_1gac03220b2c8a090b4f76eb2c9407b84fb" compoundref="diskio_8c" startline="150" endline="190">disk_write</referencedby>
        <referencedby refid="group__filesystem_1gab00fa450a811dbdabe3c655c1a36fab4" compoundref="diskio_8c" startline="199" endline="229">disk_ioctl</referencedby>
      </memberdef>
      <memberdef kind="define" id="diskio_8c_1ab5a7d5477e55758bde614bda3250a93c" prot="public" static="no">
        <name>MMC</name>
        <initializer>1	/* Example: Map MMC/<ref refid="driver_8c_1af0b48351ca80316714b273fa1afddaf9" kindref="member">SD</ref> card to physical drive 1 */</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/diskio.c" line="17" column="9" bodyfile="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/diskio.c" bodystart="17" bodyend="-1"/>
        <referencedby refid="group__filesystem_1ga8348ac5ee6d709420c02e45c111f4793" compoundref="diskio_8c" startline="25" endline="55">disk_status</referencedby>
        <referencedby refid="group__filesystem_1ga09cdaa6f36fa409bdf002727bff98eb1" compoundref="diskio_8c" startline="63" endline="93">disk_initialize</referencedby>
        <referencedby refid="group__filesystem_1ga075d27f59f550e2cee07d00abcff32e0" compoundref="diskio_8c" startline="101" endline="141">disk_read</referencedby>
        <referencedby refid="group__filesystem_1gac03220b2c8a090b4f76eb2c9407b84fb" compoundref="diskio_8c" startline="150" endline="190">disk_write</referencedby>
        <referencedby refid="group__filesystem_1gab00fa450a811dbdabe3c655c1a36fab4" compoundref="diskio_8c" startline="199" endline="229">disk_ioctl</referencedby>
      </memberdef>
      <memberdef kind="define" id="diskio_8c_1a779bf099075a999d1074357fccbd466b" prot="public" static="no">
        <name>USB</name>
        <initializer>2	/* Example: Map USB MSD to physical drive 2 */</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/diskio.c" line="18" column="9" bodyfile="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/diskio.c" bodystart="18" bodyend="-1"/>
        <referencedby refid="group__filesystem_1ga8348ac5ee6d709420c02e45c111f4793" compoundref="diskio_8c" startline="25" endline="55">disk_status</referencedby>
        <referencedby refid="group__filesystem_1ga09cdaa6f36fa409bdf002727bff98eb1" compoundref="diskio_8c" startline="63" endline="93">disk_initialize</referencedby>
        <referencedby refid="group__filesystem_1ga075d27f59f550e2cee07d00abcff32e0" compoundref="diskio_8c" startline="101" endline="141">disk_read</referencedby>
        <referencedby refid="group__filesystem_1gac03220b2c8a090b4f76eb2c9407b84fb" compoundref="diskio_8c" startline="150" endline="190">disk_write</referencedby>
        <referencedby refid="group__filesystem_1gab00fa450a811dbdabe3c655c1a36fab4" compoundref="diskio_8c" startline="199" endline="229">disk_ioctl</referencedby>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__filesystem_1ga09cdaa6f36fa409bdf002727bff98eb1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="diskio_8h_1adba6790898ce4029c20a34b898ce73c1" kindref="member">DSTATUS</ref></type>
        <definition>DSTATUS disk_initialize</definition>
        <argsstring>(BYTE pdrv)</argsstring>
        <name>disk_initialize</name>
        <param>
          <type><ref refid="integer_8h_1a4ae1dab0fb4b072a66584546209e7d58" kindref="member">BYTE</ref></type>
          <declname>pdrv</declname>
        </param>
        <briefdescription>
<para>The disk_initialize function initializes the storage device. </para>        </briefdescription>
        <detaileddescription>
<para>This function initializes the storage device and put it ready to generic read/write. When the function succeeded, STA_NOINIT flag in the return value is cleared. <linebreak/>
 <bold>Application program MUST NOT call this function, or FAT structure on the volume can be broken. To re-initialize the file system, use <ref refid="group__filesystem_1ga16a934c2bbfa2160295810adc49d5509" kindref="member">f_mount()</ref> function instead.</bold> This function is called at volume mount process by FatFs module to manage the media change. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">pdrv</parametername>
</parameternamelist>
<parameterdescription>
<para>Physical drive number to identify the target device. Always zero at single drive system. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>This</parametername>
</parameternamelist>
<parameterdescription>
<para>function returns the current drive status flags as the result. For details of the drive status, refer to the <ref refid="group__filesystem_1ga8348ac5ee6d709420c02e45c111f4793" kindref="member">disk_status()</ref> function. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/diskio.c" line="63" column="1" bodyfile="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/diskio.c" bodystart="63" bodyend="93"/>
        <references refid="diskio_8c_1a2c51f8df39130923660818986234711f" compoundref="diskio_8c" startline="16">ATA</references>
        <references refid="diskio_8c_1ab5a7d5477e55758bde614bda3250a93c" compoundref="diskio_8c" startline="17">MMC</references>
        <references refid="diskio_8c_1a779bf099075a999d1074357fccbd466b" compoundref="diskio_8c" startline="18">USB</references>
        <references refid="diskio_8h_1abd6503c70d862b979a3f7080a59e9acd" compoundref="diskio_8h" startline="44">STA_NOINIT</references>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1gab00fa450a811dbdabe3c655c1a36fab4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__filesystem_1gaacdfef1dad6565f65c26d12fe0ea4b2b" kindref="member">DRESULT</ref></type>
        <definition>DRESULT disk_ioctl</definition>
        <argsstring>(BYTE pdrv, BYTE cmd, void *buff)</argsstring>
        <name>disk_ioctl</name>
        <param>
          <type><ref refid="integer_8h_1a4ae1dab0fb4b072a66584546209e7d58" kindref="member">BYTE</ref></type>
          <declname>pdrv</declname>
        </param>
        <param>
          <type><ref refid="integer_8h_1a4ae1dab0fb4b072a66584546209e7d58" kindref="member">BYTE</ref></type>
          <declname>cmd</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>buff</declname>
        </param>
        <briefdescription>
<para>The disk_ioctl function cntrols device specific features and miscellaneous functions other than generic read/write. </para>        </briefdescription>
        <detaileddescription>
<para>The FatFs module requires only five device independent commands described below. <linebreak/>
 <linebreak/>
<center> <bold> Standard ioctl command used by FatFs: </bold> </center> <table rows="6" cols="2"><row>
<entry thead="yes"><para>Command </para></entry><entry thead="yes"><para>Description  </para></entry></row>
<row>
<entry thead="no"><para>CTRL_SYNC </para></entry><entry thead="no"><para>Make sure that the device has finished pending write process. If the disk I/O module has a write back cache, the dirty buffers must be written back to the media immediately. Nothing to do for this command if each write operation to the media is completed within the <ref refid="group__filesystem_1gac03220b2c8a090b4f76eb2c9407b84fb" kindref="member">disk_write()</ref> function. </para></entry></row>
<row>
<entry thead="no"><para>GET_SECTOR_COUNT </para></entry><entry thead="no"><para>Returns number of available sectors on the drive into the DWORD variable pointed by buff. This command is used by only <ref refid="group__filesystem_1ga799aff9594e708c8be357281cf85428b" kindref="member">f_mkfs()</ref> and <ref refid="group__filesystem_1ga0c1bd3e3872abbda0e256e7c73da9f3b" kindref="member">f_fdisk()</ref> function to determine the volume/partition size to be created. Required at _USE_MKFS == 1 or _MULTI_PARTITION == 1. </para></entry></row>
<row>
<entry thead="no"><para>GET_SECTOR_SIZE </para></entry><entry thead="no"><para>Returns sector size of the media into the WORD variable pointed by buff. Valid return values of this command are 512, 1024, 2048 and 4096. This command is required only at variable sector size configuration, _MAX_SS &gt; _MIN_SS. At fixed sector size configuration, _MAX_SS == _MIN_SS, this command is not used and the device must work at that sector size. </para></entry></row>
<row>
<entry thead="no"><para>GET_BLOCK_SIZE </para></entry><entry thead="no"><para>Returns erase block size of the flash memory media in unit of sector into the DWORD variable pointed by buff. The allowable value is from 1 to 32768 in power of 2. Return 1 if the erase block size is unknown or non flash memory media. This command is used by only <ref refid="group__filesystem_1ga799aff9594e708c8be357281cf85428b" kindref="member">f_mkfs()</ref> function and it attempts to align data area to the erase block boundary. Required at _USE_MKFS == 1. </para></entry></row>
<row>
<entry thead="no"><para>CTRL_TRIM </para></entry><entry thead="no"><para>Informs the device the data on the block of sectors that specified by DWORD array {&lt;start sector&gt;=&quot;&quot;&gt;, &lt;end sector&gt;=&quot;&quot;&gt;} pointed by buff is no longer needed and it may be erased. This is an identical command to Trim of ATA device. When this feature is not supported or not a flash memory device, nothing to do for this command. The FatFs does not check the result code and the file function is not affected even if the sector block was not erased well. This command is called on removing a cluster chain and <ref refid="group__filesystem_1ga799aff9594e708c8be357281cf85428b" kindref="member">f_mkfs()</ref> function. Required at _USE_TRIM == 1. </para></entry></row>
</table>
</para><para>FatFs never uses any device dependent command nor user defined command. Following table shows an example of non-standard commands usable for some applications. <center> <bold> Example of optional ioctl command </bold> </center></para><para><table rows="13" cols="2"><row>
<entry thead="yes"><para>Command </para></entry><entry thead="yes"><para>Description  </para></entry></row>
<row>
<entry thead="no"><para>CTRL_FORMAT </para></entry><entry thead="no"><para>Create a physical format on the media. If buff is not null, it is pointer to the call-back function for progress notification. </para></entry></row>
<row>
<entry thead="no"><para>CTRL_POWER_IDLE </para></entry><entry thead="no"><para>Put the device idle state. STA_NOINIT in status flag may not be set if the device goes active state by generic read/write function. </para></entry></row>
<row>
<entry thead="no"><para>CTRL_POWER_OFF </para></entry><entry thead="no"><para>Put the device off state. Shut-down the power to the device and deinitialize the device interface if needed. STA_NOINIT in status flag must be set. The device goes active state by <ref refid="group__filesystem_1ga09cdaa6f36fa409bdf002727bff98eb1" kindref="member">disk_initialize()</ref> function. </para></entry></row>
<row>
<entry thead="no"><para>CTRL_LOCK </para></entry><entry thead="no"><para>Lock media eject mechanism. </para></entry></row>
<row>
<entry thead="no"><para>CTRL_UNLOCK </para></entry><entry thead="no"><para>Unlock media eject mechanism. </para></entry></row>
<row>
<entry thead="no"><para>MMC_GET_CSD </para></entry><entry thead="no"><para>Eject media cartridge. STA_NOINIT and STA_NODISK in status flag are set after the function succeeded. </para></entry></row>
<row>
<entry thead="no"><para>MMC_GET_CID </para></entry><entry thead="no"><para>Get card type. The type flags, bit0:MMCv3, bit1:SDv1, bit2:SDv2+ and bit3:LBA, is stored to a BYTE variable pointed by buff. (MMC/SDC specific command) </para></entry></row>
<row>
<entry thead="no"><para>MMC_GET_OCR </para></entry><entry thead="no"><para>Get OCR register into a 4-byte buffer pointed by buff. (MMC/SDC specific command) </para></entry></row>
<row>
<entry thead="no"><para>MMC_GET_SDSTAT </para></entry><entry thead="no"><para>Get SDSTATUS register into a 64-byte buffer pointed by buff. (SDC specific command) </para></entry></row>
<row>
<entry thead="no"><para>ATA_GET_REV </para></entry><entry thead="no"><para>Get the revision string into a 16-byte buffer pointed by buff. (ATA/CFC specific command) </para></entry></row>
<row>
<entry thead="no"><para>ATA_GET_MODEL </para></entry><entry thead="no"><para>Get the model string into a 40-byte buffer pointed by buff. (ATA/CFC specific command) </para></entry></row>
<row>
<entry thead="no"><para>ATA_GET_SN </para></entry><entry thead="no"><para>Get the serial number string into a 20-byte buffer pointed by buff. (ATA/CFC specific command) </para></entry></row>
</table>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">pdrv</parametername>
</parameternamelist>
<parameterdescription>
<para>Physical drive number to identify the target device. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">cmd</parametername>
</parameternamelist>
<parameterdescription>
<para>Command code. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="inout">buff</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the parameter depends on the command code. Do not care if no parameter to be passed. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>RES_OK(0)</parametername>
</parameternamelist>
<parameterdescription>
<para><linebreak/>
 The function succeeded. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>RES_ERROR</parametername>
</parameternamelist>
<parameterdescription>
<para><linebreak/>
 An error occured. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>RES_PARERR</parametername>
</parameternamelist>
<parameterdescription>
<para><linebreak/>
 The command code or parameter is invalid. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>RES_NOTRDY</parametername>
</parameternamelist>
<parameterdescription>
<para><linebreak/>
 The device has not been initialized. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The disk_ioctl function is not needed when _FS_READONLY == 1 and _MAX_SS == _MIN_SS. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/diskio.c" line="199" column="1" bodyfile="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/diskio.c" bodystart="199" bodyend="229"/>
        <references refid="diskio_8c_1a2c51f8df39130923660818986234711f" compoundref="diskio_8c" startline="16">ATA</references>
        <references refid="diskio_8c_1ab5a7d5477e55758bde614bda3250a93c" compoundref="diskio_8c" startline="17">MMC</references>
        <references refid="diskio_8c_1a779bf099075a999d1074357fccbd466b" compoundref="diskio_8c" startline="18">USB</references>
        <references refid="diskio_8h_1gaacdfef1dad6565f65c26d12fe0ea4b2baf4dcc07fd46310b5495fa8025c89a9f3" compoundref="diskio_8h" startline="27">RES_PARERR</references>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1ga075d27f59f550e2cee07d00abcff32e0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__filesystem_1gaacdfef1dad6565f65c26d12fe0ea4b2b" kindref="member">DRESULT</ref></type>
        <definition>DRESULT disk_read</definition>
        <argsstring>(BYTE pdrv, BYTE *buff, DWORD sector, UINT count)</argsstring>
        <name>disk_read</name>
        <param>
          <type><ref refid="integer_8h_1a4ae1dab0fb4b072a66584546209e7d58" kindref="member">BYTE</ref></type>
          <declname>pdrv</declname>
        </param>
        <param>
          <type><ref refid="integer_8h_1a4ae1dab0fb4b072a66584546209e7d58" kindref="member">BYTE</ref> *</type>
          <declname>buff</declname>
        </param>
        <param>
          <type><ref refid="integer_8h_1ad342ac907eb044443153a22f964bf0af" kindref="member">DWORD</ref></type>
          <declname>sector</declname>
        </param>
        <param>
          <type><ref refid="integer_8h_1a36cb3b01d81ffd844bbbfb54003e06ec" kindref="member">UINT</ref></type>
          <declname>count</declname>
        </param>
        <briefdescription>
<para>The disk_read function reads sector(s) from the storage device. </para>        </briefdescription>
        <detaileddescription>
<para>The data read/write operation to the storage devices is done in unit of sector. FatFs supports the sector size in range of from 512 to 4096 bytes. When FatFs is configured to fixed sector size (_MIN_SS == MAX_SS, this will be the most case), the read/write function must work at that sector size. If variable sector size is selected (_MIN_SS &lt; MAX_SS), FatFs inquires the sector size with <ref refid="group__filesystem_1gab00fa450a811dbdabe3c655c1a36fab4" kindref="member">disk_ioctl()</ref> after initialization. <linebreak/>
 The memory address specified by buff is not that always aligned to word boundary because the argument is defined as BYTE*. The misaligned read/write request can occure at direct transfer. If the bus architecture, especially DMA controller, does not allow misaligned memory access, it should be solved in this function. There are some workarounds described below to avoid this issue. <linebreak/>
<itemizedlist>
<listitem><para>Convert word transfer to byte transfer in this function if needed. - Recommended.</para></listitem><listitem><para>For <ref refid="group__filesystem_1gac4c3dcb6869ca252888eebabe39727b3" kindref="member">f_read()</ref>, avoid long read request that includes a whole of sector. - Direct transfer will never occure.</para></listitem><listitem><para>For f_read(fp, buff, btr, &amp;br), make sure that (((UINT)buff &amp; 3) == (<ref refid="ff_8h_1a5e1daca7ce13cdc277e42185f7f9124f" kindref="member">f_tell(fp)</ref> &amp; 3)) is true. - Word aligned direct transfer is guaranteed. <linebreak/>
 Generally, a multiple sector transfer request must not be split into single sector transactions to the storage device, or you will not get good read throughput. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">pdrv</parametername>
</parameternamelist>
<parameterdescription>
<para>Physical drive number to identify the target device. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">buff</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the byte array to store the read data. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">sector</parametername>
</parameternamelist>
<parameterdescription>
<para>Start sector number in 32-bit LBA. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">count</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of sectors to read in range of from 1 to 128.. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>RES_OK</parametername>
</parameternamelist>
<parameterdescription>
<para>(0) <linebreak/>
 The function succeeded. <linebreak/>
</para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>RES_ERROR</parametername>
</parameternamelist>
<parameterdescription>
<para><linebreak/>
 Any hard error occured during the read operation and could not recover it. <linebreak/>
</para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>RES_PARERR</parametername>
</parameternamelist>
<parameterdescription>
<para><linebreak/>
 Invalid parameter. <linebreak/>
</para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>RES_NOTRDY</parametername>
</parameternamelist>
<parameterdescription>
<para><linebreak/>
 The device has not been initialized. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para></listitem></itemizedlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/diskio.c" line="101" column="1" bodyfile="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/diskio.c" bodystart="101" bodyend="141"/>
        <references refid="diskio_8c_1a2c51f8df39130923660818986234711f" compoundref="diskio_8c" startline="16">ATA</references>
        <references refid="diskio_8c_1ab5a7d5477e55758bde614bda3250a93c" compoundref="diskio_8c" startline="17">MMC</references>
        <references refid="diskio_8c_1a779bf099075a999d1074357fccbd466b" compoundref="diskio_8c" startline="18">USB</references>
        <references refid="diskio_8h_1gaacdfef1dad6565f65c26d12fe0ea4b2baf4dcc07fd46310b5495fa8025c89a9f3" compoundref="diskio_8h" startline="27">RES_PARERR</references>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1ga8348ac5ee6d709420c02e45c111f4793" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="diskio_8h_1adba6790898ce4029c20a34b898ce73c1" kindref="member">DSTATUS</ref></type>
        <definition>DSTATUS disk_status</definition>
        <argsstring>(BYTE pdrv)</argsstring>
        <name>disk_status</name>
        <param>
          <type><ref refid="integer_8h_1a4ae1dab0fb4b072a66584546209e7d58" kindref="member">BYTE</ref></type>
          <declname>pdrv</declname>
        </param>
        <briefdescription>
<para>The disk_status function returns the current drive status. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">pdrv</parametername>
</parameternamelist>
<parameterdescription>
<para>Physical drive number to identify the target device. Always zero at single drive system. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>The</parametername>
</parameternamelist>
<parameterdescription>
<para>current drive status is returned in combination of status flags described below. FatFs refers only STA_NOINIT and STA_PROTECT. <linebreak/>
</para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>STA_NOINIT</parametername>
</parameternamelist>
<parameterdescription>
<para><linebreak/>
 Indicates that the device is not initialized. This flag is set on system reset, media removal or failure of <ref refid="group__filesystem_1ga09cdaa6f36fa409bdf002727bff98eb1" kindref="member">disk_initialize()</ref> function. It is cleared on <ref refid="group__filesystem_1ga09cdaa6f36fa409bdf002727bff98eb1" kindref="member">disk_initialize()</ref> function succeeded. Media change that occurs asynchronously must be captured and reflect it to the status flags, or auto-mount feature will not work correctly. If the system does not support media change detect feature, application program needs to force de-initialize the file system object with <ref refid="group__filesystem_1ga16a934c2bbfa2160295810adc49d5509" kindref="member">f_mount()</ref> function after the media change. <linebreak/>
</para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>STA_NODISK</parametername>
</parameternamelist>
<parameterdescription>
<para><linebreak/>
 Indicates that no medium in the drive. This is always cleared on fixed disk drive. Note that FatFs does not refer this flag. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>STA_PROTECT</parametername>
</parameternamelist>
<parameterdescription>
<para><linebreak/>
 Indicates that the medium is write protected. This is always cleared on the drives without write protect feature. Not valid if no medium in the drive. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/diskio.c" line="25" column="1" bodyfile="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/diskio.c" bodystart="25" bodyend="55"/>
        <references refid="diskio_8c_1a2c51f8df39130923660818986234711f" compoundref="diskio_8c" startline="16">ATA</references>
        <references refid="diskio_8c_1ab5a7d5477e55758bde614bda3250a93c" compoundref="diskio_8c" startline="17">MMC</references>
        <references refid="diskio_8c_1a779bf099075a999d1074357fccbd466b" compoundref="diskio_8c" startline="18">USB</references>
        <references refid="diskio_8h_1abd6503c70d862b979a3f7080a59e9acd" compoundref="diskio_8h" startline="44">STA_NOINIT</references>
      </memberdef>
      <memberdef kind="function" id="group__filesystem_1gac03220b2c8a090b4f76eb2c9407b84fb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__filesystem_1gaacdfef1dad6565f65c26d12fe0ea4b2b" kindref="member">DRESULT</ref></type>
        <definition>DRESULT disk_write</definition>
        <argsstring>(BYTE pdrv, const BYTE *buff, DWORD sector, UINT count)</argsstring>
        <name>disk_write</name>
        <param>
          <type><ref refid="integer_8h_1a4ae1dab0fb4b072a66584546209e7d58" kindref="member">BYTE</ref></type>
          <declname>drv</declname>
          <defname>pdrv</defname>
        </param>
        <param>
          <type>const <ref refid="integer_8h_1a4ae1dab0fb4b072a66584546209e7d58" kindref="member">BYTE</ref> *</type>
          <declname>buff</declname>
        </param>
        <param>
          <type><ref refid="integer_8h_1ad342ac907eb044443153a22f964bf0af" kindref="member">DWORD</ref></type>
          <declname>sector</declname>
        </param>
        <param>
          <type><ref refid="integer_8h_1a36cb3b01d81ffd844bbbfb54003e06ec" kindref="member">UINT</ref></type>
          <declname>count</declname>
        </param>
        <briefdescription>
<para>The disk_write writes sector(s) to the storage device. </para>        </briefdescription>
        <detaileddescription>
<para>The specified memory address is not that always aligned to word boundary because the type of pointer is defined as BYTE*. For more information, refer to the description of <ref refid="group__filesystem_1ga075d27f59f550e2cee07d00abcff32e0" kindref="member">disk_read()</ref> function. <linebreak/>
 Generally, a multiple sector transfer request must not be split into single sector transactions to the storage device, or you will never get good write throughput. <linebreak/>
 FatFs expects delayed write feature of the disk functions. The write operation to the media need not to be completed due to write operation is in progress or only stored it into the cache buffer when return from this function. But data on the buff is invalid after return from this function. The write completion request is done by CTRL_SYNC command of <ref refid="group__filesystem_1gab00fa450a811dbdabe3c655c1a36fab4" kindref="member">disk_ioctl()</ref> function. Therefore, if delayed write feature is implemented, the write throughput may be improved. <linebreak/>
 Application program MUST NOT call this function, or FAT structure on the volume can be collapsed. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">pdrv</parametername>
</parameternamelist>
<parameterdescription>
<para>Physical drive number to identify the target device. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">buff</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the byte array to be written. The size of data to be written is sector size * count bytes. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">sector</parametername>
</parameternamelist>
<parameterdescription>
<para>Start sector number in 32-bit LBA. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">count</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of sectors to write in range of from 1 to 128. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>RES_OK(0)</parametername>
</parameternamelist>
<parameterdescription>
<para><linebreak/>
 The function succeeded. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>RES_ERROR</parametername>
</parameternamelist>
<parameterdescription>
<para><linebreak/>
 Any hard error occured during the write operation and could not recover it. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>RES_WRPRT</parametername>
</parameternamelist>
<parameterdescription>
<para><linebreak/>
 The medium is write protected. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>RES_PARERR</parametername>
</parameternamelist>
<parameterdescription>
<para><linebreak/>
 Invalid parameter. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>RES_NOTRDY</parametername>
</parameternamelist>
<parameterdescription>
<para><linebreak/>
 The device has not been initialized. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function is not needed when _FS_READONLY == 1. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/diskio.c" line="150" column="1" bodyfile="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/diskio.c" bodystart="150" bodyend="190"/>
        <references refid="diskio_8c_1a2c51f8df39130923660818986234711f" compoundref="diskio_8c" startline="16">ATA</references>
        <references refid="diskio_8c_1ab5a7d5477e55758bde614bda3250a93c" compoundref="diskio_8c" startline="17">MMC</references>
        <references refid="diskio_8c_1a779bf099075a999d1074357fccbd466b" compoundref="diskio_8c" startline="18">USB</references>
        <references refid="diskio_8h_1gaacdfef1dad6565f65c26d12fe0ea4b2baf4dcc07fd46310b5495fa8025c89a9f3" compoundref="diskio_8h" startline="27">RES_PARERR</references>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="comment">/*-----------------------------------------------------------------------*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Low<sp/>level<sp/>disk<sp/>I/O<sp/>module<sp/>skeleton<sp/>for<sp/>FatFs<sp/><sp/><sp/><sp/><sp/>(C)ChaN,<sp/>2014<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3"><highlight class="normal"></highlight><highlight class="comment">/*-----------------------------------------------------------------------*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>If<sp/>a<sp/>working<sp/>storage<sp/>control<sp/>module<sp/>is<sp/>available,<sp/>it<sp/>should<sp/>be<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>attached<sp/>to<sp/>the<sp/>FatFs<sp/>via<sp/>a<sp/>glue<sp/>function<sp/>rather<sp/>than<sp/>modifying<sp/>it.<sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>This<sp/>is<sp/>an<sp/>example<sp/>of<sp/>glue<sp/>functions<sp/>to<sp/>attach<sp/>various<sp/>exsisting<sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>storage<sp/>control<sp/>modules<sp/>to<sp/>the<sp/>FatFs<sp/>module<sp/>with<sp/>a<sp/>defined<sp/>API.<sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8"><highlight class="normal"></highlight><highlight class="comment">/*-----------------------------------------------------------------------*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9"><highlight class="normal"></highlight></codeline>
<codeline lineno="10"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="diskio_8h" kindref="compound">diskio.h</ref>&quot;</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>FatFs<sp/>lower<sp/>layer<sp/>API<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;usbdisk.h&quot;</highlight><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Example:<sp/>Header<sp/>file<sp/>of<sp/>existing<sp/>USB<sp/>MSD<sp/>control<sp/>module<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;atadrive.h&quot;</highlight><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Example:<sp/>Header<sp/>file<sp/>of<sp/>existing<sp/>ATA<sp/>harddisk<sp/>control<sp/>module<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;sdcard.h&quot;</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Example:<sp/>Header<sp/>file<sp/>of<sp/>existing<sp/>MMC/SDC<sp/>contorl<sp/>module<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14"><highlight class="normal"></highlight></codeline>
<codeline lineno="15"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Definitions<sp/>of<sp/>physical<sp/>drive<sp/>number<sp/>for<sp/>each<sp/>drive<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16" refid="diskio_8c_1a2c51f8df39130923660818986234711f" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>ATA<sp/><sp/><sp/><sp/><sp/>0<sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Example:<sp/>Map<sp/>ATA<sp/>harddisk<sp/>to<sp/>physical<sp/>drive<sp/>0<sp/>*/</highlight><highlight class="preprocessor"></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17" refid="diskio_8c_1ab5a7d5477e55758bde614bda3250a93c" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>MMC<sp/><sp/><sp/><sp/><sp/>1<sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Example:<sp/>Map<sp/>MMC/SD<sp/>card<sp/>to<sp/>physical<sp/>drive<sp/>1<sp/>*/</highlight><highlight class="preprocessor"></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="18" refid="diskio_8c_1a779bf099075a999d1074357fccbd466b" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>USB<sp/><sp/><sp/><sp/><sp/>2<sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Example:<sp/>Map<sp/>USB<sp/>MSD<sp/>to<sp/>physical<sp/>drive<sp/>2<sp/>*/</highlight><highlight class="preprocessor"></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="19"><highlight class="normal"></highlight></codeline>
<codeline lineno="20"><highlight class="normal"></highlight></codeline>
<codeline lineno="21"><highlight class="normal"></highlight><highlight class="comment">/*-----------------------------------------------------------------------*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="22"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Get<sp/>Drive<sp/>Status<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="23"><highlight class="normal"></highlight><highlight class="comment">/*-----------------------------------------------------------------------*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="24"><highlight class="normal"></highlight></codeline>
<codeline lineno="25" refid="group__filesystem_1ga8348ac5ee6d709420c02e45c111f4793" refkind="member"><highlight class="normal"><ref refid="diskio_8h_1adba6790898ce4029c20a34b898ce73c1" kindref="member">DSTATUS</ref><sp/><ref refid="group__filesystem_1ga8348ac5ee6d709420c02e45c111f4793" kindref="member">disk_status</ref><sp/>(</highlight></codeline>
<codeline lineno="26"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="integer_8h_1a4ae1dab0fb4b072a66584546209e7d58" kindref="member">BYTE</ref><sp/>pdrv<sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Physical<sp/>drive<sp/>nmuber<sp/>to<sp/>identify<sp/>the<sp/>drive<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="27"><highlight class="normal">)</highlight></codeline>
<codeline lineno="28"><highlight class="normal">{</highlight></codeline>
<codeline lineno="29"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="diskio_8h_1adba6790898ce4029c20a34b898ce73c1" kindref="member">DSTATUS</ref><sp/>stat;</highlight></codeline>
<codeline lineno="30"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>result;</highlight></codeline>
<codeline lineno="31"><highlight class="normal"></highlight></codeline>
<codeline lineno="32"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(pdrv)<sp/>{</highlight></codeline>
<codeline lineno="33"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="diskio_8c_1a2c51f8df39130923660818986234711f" kindref="member">ATA</ref><sp/>:</highlight></codeline>
<codeline lineno="34"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>=<sp/>ATA_disk_status();</highlight></codeline>
<codeline lineno="35"><highlight class="normal"></highlight></codeline>
<codeline lineno="36"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>translate<sp/>the<sp/>reslut<sp/>code<sp/>here</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="37"><highlight class="normal"></highlight></codeline>
<codeline lineno="38"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>stat;</highlight></codeline>
<codeline lineno="39"><highlight class="normal"></highlight></codeline>
<codeline lineno="40"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="diskio_8c_1ab5a7d5477e55758bde614bda3250a93c" kindref="member">MMC</ref><sp/>:</highlight></codeline>
<codeline lineno="41"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>=<sp/>MMC_disk_status();</highlight></codeline>
<codeline lineno="42"><highlight class="normal"></highlight></codeline>
<codeline lineno="43"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>translate<sp/>the<sp/>reslut<sp/>code<sp/>here</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="44"><highlight class="normal"></highlight></codeline>
<codeline lineno="45"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>stat;</highlight></codeline>
<codeline lineno="46"><highlight class="normal"></highlight></codeline>
<codeline lineno="47"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="diskio_8c_1a779bf099075a999d1074357fccbd466b" kindref="member">USB</ref><sp/>:</highlight></codeline>
<codeline lineno="48"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>=<sp/>USB_disk_status();</highlight></codeline>
<codeline lineno="49"><highlight class="normal"></highlight></codeline>
<codeline lineno="50"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>translate<sp/>the<sp/>reslut<sp/>code<sp/>here</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="51"><highlight class="normal"></highlight></codeline>
<codeline lineno="52"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>stat;</highlight></codeline>
<codeline lineno="53"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="54"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="diskio_8h_1abd6503c70d862b979a3f7080a59e9acd" kindref="member">STA_NOINIT</ref>;</highlight></codeline>
<codeline lineno="55"><highlight class="normal">}</highlight></codeline>
<codeline lineno="56"><highlight class="normal"></highlight></codeline>
<codeline lineno="57"><highlight class="normal"></highlight></codeline>
<codeline lineno="58"><highlight class="normal"></highlight></codeline>
<codeline lineno="59"><highlight class="normal"></highlight><highlight class="comment">/*-----------------------------------------------------------------------*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="60"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Inidialize<sp/>a<sp/>Drive<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="61"><highlight class="normal"></highlight><highlight class="comment">/*-----------------------------------------------------------------------*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="62"><highlight class="normal"></highlight></codeline>
<codeline lineno="63" refid="group__filesystem_1ga09cdaa6f36fa409bdf002727bff98eb1" refkind="member"><highlight class="normal"><ref refid="diskio_8h_1adba6790898ce4029c20a34b898ce73c1" kindref="member">DSTATUS</ref><sp/><ref refid="group__filesystem_1ga09cdaa6f36fa409bdf002727bff98eb1" kindref="member">disk_initialize</ref><sp/>(</highlight></codeline>
<codeline lineno="64"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="integer_8h_1a4ae1dab0fb4b072a66584546209e7d58" kindref="member">BYTE</ref><sp/>pdrv<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Physical<sp/>drive<sp/>nmuber<sp/>to<sp/>identify<sp/>the<sp/>drive<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="65"><highlight class="normal">)</highlight></codeline>
<codeline lineno="66"><highlight class="normal">{</highlight></codeline>
<codeline lineno="67"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="diskio_8h_1adba6790898ce4029c20a34b898ce73c1" kindref="member">DSTATUS</ref><sp/>stat;</highlight></codeline>
<codeline lineno="68"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>result;</highlight></codeline>
<codeline lineno="69"><highlight class="normal"></highlight></codeline>
<codeline lineno="70"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(pdrv)<sp/>{</highlight></codeline>
<codeline lineno="71"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="diskio_8c_1a2c51f8df39130923660818986234711f" kindref="member">ATA</ref><sp/>:</highlight></codeline>
<codeline lineno="72"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>=<sp/>ATA_disk_initialize();</highlight></codeline>
<codeline lineno="73"><highlight class="normal"></highlight></codeline>
<codeline lineno="74"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>translate<sp/>the<sp/>reslut<sp/>code<sp/>here</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="75"><highlight class="normal"></highlight></codeline>
<codeline lineno="76"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>stat;</highlight></codeline>
<codeline lineno="77"><highlight class="normal"></highlight></codeline>
<codeline lineno="78"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="diskio_8c_1ab5a7d5477e55758bde614bda3250a93c" kindref="member">MMC</ref><sp/>:</highlight></codeline>
<codeline lineno="79"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>=<sp/>MMC_disk_initialize();</highlight></codeline>
<codeline lineno="80"><highlight class="normal"></highlight></codeline>
<codeline lineno="81"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>translate<sp/>the<sp/>reslut<sp/>code<sp/>here</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="82"><highlight class="normal"></highlight></codeline>
<codeline lineno="83"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>stat;</highlight></codeline>
<codeline lineno="84"><highlight class="normal"></highlight></codeline>
<codeline lineno="85"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="diskio_8c_1a779bf099075a999d1074357fccbd466b" kindref="member">USB</ref><sp/>:</highlight></codeline>
<codeline lineno="86"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>=<sp/>USB_disk_initialize();</highlight></codeline>
<codeline lineno="87"><highlight class="normal"></highlight></codeline>
<codeline lineno="88"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>translate<sp/>the<sp/>reslut<sp/>code<sp/>here</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="89"><highlight class="normal"></highlight></codeline>
<codeline lineno="90"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>stat;</highlight></codeline>
<codeline lineno="91"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="92"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="diskio_8h_1abd6503c70d862b979a3f7080a59e9acd" kindref="member">STA_NOINIT</ref>;</highlight></codeline>
<codeline lineno="93"><highlight class="normal">}</highlight></codeline>
<codeline lineno="94"><highlight class="normal"></highlight></codeline>
<codeline lineno="95"><highlight class="normal"></highlight></codeline>
<codeline lineno="96"><highlight class="normal"></highlight></codeline>
<codeline lineno="97"><highlight class="normal"></highlight><highlight class="comment">/*-----------------------------------------------------------------------*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="98"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Read<sp/>Sector(s)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="99"><highlight class="normal"></highlight><highlight class="comment">/*-----------------------------------------------------------------------*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="100"><highlight class="normal"></highlight></codeline>
<codeline lineno="101" refid="group__filesystem_1ga075d27f59f550e2cee07d00abcff32e0" refkind="member"><highlight class="normal"><ref refid="group__filesystem_1gaacdfef1dad6565f65c26d12fe0ea4b2b" kindref="member">DRESULT</ref><sp/><ref refid="group__filesystem_1ga075d27f59f550e2cee07d00abcff32e0" kindref="member">disk_read</ref><sp/>(</highlight></codeline>
<codeline lineno="102"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="integer_8h_1a4ae1dab0fb4b072a66584546209e7d58" kindref="member">BYTE</ref><sp/>pdrv,<sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Physical<sp/>drive<sp/>nmuber<sp/>to<sp/>identify<sp/>the<sp/>drive<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="103"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="integer_8h_1a4ae1dab0fb4b072a66584546209e7d58" kindref="member">BYTE</ref><sp/>*buff,<sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Data<sp/>buffer<sp/>to<sp/>store<sp/>read<sp/>data<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="104"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="integer_8h_1ad342ac907eb044443153a22f964bf0af" kindref="member">DWORD</ref><sp/>sector,<sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Sector<sp/>address<sp/>in<sp/>LBA<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="105"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="integer_8h_1a36cb3b01d81ffd844bbbfb54003e06ec" kindref="member">UINT</ref><sp/>count<sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Number<sp/>of<sp/>sectors<sp/>to<sp/>read<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="106"><highlight class="normal">)</highlight></codeline>
<codeline lineno="107"><highlight class="normal">{</highlight></codeline>
<codeline lineno="108"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__filesystem_1gaacdfef1dad6565f65c26d12fe0ea4b2b" kindref="member">DRESULT</ref><sp/>res;</highlight></codeline>
<codeline lineno="109"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>result;</highlight></codeline>
<codeline lineno="110"><highlight class="normal"></highlight></codeline>
<codeline lineno="111"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(pdrv)<sp/>{</highlight></codeline>
<codeline lineno="112"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="diskio_8c_1a2c51f8df39130923660818986234711f" kindref="member">ATA</ref><sp/>:</highlight></codeline>
<codeline lineno="113"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>translate<sp/>the<sp/>arguments<sp/>here</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="114"><highlight class="normal"></highlight></codeline>
<codeline lineno="115"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>=<sp/>ATA_disk_read(buff,<sp/>sector,<sp/>count);</highlight></codeline>
<codeline lineno="116"><highlight class="normal"></highlight></codeline>
<codeline lineno="117"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>translate<sp/>the<sp/>reslut<sp/>code<sp/>here</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="118"><highlight class="normal"></highlight></codeline>
<codeline lineno="119"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="120"><highlight class="normal"></highlight></codeline>
<codeline lineno="121"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="diskio_8c_1ab5a7d5477e55758bde614bda3250a93c" kindref="member">MMC</ref><sp/>:</highlight></codeline>
<codeline lineno="122"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>translate<sp/>the<sp/>arguments<sp/>here</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="123"><highlight class="normal"></highlight></codeline>
<codeline lineno="124"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>=<sp/>MMC_disk_read(buff,<sp/>sector,<sp/>count);</highlight></codeline>
<codeline lineno="125"><highlight class="normal"></highlight></codeline>
<codeline lineno="126"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>translate<sp/>the<sp/>reslut<sp/>code<sp/>here</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="127"><highlight class="normal"></highlight></codeline>
<codeline lineno="128"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="129"><highlight class="normal"></highlight></codeline>
<codeline lineno="130"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="diskio_8c_1a779bf099075a999d1074357fccbd466b" kindref="member">USB</ref><sp/>:</highlight></codeline>
<codeline lineno="131"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>translate<sp/>the<sp/>arguments<sp/>here</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="132"><highlight class="normal"></highlight></codeline>
<codeline lineno="133"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>=<sp/>USB_disk_read(buff,<sp/>sector,<sp/>count);</highlight></codeline>
<codeline lineno="134"><highlight class="normal"></highlight></codeline>
<codeline lineno="135"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>translate<sp/>the<sp/>reslut<sp/>code<sp/>here</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="136"><highlight class="normal"></highlight></codeline>
<codeline lineno="137"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="138"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="139"><highlight class="normal"></highlight></codeline>
<codeline lineno="140"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="diskio_8h_1gaacdfef1dad6565f65c26d12fe0ea4b2baf4dcc07fd46310b5495fa8025c89a9f3" kindref="member">RES_PARERR</ref>;</highlight></codeline>
<codeline lineno="141"><highlight class="normal">}</highlight></codeline>
<codeline lineno="142"><highlight class="normal"></highlight></codeline>
<codeline lineno="143"><highlight class="normal"></highlight></codeline>
<codeline lineno="144"><highlight class="normal"></highlight></codeline>
<codeline lineno="145"><highlight class="normal"></highlight><highlight class="comment">/*-----------------------------------------------------------------------*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="146"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Write<sp/>Sector(s)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="147"><highlight class="normal"></highlight><highlight class="comment">/*-----------------------------------------------------------------------*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="148"><highlight class="normal"></highlight></codeline>
<codeline lineno="149"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>_USE_WRITE</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="150" refid="group__filesystem_1gac03220b2c8a090b4f76eb2c9407b84fb" refkind="member"><highlight class="normal"><ref refid="group__filesystem_1gaacdfef1dad6565f65c26d12fe0ea4b2b" kindref="member">DRESULT</ref><sp/><ref refid="group__filesystem_1gac03220b2c8a090b4f76eb2c9407b84fb" kindref="member">disk_write</ref><sp/>(</highlight></codeline>
<codeline lineno="151"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="integer_8h_1a4ae1dab0fb4b072a66584546209e7d58" kindref="member">BYTE</ref><sp/>pdrv,<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Physical<sp/>drive<sp/>nmuber<sp/>to<sp/>identify<sp/>the<sp/>drive<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="152"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="integer_8h_1a4ae1dab0fb4b072a66584546209e7d58" kindref="member">BYTE</ref><sp/>*buff,<sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Data<sp/>to<sp/>be<sp/>written<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="153"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="integer_8h_1ad342ac907eb044443153a22f964bf0af" kindref="member">DWORD</ref><sp/>sector,<sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Sector<sp/>address<sp/>in<sp/>LBA<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="154"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="integer_8h_1a36cb3b01d81ffd844bbbfb54003e06ec" kindref="member">UINT</ref><sp/>count<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Number<sp/>of<sp/>sectors<sp/>to<sp/>write<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="155"><highlight class="normal">)</highlight></codeline>
<codeline lineno="156"><highlight class="normal">{</highlight></codeline>
<codeline lineno="157"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__filesystem_1gaacdfef1dad6565f65c26d12fe0ea4b2b" kindref="member">DRESULT</ref><sp/>res;</highlight></codeline>
<codeline lineno="158"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>result;</highlight></codeline>
<codeline lineno="159"><highlight class="normal"></highlight></codeline>
<codeline lineno="160"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(pdrv)<sp/>{</highlight></codeline>
<codeline lineno="161"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="diskio_8c_1a2c51f8df39130923660818986234711f" kindref="member">ATA</ref><sp/>:</highlight></codeline>
<codeline lineno="162"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>translate<sp/>the<sp/>arguments<sp/>here</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="163"><highlight class="normal"></highlight></codeline>
<codeline lineno="164"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>=<sp/>ATA_disk_write(buff,<sp/>sector,<sp/>count);</highlight></codeline>
<codeline lineno="165"><highlight class="normal"></highlight></codeline>
<codeline lineno="166"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>translate<sp/>the<sp/>reslut<sp/>code<sp/>here</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="167"><highlight class="normal"></highlight></codeline>
<codeline lineno="168"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="169"><highlight class="normal"></highlight></codeline>
<codeline lineno="170"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="diskio_8c_1ab5a7d5477e55758bde614bda3250a93c" kindref="member">MMC</ref><sp/>:</highlight></codeline>
<codeline lineno="171"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>translate<sp/>the<sp/>arguments<sp/>here</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="172"><highlight class="normal"></highlight></codeline>
<codeline lineno="173"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>=<sp/>MMC_disk_write(buff,<sp/>sector,<sp/>count);</highlight></codeline>
<codeline lineno="174"><highlight class="normal"></highlight></codeline>
<codeline lineno="175"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>translate<sp/>the<sp/>reslut<sp/>code<sp/>here</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="176"><highlight class="normal"></highlight></codeline>
<codeline lineno="177"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="178"><highlight class="normal"></highlight></codeline>
<codeline lineno="179"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="diskio_8c_1a779bf099075a999d1074357fccbd466b" kindref="member">USB</ref><sp/>:</highlight></codeline>
<codeline lineno="180"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>translate<sp/>the<sp/>arguments<sp/>here</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="181"><highlight class="normal"></highlight></codeline>
<codeline lineno="182"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>=<sp/>USB_disk_write(buff,<sp/>sector,<sp/>count);</highlight></codeline>
<codeline lineno="183"><highlight class="normal"></highlight></codeline>
<codeline lineno="184"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>translate<sp/>the<sp/>reslut<sp/>code<sp/>here</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="185"><highlight class="normal"></highlight></codeline>
<codeline lineno="186"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="187"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="188"><highlight class="normal"></highlight></codeline>
<codeline lineno="189"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="diskio_8h_1gaacdfef1dad6565f65c26d12fe0ea4b2baf4dcc07fd46310b5495fa8025c89a9f3" kindref="member">RES_PARERR</ref>;</highlight></codeline>
<codeline lineno="190"><highlight class="normal">}</highlight></codeline>
<codeline lineno="191"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="192"><highlight class="normal"></highlight></codeline>
<codeline lineno="193"><highlight class="normal"></highlight></codeline>
<codeline lineno="194"><highlight class="normal"></highlight><highlight class="comment">/*-----------------------------------------------------------------------*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="195"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Miscellaneous<sp/>Functions<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="196"><highlight class="normal"></highlight><highlight class="comment">/*-----------------------------------------------------------------------*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="197"><highlight class="normal"></highlight></codeline>
<codeline lineno="198"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>_USE_IOCTL</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="199" refid="group__filesystem_1gab00fa450a811dbdabe3c655c1a36fab4" refkind="member"><highlight class="normal"><ref refid="group__filesystem_1gaacdfef1dad6565f65c26d12fe0ea4b2b" kindref="member">DRESULT</ref><sp/><ref refid="group__filesystem_1gab00fa450a811dbdabe3c655c1a36fab4" kindref="member">disk_ioctl</ref><sp/>(</highlight></codeline>
<codeline lineno="200"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="integer_8h_1a4ae1dab0fb4b072a66584546209e7d58" kindref="member">BYTE</ref><sp/>pdrv,<sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Physical<sp/>drive<sp/>nmuber<sp/>(0..)<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="201"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="integer_8h_1a4ae1dab0fb4b072a66584546209e7d58" kindref="member">BYTE</ref><sp/>cmd,<sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Control<sp/>code<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="202"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*buff<sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Buffer<sp/>to<sp/>send/receive<sp/>control<sp/>data<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="203"><highlight class="normal">)</highlight></codeline>
<codeline lineno="204"><highlight class="normal">{</highlight></codeline>
<codeline lineno="205"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__filesystem_1gaacdfef1dad6565f65c26d12fe0ea4b2b" kindref="member">DRESULT</ref><sp/>res;</highlight></codeline>
<codeline lineno="206"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>result;</highlight></codeline>
<codeline lineno="207"><highlight class="normal"></highlight></codeline>
<codeline lineno="208"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(pdrv)<sp/>{</highlight></codeline>
<codeline lineno="209"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="diskio_8c_1a2c51f8df39130923660818986234711f" kindref="member">ATA</ref><sp/>:</highlight></codeline>
<codeline lineno="210"><highlight class="normal"></highlight></codeline>
<codeline lineno="211"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Process<sp/>of<sp/>the<sp/>command<sp/>for<sp/>the<sp/>ATA<sp/>drive</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="212"><highlight class="normal"></highlight></codeline>
<codeline lineno="213"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="214"><highlight class="normal"></highlight></codeline>
<codeline lineno="215"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="diskio_8c_1ab5a7d5477e55758bde614bda3250a93c" kindref="member">MMC</ref><sp/>:</highlight></codeline>
<codeline lineno="216"><highlight class="normal"></highlight></codeline>
<codeline lineno="217"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Process<sp/>of<sp/>the<sp/>command<sp/>for<sp/>the<sp/>MMC/SD<sp/>card</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="218"><highlight class="normal"></highlight></codeline>
<codeline lineno="219"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="220"><highlight class="normal"></highlight></codeline>
<codeline lineno="221"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="diskio_8c_1a779bf099075a999d1074357fccbd466b" kindref="member">USB</ref><sp/>:</highlight></codeline>
<codeline lineno="222"><highlight class="normal"></highlight></codeline>
<codeline lineno="223"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Process<sp/>of<sp/>the<sp/>command<sp/>the<sp/>USB<sp/>drive</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="224"><highlight class="normal"></highlight></codeline>
<codeline lineno="225"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="226"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="227"><highlight class="normal"></highlight></codeline>
<codeline lineno="228"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="diskio_8h_1gaacdfef1dad6565f65c26d12fe0ea4b2baf4dcc07fd46310b5495fa8025c89a9f3" kindref="member">RES_PARERR</ref>;</highlight></codeline>
<codeline lineno="229"><highlight class="normal">}</highlight></codeline>
<codeline lineno="230"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
    </programlisting>
    <location file="C:/Jenkins/XDK/Pipeline/xdk110/SDK/xdk110/Libraries/FATfs/3rd-party/fatfs/src/diskio.c"/>
  </compounddef>
</doxygen>
