<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Context-Type" content="text/html; charset=UTF-8"/>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>XDK API: FAT File System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
	<div id="header">
		<table class="background-img">
			<tr>
				<td class="left">
					<img src="header_left.jpg" alt="" />
				</td>
				<td class="center">
					<img src="header_center.jpg" alt="" />
				</td>
				<td class="right">
					<img src="header_right.jpg" alt="" />
				</td>
			</tr>
		</table>
	</div>
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="XDK-Main-App-Icon-64.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">XDK API
   &#160;<span id="projectnumber">3.6.0</span>
   </div>
   <div id="projectbrief">Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<html><head></head><body></body></html><!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">FAT File System</div>  </div>
</div><!--header-->
<div class="contents">

<p>FatFS Documentation.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:diskio_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="diskio_8h.html">diskio.h</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ff_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ff_8h.html">ff.h</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:struct_d_i_r"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#struct_d_i_r">DIR</a></td></tr>
<tr class="separator:struct_d_i_r"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_f_a_t_f_s"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#struct_f_a_t_f_s">FATFS</a></td></tr>
<tr class="separator:struct_f_a_t_f_s"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_f_i_l"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#struct_f_i_l">FIL</a></td></tr>
<tr class="separator:struct_f_i_l"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_f_i_l_i_n_f_o"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#struct_f_i_l_i_n_f_o">FILINFO</a></td></tr>
<tr class="separator:struct_f_i_l_i_n_f_o"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaacdfef1dad6565f65c26d12fe0ea4b2b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#gaacdfef1dad6565f65c26d12fe0ea4b2b">DRESULT</a> </td></tr>
<tr class="separator:gaacdfef1dad6565f65c26d12fe0ea4b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49d0171ecbd362cda5680a0d360db44c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a> </td></tr>
<tr class="separator:ga49d0171ecbd362cda5680a0d360db44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga09cdaa6f36fa409bdf002727bff98eb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="diskio_8h.html#adba6790898ce4029c20a34b898ce73c1">DSTATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#ga09cdaa6f36fa409bdf002727bff98eb1">disk_initialize</a> (<a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> pdrv)</td></tr>
<tr class="memdesc:ga09cdaa6f36fa409bdf002727bff98eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The disk_initialize function initializes the storage device.  <a href="#ga09cdaa6f36fa409bdf002727bff98eb1">More...</a><br /></td></tr>
<tr class="separator:ga09cdaa6f36fa409bdf002727bff98eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab00fa450a811dbdabe3c655c1a36fab4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__filesystem.html#gaacdfef1dad6565f65c26d12fe0ea4b2b">DRESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#gab00fa450a811dbdabe3c655c1a36fab4">disk_ioctl</a> (<a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> pdrv, <a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> cmd, void *buff)</td></tr>
<tr class="memdesc:gab00fa450a811dbdabe3c655c1a36fab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The disk_ioctl function cntrols device specific features and miscellaneous functions other than generic read/write.  <a href="#gab00fa450a811dbdabe3c655c1a36fab4">More...</a><br /></td></tr>
<tr class="separator:gab00fa450a811dbdabe3c655c1a36fab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga075d27f59f550e2cee07d00abcff32e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__filesystem.html#gaacdfef1dad6565f65c26d12fe0ea4b2b">DRESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#ga075d27f59f550e2cee07d00abcff32e0">disk_read</a> (<a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> pdrv, <a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> *buff, <a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a> sector, <a class="el" href="integer_8h.html#a36cb3b01d81ffd844bbbfb54003e06ec">UINT</a> count)</td></tr>
<tr class="memdesc:ga075d27f59f550e2cee07d00abcff32e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The disk_read function reads sector(s) from the storage device.  <a href="#ga075d27f59f550e2cee07d00abcff32e0">More...</a><br /></td></tr>
<tr class="separator:ga075d27f59f550e2cee07d00abcff32e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8348ac5ee6d709420c02e45c111f4793"><td class="memItemLeft" align="right" valign="top"><a class="el" href="diskio_8h.html#adba6790898ce4029c20a34b898ce73c1">DSTATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#ga8348ac5ee6d709420c02e45c111f4793">disk_status</a> (<a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> pdrv)</td></tr>
<tr class="memdesc:ga8348ac5ee6d709420c02e45c111f4793"><td class="mdescLeft">&#160;</td><td class="mdescRight">The disk_status function returns the current drive status.  <a href="#ga8348ac5ee6d709420c02e45c111f4793">More...</a><br /></td></tr>
<tr class="separator:ga8348ac5ee6d709420c02e45c111f4793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac03220b2c8a090b4f76eb2c9407b84fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__filesystem.html#gaacdfef1dad6565f65c26d12fe0ea4b2b">DRESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#gac03220b2c8a090b4f76eb2c9407b84fb">disk_write</a> (<a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> drv, const <a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> *buff, <a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a> sector, <a class="el" href="integer_8h.html#a36cb3b01d81ffd844bbbfb54003e06ec">UINT</a> count)</td></tr>
<tr class="memdesc:gac03220b2c8a090b4f76eb2c9407b84fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The disk_write writes sector(s) to the storage device.  <a href="#gac03220b2c8a090b4f76eb2c9407b84fb">More...</a><br /></td></tr>
<tr class="separator:gac03220b2c8a090b4f76eb2c9407b84fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53c7e9a7fb3c279254cd2d0445667e2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#ga53c7e9a7fb3c279254cd2d0445667e2f">f_chdir</a> (const <a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *path)</td></tr>
<tr class="memdesc:ga53c7e9a7fb3c279254cd2d0445667e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The f_chdir function changes the current directory of a drive.  <a href="#ga53c7e9a7fb3c279254cd2d0445667e2f">More...</a><br /></td></tr>
<tr class="separator:ga53c7e9a7fb3c279254cd2d0445667e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13e5933f851b436890361189f64261cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#ga13e5933f851b436890361189f64261cd">f_chdrive</a> (const <a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *path)</td></tr>
<tr class="memdesc:ga13e5933f851b436890361189f64261cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The f_chdrive function changes the current drive.  <a href="#ga13e5933f851b436890361189f64261cd">More...</a><br /></td></tr>
<tr class="separator:ga13e5933f851b436890361189f64261cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ee7e560eec8d82755c636ae41e702cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#ga9ee7e560eec8d82755c636ae41e702cd">f_chmod</a> (const <a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *path, <a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> attr, <a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> mask)</td></tr>
<tr class="memdesc:ga9ee7e560eec8d82755c636ae41e702cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The f_chmod function changes the attribute of a file or sub-directory.  <a href="#ga9ee7e560eec8d82755c636ae41e702cd">More...</a><br /></td></tr>
<tr class="separator:ga9ee7e560eec8d82755c636ae41e702cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53882db20ef4323dcfd1874d7733ffc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#ga53882db20ef4323dcfd1874d7733ffc3">f_close</a> (<a class="el" href="group__filesystem.html#struct_f_i_l">FIL</a> *fp)</td></tr>
<tr class="memdesc:ga53882db20ef4323dcfd1874d7733ffc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The f_close function closes an open file.  <a href="#ga53882db20ef4323dcfd1874d7733ffc3">More...</a><br /></td></tr>
<tr class="separator:ga53882db20ef4323dcfd1874d7733ffc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5f7376b6f3e3bcc7f5ff5497c8b7364"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#gab5f7376b6f3e3bcc7f5ff5497c8b7364">f_closedir</a> (<a class="el" href="group__filesystem.html#struct_d_i_r">DIR</a> *dp)</td></tr>
<tr class="memdesc:gab5f7376b6f3e3bcc7f5ff5497c8b7364"><td class="mdescLeft">&#160;</td><td class="mdescRight">The f_closedir function closes an open directory.  <a href="#gab5f7376b6f3e3bcc7f5ff5497c8b7364">More...</a><br /></td></tr>
<tr class="separator:gab5f7376b6f3e3bcc7f5ff5497c8b7364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0878582b1255b693b29dca3c6ecccf1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#gaf0878582b1255b693b29dca3c6ecccf1">f_eof</a> (<a class="el" href="group__filesystem.html#struct_f_i_l">FIL</a> *fp)</td></tr>
<tr class="memdesc:gaf0878582b1255b693b29dca3c6ecccf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The f_eof function tests for end-of-file on a file.  <a href="#gaf0878582b1255b693b29dca3c6ecccf1">More...</a><br /></td></tr>
<tr class="separator:gaf0878582b1255b693b29dca3c6ecccf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3c6dd79ef26a59629a6c8f6afe71fbf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#gad3c6dd79ef26a59629a6c8f6afe71fbf">f_error</a> (<a class="el" href="group__filesystem.html#struct_f_i_l">FIL</a> *fp)</td></tr>
<tr class="memdesc:gad3c6dd79ef26a59629a6c8f6afe71fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The f_error tests for an error on a file.  <a href="#gad3c6dd79ef26a59629a6c8f6afe71fbf">More...</a><br /></td></tr>
<tr class="separator:gad3c6dd79ef26a59629a6c8f6afe71fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c1bd3e3872abbda0e256e7c73da9f3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#ga0c1bd3e3872abbda0e256e7c73da9f3b">f_fdisk</a> (<a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> pdrv, const <a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a> part[], void *work)</td></tr>
<tr class="memdesc:ga0c1bd3e3872abbda0e256e7c73da9f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The f_fdisk fucntion divides a physical drive.  <a href="#ga0c1bd3e3872abbda0e256e7c73da9f3b">More...</a><br /></td></tr>
<tr class="separator:ga0c1bd3e3872abbda0e256e7c73da9f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c0c4cd695704aa6d952c90be81d9849"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#ga6c0c4cd695704aa6d952c90be81d9849">f_forward</a> (<a class="el" href="group__filesystem.html#struct_f_i_l">FIL</a> *fp, <a class="el" href="integer_8h.html#a36cb3b01d81ffd844bbbfb54003e06ec">UINT</a>(*func)(const <a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> *, <a class="el" href="integer_8h.html#a36cb3b01d81ffd844bbbfb54003e06ec">UINT</a>), <a class="el" href="integer_8h.html#a36cb3b01d81ffd844bbbfb54003e06ec">UINT</a> btf, <a class="el" href="integer_8h.html#a36cb3b01d81ffd844bbbfb54003e06ec">UINT</a> *bf)</td></tr>
<tr class="memdesc:ga6c0c4cd695704aa6d952c90be81d9849"><td class="mdescLeft">&#160;</td><td class="mdescRight">The f_forward function reads the file data and forward it to the data streaming device.  <a href="#ga6c0c4cd695704aa6d952c90be81d9849">More...</a><br /></td></tr>
<tr class="separator:ga6c0c4cd695704aa6d952c90be81d9849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb865a03dbac0031ac5cb8a031f7b71c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#gacb865a03dbac0031ac5cb8a031f7b71c">f_getcwd</a> (<a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *buff, <a class="el" href="integer_8h.html#a36cb3b01d81ffd844bbbfb54003e06ec">UINT</a> len)</td></tr>
<tr class="memdesc:gacb865a03dbac0031ac5cb8a031f7b71c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The f_getcwd function retrieves the current directory.  <a href="#gacb865a03dbac0031ac5cb8a031f7b71c">More...</a><br /></td></tr>
<tr class="separator:gacb865a03dbac0031ac5cb8a031f7b71c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ff39f75a87cbda9cd6ea65d83f16cec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#ga0ff39f75a87cbda9cd6ea65d83f16cec">f_getfree</a> (const <a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *path, <a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a> *nclst, <a class="el" href="group__filesystem.html#struct_f_a_t_f_s">FATFS</a> **fatfs)</td></tr>
<tr class="memdesc:ga0ff39f75a87cbda9cd6ea65d83f16cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The f_getfree function gets number of the free clusters on the volume.  <a href="#ga0ff39f75a87cbda9cd6ea65d83f16cec">More...</a><br /></td></tr>
<tr class="separator:ga0ff39f75a87cbda9cd6ea65d83f16cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4ff40a674bcbfe40d81b1e8e54befc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#gac4ff40a674bcbfe40d81b1e8e54befc6">f_getlabel</a> (const <a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *path, <a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *label, <a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a> *vsn)</td></tr>
<tr class="memdesc:gac4ff40a674bcbfe40d81b1e8e54befc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The f_getlabel function returns volume label and volume serial number of a drive. <br />
 Example:  <a href="#gac4ff40a674bcbfe40d81b1e8e54befc6">More...</a><br /></td></tr>
<tr class="separator:gac4ff40a674bcbfe40d81b1e8e54befc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fa54bd310785ecdaed19dda8f60dac5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#ga0fa54bd310785ecdaed19dda8f60dac5">f_gets</a> (<a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *buff, int len, <a class="el" href="group__filesystem.html#struct_f_i_l">FIL</a> *fp)</td></tr>
<tr class="memdesc:ga0fa54bd310785ecdaed19dda8f60dac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The f_gets reads a string from the file.  <a href="#ga0fa54bd310785ecdaed19dda8f60dac5">More...</a><br /></td></tr>
<tr class="separator:ga0fa54bd310785ecdaed19dda8f60dac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5df0ac672ada972e89ef4b003e57f964"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#ga5df0ac672ada972e89ef4b003e57f964">f_lseek</a> (<a class="el" href="group__filesystem.html#struct_f_i_l">FIL</a> *fp, <a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a> ofs)</td></tr>
<tr class="memdesc:ga5df0ac672ada972e89ef4b003e57f964"><td class="mdescLeft">&#160;</td><td class="mdescRight">The f_lseek function moves the file read/write pointer of an open file object. It can also be used to expand the file size (cluster pre-allocation).  <a href="#ga5df0ac672ada972e89ef4b003e57f964">More...</a><br /></td></tr>
<tr class="separator:ga5df0ac672ada972e89ef4b003e57f964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b4d38db58e89c526cfcf53200d719d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#ga4b4d38db58e89c526cfcf53200d719d0">f_mkdir</a> (const <a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *path)</td></tr>
<tr class="memdesc:ga4b4d38db58e89c526cfcf53200d719d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The f_mkdir function creates a new directory.  <a href="#ga4b4d38db58e89c526cfcf53200d719d0">More...</a><br /></td></tr>
<tr class="separator:ga4b4d38db58e89c526cfcf53200d719d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga799aff9594e708c8be357281cf85428b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#ga799aff9594e708c8be357281cf85428b">f_mkfs</a> (const <a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *path, <a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> sfd, <a class="el" href="integer_8h.html#a36cb3b01d81ffd844bbbfb54003e06ec">UINT</a> au)</td></tr>
<tr class="memdesc:ga799aff9594e708c8be357281cf85428b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The f_mkfs fucntion creates an FAT file system on the logical drive.  <a href="#ga799aff9594e708c8be357281cf85428b">More...</a><br /></td></tr>
<tr class="separator:ga799aff9594e708c8be357281cf85428b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16a934c2bbfa2160295810adc49d5509"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#ga16a934c2bbfa2160295810adc49d5509">f_mount</a> (<a class="el" href="group__filesystem.html#struct_f_a_t_f_s">FATFS</a> *fs, const <a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *path, <a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> opt)</td></tr>
<tr class="memdesc:ga16a934c2bbfa2160295810adc49d5509"><td class="mdescLeft">&#160;</td><td class="mdescRight">The f_mount fucntion registers/unregisters file system object to the FatFs module.  <a href="#ga16a934c2bbfa2160295810adc49d5509">More...</a><br /></td></tr>
<tr class="separator:ga16a934c2bbfa2160295810adc49d5509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefdef7126128d99d0b3bd82c28e54d80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#gaefdef7126128d99d0b3bd82c28e54d80">f_open</a> (<a class="el" href="group__filesystem.html#struct_f_i_l">FIL</a> *fp, const <a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *path, <a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> mode)</td></tr>
<tr class="memdesc:gaefdef7126128d99d0b3bd82c28e54d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">The f_open function creates a file object to be used to access the file.  <a href="#gaefdef7126128d99d0b3bd82c28e54d80">More...</a><br /></td></tr>
<tr class="separator:gaefdef7126128d99d0b3bd82c28e54d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab63b213c75f7335fbb63a1f3f70e5fc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#gab63b213c75f7335fbb63a1f3f70e5fc7">f_opendir</a> (<a class="el" href="group__filesystem.html#struct_d_i_r">DIR</a> *dp, const <a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *path)</td></tr>
<tr class="memdesc:gab63b213c75f7335fbb63a1f3f70e5fc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The f_opendir function opens a directory.  <a href="#gab63b213c75f7335fbb63a1f3f70e5fc7">More...</a><br /></td></tr>
<tr class="separator:gab63b213c75f7335fbb63a1f3f70e5fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49cccab38cd84e2d3357fef2d1df21f9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#ga49cccab38cd84e2d3357fef2d1df21f9">f_printf</a> (<a class="el" href="group__filesystem.html#struct_f_i_l">FIL</a> *fp, const <a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *fmt,...)</td></tr>
<tr class="memdesc:ga49cccab38cd84e2d3357fef2d1df21f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The f_printf function writes formatted string to the file.  <a href="#ga49cccab38cd84e2d3357fef2d1df21f9">More...</a><br /></td></tr>
<tr class="separator:ga49cccab38cd84e2d3357fef2d1df21f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62a35ee79e4913c1e31ac706241be7da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#ga62a35ee79e4913c1e31ac706241be7da">f_putc</a> (<a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> chr, <a class="el" href="group__filesystem.html#struct_f_i_l">FIL</a> *fp)</td></tr>
<tr class="memdesc:ga62a35ee79e4913c1e31ac706241be7da"><td class="mdescLeft">&#160;</td><td class="mdescRight">The f_putc funciton puts a character to the file.  <a href="#ga62a35ee79e4913c1e31ac706241be7da">More...</a><br /></td></tr>
<tr class="separator:ga62a35ee79e4913c1e31ac706241be7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9443c00129414fbfc16a5a13ad876ced"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#ga9443c00129414fbfc16a5a13ad876ced">f_puts</a> (const <a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *str, <a class="el" href="group__filesystem.html#struct_f_i_l">FIL</a> *fp)</td></tr>
<tr class="memdesc:ga9443c00129414fbfc16a5a13ad876ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">The f_puts function writes a string to the file.  <a href="#ga9443c00129414fbfc16a5a13ad876ced">More...</a><br /></td></tr>
<tr class="separator:ga9443c00129414fbfc16a5a13ad876ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4c3dcb6869ca252888eebabe39727b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#gac4c3dcb6869ca252888eebabe39727b3">f_read</a> (<a class="el" href="group__filesystem.html#struct_f_i_l">FIL</a> *fp, void *buff, <a class="el" href="integer_8h.html#a36cb3b01d81ffd844bbbfb54003e06ec">UINT</a> btr, <a class="el" href="integer_8h.html#a36cb3b01d81ffd844bbbfb54003e06ec">UINT</a> *br)</td></tr>
<tr class="memdesc:gac4c3dcb6869ca252888eebabe39727b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The f_read function reads data from a file.  <a href="#gac4c3dcb6869ca252888eebabe39727b3">More...</a><br /></td></tr>
<tr class="separator:gac4c3dcb6869ca252888eebabe39727b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab39e82a110695de45f416f3149358012"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#gab39e82a110695de45f416f3149358012">f_readdir</a> (<a class="el" href="group__filesystem.html#struct_d_i_r">DIR</a> *dp, <a class="el" href="group__filesystem.html#struct_f_i_l_i_n_f_o">FILINFO</a> *fno)</td></tr>
<tr class="memdesc:gab39e82a110695de45f416f3149358012"><td class="mdescLeft">&#160;</td><td class="mdescRight">The f_readdir function reads directory entries.  <a href="#gab39e82a110695de45f416f3149358012">More...</a><br /></td></tr>
<tr class="separator:gab39e82a110695de45f416f3149358012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d0ceea336edd9b05754c8684ea8a72f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#ga2d0ceea336edd9b05754c8684ea8a72f">f_rename</a> (const <a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *old_name, const <a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *new_name)</td></tr>
<tr class="memdesc:ga2d0ceea336edd9b05754c8684ea8a72f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renames a file or sub-directory.  <a href="#ga2d0ceea336edd9b05754c8684ea8a72f">More...</a><br /></td></tr>
<tr class="separator:ga2d0ceea336edd9b05754c8684ea8a72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa82bca64e28bc0d656a7999dd0eadec7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#gaa82bca64e28bc0d656a7999dd0eadec7">f_setlabel</a> (const <a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *label)</td></tr>
<tr class="memdesc:gaa82bca64e28bc0d656a7999dd0eadec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The f_setlabel function sets/removes the label of a volume.  <a href="#gaa82bca64e28bc0d656a7999dd0eadec7">More...</a><br /></td></tr>
<tr class="separator:gaa82bca64e28bc0d656a7999dd0eadec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c1a803b666f1cc92b2f9363d877a82e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#ga5c1a803b666f1cc92b2f9363d877a82e">f_size</a> (<a class="el" href="group__filesystem.html#struct_f_i_l">FIL</a> *fp)</td></tr>
<tr class="memdesc:ga5c1a803b666f1cc92b2f9363d877a82e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The f_size function gets the size of a file.  <a href="#ga5c1a803b666f1cc92b2f9363d877a82e">More...</a><br /></td></tr>
<tr class="separator:ga5c1a803b666f1cc92b2f9363d877a82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe1f60daab5c7d11170c334fb832c798"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#gabe1f60daab5c7d11170c334fb832c798">f_stat</a> (const <a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *path, <a class="el" href="group__filesystem.html#struct_f_i_l_i_n_f_o">FILINFO</a> *fno)</td></tr>
<tr class="memdesc:gabe1f60daab5c7d11170c334fb832c798"><td class="mdescLeft">&#160;</td><td class="mdescRight">The f_stat function checks the existence of a file or sub-directory.  <a href="#gabe1f60daab5c7d11170c334fb832c798">More...</a><br /></td></tr>
<tr class="separator:gabe1f60daab5c7d11170c334fb832c798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad69c7246b122ba56a134939ee0eaf847"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#gad69c7246b122ba56a134939ee0eaf847">f_sync</a> (<a class="el" href="group__filesystem.html#struct_f_i_l">FIL</a> *fp)</td></tr>
<tr class="memdesc:gad69c7246b122ba56a134939ee0eaf847"><td class="mdescLeft">&#160;</td><td class="mdescRight">The f_sync function flushes the cached information of a writing file.  <a href="#gad69c7246b122ba56a134939ee0eaf847">More...</a><br /></td></tr>
<tr class="separator:gad69c7246b122ba56a134939ee0eaf847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga091c830b8b17e19267dac539f9093128"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#ga091c830b8b17e19267dac539f9093128">f_tell</a> (<a class="el" href="group__filesystem.html#struct_f_i_l">FIL</a> *fp)</td></tr>
<tr class="memdesc:ga091c830b8b17e19267dac539f9093128"><td class="mdescLeft">&#160;</td><td class="mdescRight">The f_tell function gets the current read/write pointer of a file.  <a href="#ga091c830b8b17e19267dac539f9093128">More...</a><br /></td></tr>
<tr class="separator:ga091c830b8b17e19267dac539f9093128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga691a27b40c348f7c84b42e911636f38a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#ga691a27b40c348f7c84b42e911636f38a">f_truncate</a> (<a class="el" href="group__filesystem.html#struct_f_i_l">FIL</a> *fp)</td></tr>
<tr class="memdesc:ga691a27b40c348f7c84b42e911636f38a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The f_truncate function truncates the file size.  <a href="#ga691a27b40c348f7c84b42e911636f38a">More...</a><br /></td></tr>
<tr class="separator:ga691a27b40c348f7c84b42e911636f38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2858167fcd0bced48e9be434b3895efe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#ga2858167fcd0bced48e9be434b3895efe">f_unlink</a> (const <a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *path)</td></tr>
<tr class="memdesc:ga2858167fcd0bced48e9be434b3895efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The f_unlink function removes a file or sub-directory.  <a href="#ga2858167fcd0bced48e9be434b3895efe">More...</a><br /></td></tr>
<tr class="separator:ga2858167fcd0bced48e9be434b3895efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafaa718d1a487e12a8f0087173dba0b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#gaafaa718d1a487e12a8f0087173dba0b9">f_utime</a> (const <a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *path, const <a class="el" href="group__filesystem.html#struct_f_i_l_i_n_f_o">FILINFO</a> *fno)</td></tr>
<tr class="memdesc:gaafaa718d1a487e12a8f0087173dba0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The f_utime function changes the timestamp of a file or sub-directory.  <a href="#gaafaa718d1a487e12a8f0087173dba0b9">More...</a><br /></td></tr>
<tr class="separator:gaafaa718d1a487e12a8f0087173dba0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6a4dfae8a9e308bdb2283a37ef680f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#gae6a4dfae8a9e308bdb2283a37ef680f2">f_write</a> (<a class="el" href="group__filesystem.html#struct_f_i_l">FIL</a> *fp, const void *buff, <a class="el" href="integer_8h.html#a36cb3b01d81ffd844bbbfb54003e06ec">UINT</a> btw, <a class="el" href="integer_8h.html#a36cb3b01d81ffd844bbbfb54003e06ec">UINT</a> *bw)</td></tr>
<tr class="memdesc:gae6a4dfae8a9e308bdb2283a37ef680f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The f_write writes data to a file.  <a href="#gae6a4dfae8a9e308bdb2283a37ef680f2">More...</a><br /></td></tr>
<tr class="separator:gae6a4dfae8a9e308bdb2283a37ef680f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf58b536abfd30f77213f4ecaf2ac52f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#gaf58b536abfd30f77213f4ecaf2ac52f5">get_fattime</a> (void)</td></tr>
<tr class="memdesc:gaf58b536abfd30f77213f4ecaf2ac52f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The get_fattime function gets current time.  <a href="#gaf58b536abfd30f77213f4ecaf2ac52f5">More...</a><br /></td></tr>
<tr class="separator:gaf58b536abfd30f77213f4ecaf2ac52f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h1><a class="anchor" id="fatfs_title"></a>
FatFs - Generic FAT File System Module</h1>
<p>FatFs is a generic FAT file system module for small embedded systems. The FatFs is written in compliance with ANSI C and completely separated from the disk I/O layer. Therefore it is independent of hardware architecture. It can be incorporated into small microcontrollers with limited resource, such as AVR, 8051, PIC, ARM, Z80, 68k and etc.</p>
<p>Features:</p><ul>
<li>Windows compatible FAT file system.</li>
<li>Platform independent. Easy to port.</li>
<li>Very small footprint for code and work area.</li>
<li>Various configuration options:<ul>
<li>Multiple volumes (physical drives and partitions).</li>
<li>Multiple ANSI/OEM code pages including DBCS.</li>
<li>Long file name support in ANSI/OEM or Unicode.</li>
<li>RTOS support.</li>
<li>Multiple sector size support.</li>
<li>Read-only, minimized API, I/O buffer and etc..</li>
</ul>
</li>
</ul>
<div class="image">
<img src="layers.jpg" alt="layers.jpg"/>
</div>
<h1><a class="anchor" id="interface"></a>
Device Control Interface</h1>
<p>Since the FatFs module is a file system layer, it is completely separated from physical devices, such as memory card, harddisk and any type of storage devices. FatFs access the storage device via a simple interface described below. The low level device control module is not a part of FatFs module. It is provided by implementer. Also sample implementations for some platforms are available in the downloads. </p>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="struct_d_i_r" id="struct_d_i_r"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct DIR</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for DIR:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="struct_d_i_r__coll__graph.png" border="0" usemap="#_d_i_r_coll__map" alt="Collaboration graph"/></div>
<map name="_d_i_r_coll__map" id="_d_i_r_coll__map">
<area shape="rect" id="node2" href="group__filesystem.html#struct_f_a_t_f_s" title="FATFS" alt="" coords="5,5,68,32"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:ac134c1b4645be670eb5207032e714616"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#ac134c1b4645be670eb5207032e714616">clust</a></td></tr>
<tr class="separator:ac134c1b4645be670eb5207032e714616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30fe34a14a6efb4c9c04a522f6cf3378"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#a30fe34a14a6efb4c9c04a522f6cf3378">dir</a></td></tr>
<tr class="separator:a30fe34a14a6efb4c9c04a522f6cf3378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e961714af3bc25c08d5832cca23204"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#a34e961714af3bc25c08d5832cca23204">fn</a></td></tr>
<tr class="separator:a34e961714af3bc25c08d5832cca23204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae363a794e38f3a9aa1d55b8e3c7fcee7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__filesystem.html#struct_f_a_t_f_s">FATFS</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#ae363a794e38f3a9aa1d55b8e3c7fcee7">fs</a></td></tr>
<tr class="separator:ae363a794e38f3a9aa1d55b8e3c7fcee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7a6396b2c82ad46c6d8b2bf141a8dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#a197942eefa7db30960ae396d68339b97">WORD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#a7b7a6396b2c82ad46c6d8b2bf141a8dd">id</a></td></tr>
<tr class="separator:a7b7a6396b2c82ad46c6d8b2bf141a8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c5089b70ce76bcd61abe615ed2a42b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#a197942eefa7db30960ae396d68339b97">WORD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#ab7c5089b70ce76bcd61abe615ed2a42b">index</a></td></tr>
<tr class="separator:ab7c5089b70ce76bcd61abe615ed2a42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ac58da8ca4254c6923552f1a9ca92d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#a570001c92f314285ad3e7139d8c58cf7">WCHAR</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#a95ac58da8ca4254c6923552f1a9ca92d">lfn</a></td></tr>
<tr class="separator:a95ac58da8ca4254c6923552f1a9ca92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f94c0148d9e604278c77e10ab0140cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#a197942eefa7db30960ae396d68339b97">WORD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#a7f94c0148d9e604278c77e10ab0140cb">lfn_idx</a></td></tr>
<tr class="separator:a7f94c0148d9e604278c77e10ab0140cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d52f3fde971d2a05ff777a6243c252"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#ad5d52f3fde971d2a05ff777a6243c252">sclust</a></td></tr>
<tr class="separator:ad5d52f3fde971d2a05ff777a6243c252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e49e0860170e0fd9fc3e891b0d59975"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#a3e49e0860170e0fd9fc3e891b0d59975">sect</a></td></tr>
<tr class="separator:a3e49e0860170e0fd9fc3e891b0d59975"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Field Documentation</h4>
<a class="anchor" id="ac134c1b4645be670eb5207032e714616"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a> clust</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a30fe34a14a6efb4c9c04a522f6cf3378"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>* dir</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a34e961714af3bc25c08d5832cca23204"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>* fn</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae363a794e38f3a9aa1d55b8e3c7fcee7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__filesystem.html#struct_f_a_t_f_s">FATFS</a>* fs</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7b7a6396b2c82ad46c6d8b2bf141a8dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#a197942eefa7db30960ae396d68339b97">WORD</a> id</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab7c5089b70ce76bcd61abe615ed2a42b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#a197942eefa7db30960ae396d68339b97">WORD</a> index</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a95ac58da8ca4254c6923552f1a9ca92d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#a570001c92f314285ad3e7139d8c58cf7">WCHAR</a>* lfn</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7f94c0148d9e604278c77e10ab0140cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#a197942eefa7db30960ae396d68339b97">WORD</a> lfn_idx</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad5d52f3fde971d2a05ff777a6243c252"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a> sclust</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3e49e0860170e0fd9fc3e891b0d59975"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a> sect</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>

</div>
</div>
<a name="struct_f_a_t_f_s" id="struct_f_a_t_f_s"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct FATFS</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:ace95d33f1aefff4c3e821cf8eac7ec3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#ace95d33f1aefff4c3e821cf8eac7ec3e">csize</a></td></tr>
<tr class="separator:ace95d33f1aefff4c3e821cf8eac7ec3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112ba7d33529e5c9fda3b950fff01180"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#a112ba7d33529e5c9fda3b950fff01180">database</a></td></tr>
<tr class="separator:a112ba7d33529e5c9fda3b950fff01180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebfa6556d8f94e951a8b2c1eb740e9a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#aebfa6556d8f94e951a8b2c1eb740e9a1">dirbase</a></td></tr>
<tr class="separator:aebfa6556d8f94e951a8b2c1eb740e9a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46443bf86aaaff8d411814ed640e831"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#af46443bf86aaaff8d411814ed640e831">drv</a></td></tr>
<tr class="separator:af46443bf86aaaff8d411814ed640e831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e60540a346de6eb9f0c13d6203efa1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#a74e60540a346de6eb9f0c13d6203efa1">fatbase</a></td></tr>
<tr class="separator:a74e60540a346de6eb9f0c13d6203efa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509defa217cfb2eb777ed3c74c4ef426"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#a509defa217cfb2eb777ed3c74c4ef426">free_clust</a></td></tr>
<tr class="separator:a509defa217cfb2eb777ed3c74c4ef426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3630ef0b29c45ef8e0c1de639efab754"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#a3630ef0b29c45ef8e0c1de639efab754">fs_type</a></td></tr>
<tr class="separator:a3630ef0b29c45ef8e0c1de639efab754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c4d8e68262d5542852e2aed6ce69b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#a66c4d8e68262d5542852e2aed6ce69b4">fsi_flag</a></td></tr>
<tr class="separator:a66c4d8e68262d5542852e2aed6ce69b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70a0afd16367837984d6205cbfca308"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#af70a0afd16367837984d6205cbfca308">fsize</a></td></tr>
<tr class="separator:af70a0afd16367837984d6205cbfca308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7a6396b2c82ad46c6d8b2bf141a8dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#a197942eefa7db30960ae396d68339b97">WORD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#a7b7a6396b2c82ad46c6d8b2bf141a8dd">id</a></td></tr>
<tr class="separator:a7b7a6396b2c82ad46c6d8b2bf141a8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10cd8b80b3b6474bf0d6432c8fb9d2d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#a10cd8b80b3b6474bf0d6432c8fb9d2d2">last_clust</a></td></tr>
<tr class="separator:a10cd8b80b3b6474bf0d6432c8fb9d2d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388eb0fa0f3f1449a6ab88c6674e16fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#a388eb0fa0f3f1449a6ab88c6674e16fc">n_fatent</a></td></tr>
<tr class="separator:a388eb0fa0f3f1449a6ab88c6674e16fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18fdbb9dec86b70abc6ee2a1217ac47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#af18fdbb9dec86b70abc6ee2a1217ac47">n_fats</a></td></tr>
<tr class="separator:af18fdbb9dec86b70abc6ee2a1217ac47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e74fc44cd5274ba7c3b18d5e357697"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#a197942eefa7db30960ae396d68339b97">WORD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#a22e74fc44cd5274ba7c3b18d5e357697">n_rootdir</a></td></tr>
<tr class="separator:a22e74fc44cd5274ba7c3b18d5e357697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2c369d5858a2d8b60e65431b0b1a85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___f_f_c_o_n_f_i_g.html#ga9a3f0670343e51652dd12b18fa90a9eb">_SYNC_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#a1c2c369d5858a2d8b60e65431b0b1a85">sobj</a></td></tr>
<tr class="separator:a1c2c369d5858a2d8b60e65431b0b1a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3472628262823af495681702709e8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#a3e3472628262823af495681702709e8e">volbase</a></td></tr>
<tr class="separator:a3e3472628262823af495681702709e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3983f8d19ef9879f30d04b076e9ff2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#adb3983f8d19ef9879f30d04b076e9ff2">wflag</a></td></tr>
<tr class="separator:adb3983f8d19ef9879f30d04b076e9ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf9e848c88b78e22df6e09a0626e6f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#aabf9e848c88b78e22df6e09a0626e6f5">win</a> [<a class="el" href="group___f_f_c_o_n_f_i_g.html#gac271b697378912f17132cb9c7d0de024">_MAX_SS</a>]</td></tr>
<tr class="separator:aabf9e848c88b78e22df6e09a0626e6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285dc1de6874bb5f0c41c328c9433e14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#a285dc1de6874bb5f0c41c328c9433e14">winsect</a></td></tr>
<tr class="separator:a285dc1de6874bb5f0c41c328c9433e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Field Documentation</h4>
<a class="anchor" id="ace95d33f1aefff4c3e821cf8eac7ec3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> csize</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a112ba7d33529e5c9fda3b950fff01180"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a> database</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aebfa6556d8f94e951a8b2c1eb740e9a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a> dirbase</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af46443bf86aaaff8d411814ed640e831"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> drv</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a74e60540a346de6eb9f0c13d6203efa1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a> fatbase</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a509defa217cfb2eb777ed3c74c4ef426"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a> free_clust</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3630ef0b29c45ef8e0c1de639efab754"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> fs_type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a66c4d8e68262d5542852e2aed6ce69b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> fsi_flag</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af70a0afd16367837984d6205cbfca308"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a> fsize</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7b7a6396b2c82ad46c6d8b2bf141a8dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#a197942eefa7db30960ae396d68339b97">WORD</a> id</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a10cd8b80b3b6474bf0d6432c8fb9d2d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a> last_clust</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a388eb0fa0f3f1449a6ab88c6674e16fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a> n_fatent</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af18fdbb9dec86b70abc6ee2a1217ac47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> n_fats</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a22e74fc44cd5274ba7c3b18d5e357697"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#a197942eefa7db30960ae396d68339b97">WORD</a> n_rootdir</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1c2c369d5858a2d8b60e65431b0b1a85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___f_f_c_o_n_f_i_g.html#ga9a3f0670343e51652dd12b18fa90a9eb">_SYNC_t</a> sobj</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3e3472628262823af495681702709e8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a> volbase</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adb3983f8d19ef9879f30d04b076e9ff2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> wflag</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aabf9e848c88b78e22df6e09a0626e6f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> win[<a class="el" href="group___f_f_c_o_n_f_i_g.html#gac271b697378912f17132cb9c7d0de024">_MAX_SS</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a285dc1de6874bb5f0c41c328c9433e14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a> winsect</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>

</div>
</div>
<a name="struct_f_i_l" id="struct_f_i_l"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct FIL</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for FIL:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><img src="struct_f_i_l__coll__graph.png" border="0" usemap="#_f_i_l_coll__map" alt="Collaboration graph"/></div>
<map name="_f_i_l_coll__map" id="_f_i_l_coll__map">
<area shape="rect" id="node2" href="group__filesystem.html#struct_f_a_t_f_s" title="FATFS" alt="" coords="5,5,68,32"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a1602edc1ba9d9ae2b583cf55f3492325"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#a1602edc1ba9d9ae2b583cf55f3492325">buf</a> [<a class="el" href="group___f_f_c_o_n_f_i_g.html#gac271b697378912f17132cb9c7d0de024">_MAX_SS</a>]</td></tr>
<tr class="separator:a1602edc1ba9d9ae2b583cf55f3492325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac134c1b4645be670eb5207032e714616"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#ac134c1b4645be670eb5207032e714616">clust</a></td></tr>
<tr class="separator:ac134c1b4645be670eb5207032e714616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0071755a7d2cacd3bafbb1bf2dab98a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#a0071755a7d2cacd3bafbb1bf2dab98a0">dir_ptr</a></td></tr>
<tr class="separator:a0071755a7d2cacd3bafbb1bf2dab98a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e11faf537370889c867127205f26ad1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#a5e11faf537370889c867127205f26ad1">dir_sect</a></td></tr>
<tr class="separator:a5e11faf537370889c867127205f26ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272171f74215002aba31a89428f1d290"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#a272171f74215002aba31a89428f1d290">dsect</a></td></tr>
<tr class="separator:a272171f74215002aba31a89428f1d290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b2a186af2cab58af8114c05386b9f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#a32b2a186af2cab58af8114c05386b9f6">err</a></td></tr>
<tr class="separator:a32b2a186af2cab58af8114c05386b9f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2c49aaa8df55e1e1d8cb0c5e04a3bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#abb2c49aaa8df55e1e1d8cb0c5e04a3bf">flag</a></td></tr>
<tr class="separator:abb2c49aaa8df55e1e1d8cb0c5e04a3bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f65af32a2d036c560e66177961b9b22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#a0f65af32a2d036c560e66177961b9b22">fptr</a></td></tr>
<tr class="separator:a0f65af32a2d036c560e66177961b9b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae363a794e38f3a9aa1d55b8e3c7fcee7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__filesystem.html#struct_f_a_t_f_s">FATFS</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#ae363a794e38f3a9aa1d55b8e3c7fcee7">fs</a></td></tr>
<tr class="separator:ae363a794e38f3a9aa1d55b8e3c7fcee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70a0afd16367837984d6205cbfca308"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#af70a0afd16367837984d6205cbfca308">fsize</a></td></tr>
<tr class="separator:af70a0afd16367837984d6205cbfca308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7a6396b2c82ad46c6d8b2bf141a8dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#a197942eefa7db30960ae396d68339b97">WORD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#a7b7a6396b2c82ad46c6d8b2bf141a8dd">id</a></td></tr>
<tr class="separator:a7b7a6396b2c82ad46c6d8b2bf141a8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d52f3fde971d2a05ff777a6243c252"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#ad5d52f3fde971d2a05ff777a6243c252">sclust</a></td></tr>
<tr class="separator:ad5d52f3fde971d2a05ff777a6243c252"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Field Documentation</h4>
<a class="anchor" id="a1602edc1ba9d9ae2b583cf55f3492325"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> buf[<a class="el" href="group___f_f_c_o_n_f_i_g.html#gac271b697378912f17132cb9c7d0de024">_MAX_SS</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac134c1b4645be670eb5207032e714616"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a> clust</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0071755a7d2cacd3bafbb1bf2dab98a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>* dir_ptr</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5e11faf537370889c867127205f26ad1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a> dir_sect</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a272171f74215002aba31a89428f1d290"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a> dsect</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a32b2a186af2cab58af8114c05386b9f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> err</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abb2c49aaa8df55e1e1d8cb0c5e04a3bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> flag</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0f65af32a2d036c560e66177961b9b22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a> fptr</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae363a794e38f3a9aa1d55b8e3c7fcee7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__filesystem.html#struct_f_a_t_f_s">FATFS</a>* fs</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af70a0afd16367837984d6205cbfca308"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a> fsize</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7b7a6396b2c82ad46c6d8b2bf141a8dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#a197942eefa7db30960ae396d68339b97">WORD</a> id</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad5d52f3fde971d2a05ff777a6243c252"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a> sclust</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>

</div>
</div>
<a name="struct_f_i_l_i_n_f_o" id="struct_f_i_l_i_n_f_o"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct FILINFO</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a8d28e8b20d001f36bf6099d312384fbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#a8d28e8b20d001f36bf6099d312384fbd">fattrib</a></td></tr>
<tr class="separator:a8d28e8b20d001f36bf6099d312384fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af49edeb97b10af8854cc15a05947a7d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#a197942eefa7db30960ae396d68339b97">WORD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#af49edeb97b10af8854cc15a05947a7d4">fdate</a></td></tr>
<tr class="separator:af49edeb97b10af8854cc15a05947a7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c33845207b44ca3b394052ad6724e72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#a7c33845207b44ca3b394052ad6724e72">fname</a> [13]</td></tr>
<tr class="separator:a7c33845207b44ca3b394052ad6724e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70a0afd16367837984d6205cbfca308"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#af70a0afd16367837984d6205cbfca308">fsize</a></td></tr>
<tr class="separator:af70a0afd16367837984d6205cbfca308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb685b4c58c087d1cd790afb710001cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#a197942eefa7db30960ae396d68339b97">WORD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#adb685b4c58c087d1cd790afb710001cb">ftime</a></td></tr>
<tr class="separator:adb685b4c58c087d1cd790afb710001cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40e23991a0616f2573d7856cdbba9ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#ac40e23991a0616f2573d7856cdbba9ea">lfname</a></td></tr>
<tr class="separator:ac40e23991a0616f2573d7856cdbba9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ec94b667e705d5eb0ec0bc7b5e32ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="integer_8h.html#a36cb3b01d81ffd844bbbfb54003e06ec">UINT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filesystem.html#a28ec94b667e705d5eb0ec0bc7b5e32ec">lfsize</a></td></tr>
<tr class="separator:a28ec94b667e705d5eb0ec0bc7b5e32ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Field Documentation</h4>
<a class="anchor" id="a8d28e8b20d001f36bf6099d312384fbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> fattrib</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af49edeb97b10af8854cc15a05947a7d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#a197942eefa7db30960ae396d68339b97">WORD</a> fdate</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7c33845207b44ca3b394052ad6724e72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> fname[13]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af70a0afd16367837984d6205cbfca308"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a> fsize</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adb685b4c58c087d1cd790afb710001cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#a197942eefa7db30960ae396d68339b97">WORD</a> ftime</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac40e23991a0616f2573d7856cdbba9ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a>* lfname</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a28ec94b667e705d5eb0ec0bc7b5e32ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#a36cb3b01d81ffd844bbbfb54003e06ec">UINT</a> lfsize</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gaacdfef1dad6565f65c26d12fe0ea4b2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__filesystem.html#gaacdfef1dad6565f65c26d12fe0ea4b2b">DRESULT</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gaacdfef1dad6565f65c26d12fe0ea4b2ba2ea4b6ef3fffc17dd1d38ab5c2837737"></a>RES_OK&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gaacdfef1dad6565f65c26d12fe0ea4b2ba78011f5557679ec178fb40bd21e89840"></a>RES_ERROR&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gaacdfef1dad6565f65c26d12fe0ea4b2ba442a6d4393dc404827067bc4e981b322"></a>RES_WRPRT&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gaacdfef1dad6565f65c26d12fe0ea4b2baad64c27c69eb1ff39ae67c5f77bb2b1d"></a>RES_NOTRDY&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gaacdfef1dad6565f65c26d12fe0ea4b2baf4dcc07fd46310b5495fa8025c89a9f3"></a>RES_PARERR&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga49d0171ecbd362cda5680a0d360db44c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ga49d0171ecbd362cda5680a0d360db44ca62fce5cd9df008f8fc85f99706bda5f1"></a>FR_OK&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ga49d0171ecbd362cda5680a0d360db44ca97dee4a6b485dc8f91f37486092dfe34"></a>FR_DISK_ERR&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ga49d0171ecbd362cda5680a0d360db44cab6c9903af6e9bffbb7a288705f4a6a76"></a>FR_INT_ERR&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ga49d0171ecbd362cda5680a0d360db44cac9894bed3e8632ede8d2712235fa8e45"></a>FR_NOT_READY&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ga49d0171ecbd362cda5680a0d360db44ca97da8f98fc2e66d8fa7847f9ebb19b8c"></a>FR_NO_FILE&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ga49d0171ecbd362cda5680a0d360db44cae4529c8cc8b59783d6efc9ba4f574532"></a>FR_NO_PATH&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ga49d0171ecbd362cda5680a0d360db44ca83e45a4b579558c57192c0a391b9bb45"></a>FR_INVALID_NAME&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ga49d0171ecbd362cda5680a0d360db44ca897e9f2dd7629a80f48af242d8bc1a3d"></a>FR_DENIED&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ga49d0171ecbd362cda5680a0d360db44ca0d8f024d256df76e84782b95018a2450"></a>FR_EXIST&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ga49d0171ecbd362cda5680a0d360db44ca3dec4eba481cdf5e99d7cd6009e6dcf8"></a>FR_INVALID_OBJECT&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ga49d0171ecbd362cda5680a0d360db44cac3afbb423b1d4497229416812aff383b"></a>FR_WRITE_PROTECTED&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ga49d0171ecbd362cda5680a0d360db44ca487844af77de15f6932a3b41ef3a2d65"></a>FR_INVALID_DRIVE&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ga49d0171ecbd362cda5680a0d360db44cafc56605c68aaffab4a428339a8bd600d"></a>FR_NOT_ENABLED&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ga49d0171ecbd362cda5680a0d360db44ca086154b5fee763f28c49fd0e2c1cb463"></a>FR_NO_FILESYSTEM&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ga49d0171ecbd362cda5680a0d360db44ca4b02760f758f5b1a89f445244fe9fbca"></a>FR_MKFS_ABORTED&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ga49d0171ecbd362cda5680a0d360db44ca3f8ca7e51af8b129d14328de7243c5d4"></a>FR_TIMEOUT&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ga49d0171ecbd362cda5680a0d360db44ca7db5afaaa2af591bd4a208b2967075d7"></a>FR_LOCKED&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ga49d0171ecbd362cda5680a0d360db44caf56a76a86602cbdeb2c4f3d00cfad21c"></a>FR_NOT_ENOUGH_CORE&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ga49d0171ecbd362cda5680a0d360db44ca50dd3c3c274ccebb2cfbddde9d065bb9"></a>FR_TOO_MANY_OPEN_FILES&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ga49d0171ecbd362cda5680a0d360db44ca3b89faeceab64db277d0fcdeaaa315d6"></a>FR_INVALID_PARAMETER&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga09cdaa6f36fa409bdf002727bff98eb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="diskio_8h.html#adba6790898ce4029c20a34b898ce73c1">DSTATUS</a> disk_initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>&#160;</td>
          <td class="paramname"><em>pdrv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function initializes the storage device and put it ready to generic read/write. When the function succeeded, STA_NOINIT flag in the return value is cleared. <br />
 <b>Application program MUST NOT call this function, or FAT structure on the volume can be broken. To re-initialize the file system, use <a class="el" href="group__filesystem.html#ga16a934c2bbfa2160295810adc49d5509" title="The f_mount fucntion registers/unregisters file system object to the FatFs module. ">f_mount()</a> function instead.</b> This function is called at volume mount process by FatFs module to manage the media change. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pdrv</td><td>Physical drive number to identify the target device. Always zero at single drive system. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">This</td><td>function returns the current drive status flags as the result. For details of the drive status, refer to the <a class="el" href="group__filesystem.html#ga8348ac5ee6d709420c02e45c111f4793" title="The disk_status function returns the current drive status. ">disk_status()</a> function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab00fa450a811dbdabe3c655c1a36fab4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__filesystem.html#gaacdfef1dad6565f65c26d12fe0ea4b2b">DRESULT</a> disk_ioctl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>&#160;</td>
          <td class="paramname"><em>pdrv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The FatFs module requires only five device independent commands described below. <br />
 <br />
</p><center> <b> Standard ioctl command used by FatFs: </b> </center> <table class="doxtable">
<tr>
<th>Command </th><th>Description  </th></tr>
<tr>
<td>CTRL_SYNC </td><td>Make sure that the device has finished pending write process. If the disk I/O module has a write back cache, the dirty buffers must be written back to the media immediately. Nothing to do for this command if each write operation to the media is completed within the <a class="el" href="group__filesystem.html#gac03220b2c8a090b4f76eb2c9407b84fb" title="The disk_write writes sector(s) to the storage device. ">disk_write()</a> function. </td></tr>
<tr>
<td>GET_SECTOR_COUNT </td><td>Returns number of available sectors on the drive into the DWORD variable pointed by buff. This command is used by only <a class="el" href="group__filesystem.html#ga799aff9594e708c8be357281cf85428b" title="The f_mkfs fucntion creates an FAT file system on the logical drive. ">f_mkfs()</a> and <a class="el" href="group__filesystem.html#ga0c1bd3e3872abbda0e256e7c73da9f3b" title="The f_fdisk fucntion divides a physical drive. ">f_fdisk()</a> function to determine the volume/partition size to be created. Required at _USE_MKFS == 1 or _MULTI_PARTITION == 1. </td></tr>
<tr>
<td>GET_SECTOR_SIZE </td><td>Returns sector size of the media into the WORD variable pointed by buff. Valid return values of this command are 512, 1024, 2048 and 4096. This command is required only at variable sector size configuration, _MAX_SS &gt; _MIN_SS. At fixed sector size configuration, _MAX_SS == _MIN_SS, this command is not used and the device must work at that sector size. </td></tr>
<tr>
<td>GET_BLOCK_SIZE </td><td>Returns erase block size of the flash memory media in unit of sector into the DWORD variable pointed by buff. The allowable value is from 1 to 32768 in power of 2. Return 1 if the erase block size is unknown or non flash memory media. This command is used by only <a class="el" href="group__filesystem.html#ga799aff9594e708c8be357281cf85428b" title="The f_mkfs fucntion creates an FAT file system on the logical drive. ">f_mkfs()</a> function and it attempts to align data area to the erase block boundary. Required at _USE_MKFS == 1. </td></tr>
<tr>
<td>CTRL_TRIM </td><td>Informs the device the data on the block of sectors that specified by DWORD array {&lt;start sector&gt;=""&gt;, &lt;end sector&gt;=""&gt;} pointed by buff is no longer needed and it may be erased. This is an identical command to Trim of ATA device. When this feature is not supported or not a flash memory device, nothing to do for this command. The FatFs does not check the result code and the file function is not affected even if the sector block was not erased well. This command is called on removing a cluster chain and <a class="el" href="group__filesystem.html#ga799aff9594e708c8be357281cf85428b" title="The f_mkfs fucntion creates an FAT file system on the logical drive. ">f_mkfs()</a> function. Required at _USE_TRIM == 1. </td></tr>
</table>
<p>FatFs never uses any device dependent command nor user defined command. Following table shows an example of non-standard commands usable for some applications. </p><center> <b> Example of optional ioctl command </b> </center><table class="doxtable">
<tr>
<th>Command </th><th>Description  </th></tr>
<tr>
<td>CTRL_FORMAT </td><td>Create a physical format on the media. If buff is not null, it is pointer to the call-back function for progress notification. </td></tr>
<tr>
<td>CTRL_POWER_IDLE </td><td>Put the device idle state. STA_NOINIT in status flag may not be set if the device goes active state by generic read/write function. </td></tr>
<tr>
<td>CTRL_POWER_OFF </td><td>Put the device off state. Shut-down the power to the device and deinitialize the device interface if needed. STA_NOINIT in status flag must be set. The device goes active state by <a class="el" href="group__filesystem.html#ga09cdaa6f36fa409bdf002727bff98eb1" title="The disk_initialize function initializes the storage device. ">disk_initialize()</a> function. </td></tr>
<tr>
<td>CTRL_LOCK </td><td>Lock media eject mechanism. </td></tr>
<tr>
<td>CTRL_UNLOCK </td><td>Unlock media eject mechanism. </td></tr>
<tr>
<td>MMC_GET_CSD </td><td>Eject media cartridge. STA_NOINIT and STA_NODISK in status flag are set after the function succeeded. </td></tr>
<tr>
<td>MMC_GET_CID </td><td>Get card type. The type flags, bit0:MMCv3, bit1:SDv1, bit2:SDv2+ and bit3:LBA, is stored to a BYTE variable pointed by buff. (MMC/SDC specific command) </td></tr>
<tr>
<td>MMC_GET_OCR </td><td>Get OCR register into a 4-byte buffer pointed by buff. (MMC/SDC specific command) </td></tr>
<tr>
<td>MMC_GET_SDSTAT </td><td>Get SDSTATUS register into a 64-byte buffer pointed by buff. (SDC specific command) </td></tr>
<tr>
<td>ATA_GET_REV </td><td>Get the revision string into a 16-byte buffer pointed by buff. (ATA/CFC specific command) </td></tr>
<tr>
<td>ATA_GET_MODEL </td><td>Get the model string into a 40-byte buffer pointed by buff. (ATA/CFC specific command) </td></tr>
<tr>
<td>ATA_GET_SN </td><td>Get the serial number string into a 20-byte buffer pointed by buff. (ATA/CFC specific command) </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pdrv</td><td>Physical drive number to identify the target device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>Command code. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buff</td><td>Pointer to the parameter depends on the command code. Do not care if no parameter to be passed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">RES_OK(0)</td><td><br />
 The function succeeded. </td></tr>
    <tr><td class="paramname">RES_ERROR</td><td><br />
 An error occured. </td></tr>
    <tr><td class="paramname">RES_PARERR</td><td><br />
 The command code or parameter is invalid. </td></tr>
    <tr><td class="paramname">RES_NOTRDY</td><td><br />
 The device has not been initialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The disk_ioctl function is not needed when _FS_READONLY == 1 and _MAX_SS == _MIN_SS. </dd></dl>

</div>
</div>
<a class="anchor" id="ga075d27f59f550e2cee07d00abcff32e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__filesystem.html#gaacdfef1dad6565f65c26d12fe0ea4b2b">DRESULT</a> disk_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>&#160;</td>
          <td class="paramname"><em>pdrv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a>&#160;</td>
          <td class="paramname"><em>sector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="integer_8h.html#a36cb3b01d81ffd844bbbfb54003e06ec">UINT</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The data read/write operation to the storage devices is done in unit of sector. FatFs supports the sector size in range of from 512 to 4096 bytes. When FatFs is configured to fixed sector size (_MIN_SS == MAX_SS, this will be the most case), the read/write function must work at that sector size. If variable sector size is selected (_MIN_SS &lt; MAX_SS), FatFs inquires the sector size with <a class="el" href="group__filesystem.html#gab00fa450a811dbdabe3c655c1a36fab4" title="The disk_ioctl function cntrols device specific features and miscellaneous functions other than gener...">disk_ioctl()</a> after initialization. <br />
 The memory address specified by buff is not that always aligned to word boundary because the argument is defined as BYTE*. The misaligned read/write request can occure at direct transfer. If the bus architecture, especially DMA controller, does not allow misaligned memory access, it should be solved in this function. There are some workarounds described below to avoid this issue. <br />
</p><ul>
<li>Convert word transfer to byte transfer in this function if needed. - Recommended.</li>
<li>For <a class="el" href="group__filesystem.html#gac4c3dcb6869ca252888eebabe39727b3" title="The f_read function reads data from a file. ">f_read()</a>, avoid long read request that includes a whole of sector. - Direct transfer will never occure.</li>
<li>For f_read(fp, buff, btr, &amp;br), make sure that (((UINT)buff &amp; 3) == (<a class="el" href="ff_8h.html#a5e1daca7ce13cdc277e42185f7f9124f">f_tell(fp)</a> &amp; 3)) is true. - Word aligned direct transfer is guaranteed. <br />
 Generally, a multiple sector transfer request must not be split into single sector transactions to the storage device, or you will not get good read throughput. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pdrv</td><td>Physical drive number to identify the target device. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buff</td><td>Pointer to the byte array to store the read data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sector</td><td>Start sector number in 32-bit LBA. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of sectors to read in range of from 1 to 128.. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">RES_OK</td><td>(0) <br />
 The function succeeded. <br />
</td></tr>
    <tr><td class="paramname">RES_ERROR</td><td><br />
 Any hard error occured during the read operation and could not recover it. <br />
</td></tr>
    <tr><td class="paramname">RES_PARERR</td><td><br />
 Invalid parameter. <br />
</td></tr>
    <tr><td class="paramname">RES_NOTRDY</td><td><br />
 The device has not been initialized. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ga8348ac5ee6d709420c02e45c111f4793"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="diskio_8h.html#adba6790898ce4029c20a34b898ce73c1">DSTATUS</a> disk_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>&#160;</td>
          <td class="paramname"><em>pdrv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pdrv</td><td>Physical drive number to identify the target device. Always zero at single drive system. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>current drive status is returned in combination of status flags described below. FatFs refers only STA_NOINIT and STA_PROTECT. <br />
</td></tr>
    <tr><td class="paramname">STA_NOINIT</td><td><br />
 Indicates that the device is not initialized. This flag is set on system reset, media removal or failure of <a class="el" href="group__filesystem.html#ga09cdaa6f36fa409bdf002727bff98eb1" title="The disk_initialize function initializes the storage device. ">disk_initialize()</a> function. It is cleared on <a class="el" href="group__filesystem.html#ga09cdaa6f36fa409bdf002727bff98eb1" title="The disk_initialize function initializes the storage device. ">disk_initialize()</a> function succeeded. Media change that occurs asynchronously must be captured and reflect it to the status flags, or auto-mount feature will not work correctly. If the system does not support media change detect feature, application program needs to force de-initialize the file system object with <a class="el" href="group__filesystem.html#ga16a934c2bbfa2160295810adc49d5509" title="The f_mount fucntion registers/unregisters file system object to the FatFs module. ">f_mount()</a> function after the media change. <br />
</td></tr>
    <tr><td class="paramname">STA_NODISK</td><td><br />
 Indicates that no medium in the drive. This is always cleared on fixed disk drive. Note that FatFs does not refer this flag. </td></tr>
    <tr><td class="paramname">STA_PROTECT</td><td><br />
 Indicates that the medium is write protected. This is always cleared on the drives without write protect feature. Not valid if no medium in the drive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac03220b2c8a090b4f76eb2c9407b84fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__filesystem.html#gaacdfef1dad6565f65c26d12fe0ea4b2b">DRESULT</a> disk_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>&#160;</td>
          <td class="paramname"><em>drv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a>&#160;</td>
          <td class="paramname"><em>sector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="integer_8h.html#a36cb3b01d81ffd844bbbfb54003e06ec">UINT</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The specified memory address is not that always aligned to word boundary because the type of pointer is defined as BYTE*. For more information, refer to the description of <a class="el" href="group__filesystem.html#ga075d27f59f550e2cee07d00abcff32e0" title="The disk_read function reads sector(s) from the storage device. ">disk_read()</a> function. <br />
 Generally, a multiple sector transfer request must not be split into single sector transactions to the storage device, or you will never get good write throughput. <br />
 FatFs expects delayed write feature of the disk functions. The write operation to the media need not to be completed due to write operation is in progress or only stored it into the cache buffer when return from this function. But data on the buff is invalid after return from this function. The write completion request is done by CTRL_SYNC command of <a class="el" href="group__filesystem.html#gab00fa450a811dbdabe3c655c1a36fab4" title="The disk_ioctl function cntrols device specific features and miscellaneous functions other than gener...">disk_ioctl()</a> function. Therefore, if delayed write feature is implemented, the write throughput may be improved. <br />
 Application program MUST NOT call this function, or FAT structure on the volume can be collapsed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pdrv</td><td>Physical drive number to identify the target device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buff</td><td>Pointer to the byte array to be written. The size of data to be written is sector size * count bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sector</td><td>Start sector number in 32-bit LBA. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of sectors to write in range of from 1 to 128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">RES_OK(0)</td><td><br />
 The function succeeded. </td></tr>
    <tr><td class="paramname">RES_ERROR</td><td><br />
 Any hard error occured during the write operation and could not recover it. </td></tr>
    <tr><td class="paramname">RES_WRPRT</td><td><br />
 The medium is write protected. </td></tr>
    <tr><td class="paramname">RES_PARERR</td><td><br />
 Invalid parameter. </td></tr>
    <tr><td class="paramname">RES_NOTRDY</td><td><br />
 The device has not been initialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is not needed when _FS_READONLY == 1. </dd></dl>

</div>
</div>
<a class="anchor" id="ga53c7e9a7fb3c279254cd2d0445667e2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a> f_chdir </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__filesystem.html#ga53c7e9a7fb3c279254cd2d0445667e2f" title="The f_chdir function changes the current directory of a drive. ">f_chdir()</a> function changes the current directory of the logical drive. The current directory of a drive is initialized to the root directory when the drive is auto-mounted. Note that the current directory is retained in the each file system object so that it also affects other tasks that using the volume. <br />
 Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;/* Change current direcoty of the current drive (dir1 under root dir) */</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;f_chdir(&quot;/dir1&quot;);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;/* Change current direcoty of drive 2 (parent dir) */</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;f_chdir(&quot;2:..&quot;);</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Pointer to the null-terminated string that specifies a directory to go. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FR_OK</td><td></td></tr>
    <tr><td class="paramname">FR_DISK_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_INT_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_READY</td><td></td></tr>
    <tr><td class="paramname">FR_NO_PATH</td><td></td></tr>
    <tr><td class="paramname">FR_INVALID_NAME</td><td></td></tr>
    <tr><td class="paramname">FR_INVALID_DRIVE</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_ENABLED</td><td></td></tr>
    <tr><td class="paramname">FR_NO_FILESYSTEM</td><td></td></tr>
    <tr><td class="paramname">FR_TIMEOUT</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_ENOUGH_CORE</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Available when _FS_RPATH &gt;= 1. </dd></dl>

</div>
</div>
<a class="anchor" id="ga13e5933f851b436890361189f64261cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a> f_chdrive </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__filesystem.html#ga13e5933f851b436890361189f64261cd" title="The f_chdrive function changes the current drive. ">f_chdrive()</a> function changes the current drive. The initial value of the current drive number is 0. Note that the current drive is retained in a static variable so that it also affects other tasks that using the file functions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Specifies the logical drive number to be set as the current drive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FR_OK</td><td></td></tr>
    <tr><td class="paramname">FR_INVALID_DRIVE</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Available when _FS_RPATH &gt;= 1 and _VOLUMES &gt;= 2. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9ee7e560eec8d82755c636ae41e702cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a> f_chmod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__filesystem.html#ga9ee7e560eec8d82755c636ae41e702cd" title="The f_chmod function changes the attribute of a file or sub-directory. ">f_chmod()</a> function changes the attribute of a file or sub-directory. <br />
 Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;/* Set read-only flag, clear archive flag and others are left unchanged. */</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;f_chmod(&quot;file.txt&quot;, AR_RDO, AR_RDO | AR_ARC);</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Pointer to the null-terminated string that specifies an object to be changed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attr</td><td>Attribute flags to be set in one or more combination of the following flags. The specified flags are set and others are cleard. <table class="doxtable">
<tr>
<th>Attribute </th><th>Description  </th></tr>
<tr>
<td>AM_RDO </td><td>Read only </td></tr>
<tr>
<td>AM_ARC </td><td>Archive </td></tr>
<tr>
<td>AM_SYS </td><td>System </td></tr>
<tr>
<td>AM_HID </td><td>Hidden </td></tr>
</table>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>Attribute mask that specifies which attribute is changed. The specified attributes are set or cleard and others are left unchanged. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FR_OK</td><td></td></tr>
    <tr><td class="paramname">FR_DISK_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_INT_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_READY</td><td></td></tr>
    <tr><td class="paramname">FR_NO_FILE</td><td></td></tr>
    <tr><td class="paramname">FR_NO_PATH</td><td></td></tr>
    <tr><td class="paramname">FR_INVALID_NAME</td><td></td></tr>
    <tr><td class="paramname">FR_WRITE_PROTECTED</td><td></td></tr>
    <tr><td class="paramname">FR_INVALID_DRIVE</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_ENABLED</td><td></td></tr>
    <tr><td class="paramname">FR_NO_FILESYSTEM</td><td></td></tr>
    <tr><td class="paramname">FR_TIMEOUT</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_ENOUGH_CORE</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Available when _FS_READONLY == 0 and _FS_MINIMIZE == 0. </dd></dl>

</div>
</div>
<a class="anchor" id="ga53882db20ef4323dcfd1874d7733ffc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a> f_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__filesystem.html#struct_f_i_l">FIL</a> *&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__filesystem.html#ga53882db20ef4323dcfd1874d7733ffc3" title="The f_close function closes an open file. ">f_close()</a> function closes an open file object. If any data has been written to the file, the cached information of the file is written back to the volume. After the function succeeded, the file object is no longer valid and it can be discarded. <br />
 Note that if the file object is in read-only mode and _FS_LOCK option is not enabled, the file object can also be discarded without this process. However this is not recommended for future compatibility.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fp</td><td>Pointer to the open file object structure to be closed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FR_OK</td><td></td></tr>
    <tr><td class="paramname">FR_DISK_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_INT_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_READY</td><td></td></tr>
    <tr><td class="paramname">FR_INVALID_OBJECT</td><td></td></tr>
    <tr><td class="paramname">FR_TIMEOUT</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Always available. </dd></dl>

</div>
</div>
<a class="anchor" id="gab5f7376b6f3e3bcc7f5ff5497c8b7364"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a> f_closedir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__filesystem.html#struct_d_i_r">DIR</a> *&#160;</td>
          <td class="paramname"><em>dp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__filesystem.html#gab5f7376b6f3e3bcc7f5ff5497c8b7364" title="The f_closedir function closes an open directory. ">f_closedir()</a> function closes an open directory object. After the function succeeded, the directory object is no longer valid and it can be discarded. <br />
 Note that the directory object can also be discarded without this process if _FS_LOCK option is not enabled. However this is not recommended for future compatibility. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dp</td><td>Pointer to the open directory object structure to be closed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FR_OK</td><td></td></tr>
    <tr><td class="paramname">FR_INT_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_INVALID_OBJECT</td><td></td></tr>
    <tr><td class="paramname">FR_TIMEOUT</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Available when _FS_MINIMIZE &lt;= 1. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf0878582b1255b693b29dca3c6ecccf1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int f_eof </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__filesystem.html#struct_f_i_l">FIL</a> *&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In this revision, this function is implemented as a macro. <br />
 #define <a class="el" href="ff_8h.html#a970cdd8970a3a94967ad64cfc5d4c161">f_eof(fp)</a> ((int)((fp)-&gt;fptr == (fp)-&gt;fsize)) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fp</td><td>Pointer to the open file object structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td><a class="el" href="group__filesystem.html#gaf0878582b1255b693b29dca3c6ecccf1" title="The f_eof function tests for end-of-file on a file. ">f_eof()</a> function returns a non-zero value if the read/write pointer has reached end of the file; otherwise it returns a zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Always available. </dd></dl>

</div>
</div>
<a class="anchor" id="gad3c6dd79ef26a59629a6c8f6afe71fbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int f_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__filesystem.html#struct_f_i_l">FIL</a> *&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In this revision, this function is implemented as a macro. #define <a class="el" href="ff_8h.html#a25cbdabeed318802cf0e9db6671a33b7">f_error(fp)</a> ((fp)-&gt;flag) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fp</td><td>Pointer to the open file object structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Returns</td><td>a non-zero value if a hard error has occured; otherwise it returns a zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Always available. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0c1bd3e3872abbda0e256e7c73da9f3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a> f_fdisk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>&#160;</td>
          <td class="paramname"><em>pdrv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a>&#160;</td>
          <td class="paramname"><em>part</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__filesystem.html#ga0c1bd3e3872abbda0e256e7c73da9f3b" title="The f_fdisk fucntion divides a physical drive. ">f_fdisk()</a> function creates a partition table into the MBR of the physical drive. The partitioning rule is in generic FDISK format, so that it can create upto four primary partitions. Logical volumes in the extended partition is not supported. The part[] with four items specifies how to divide the physical drive. The first item specifies the size of first primary partition and fourth item specifies the fourth primary partition. If the value is less than or equal to 100, it specifies percentage of the partition in the entire disk space. If it is larger than 100, it specifies the partition size in unit of sector. <br />
 Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;/* Volume management table defined by user (required when _MULTI_PARTITION == 1) */</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  PARTITION VolToPart[] = {</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;     {0, 1},    /* Logical drive 0 ==&gt; Physical drive 0, 1st partition */</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;     {0, 2},    /* Logical drive 1 ==&gt; Physical drive 0, 2nd partition */</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;     {1, 0}     /* Logical drive 2 ==&gt; Physical drive 1, auto detection */</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160; };</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;/* Initialize a brand-new disk drive mapped to physical drive 0 */</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  FATFS fs;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  DWORD plist[] = {50, 50, 0, 0};  /* Divide drive into two partitions */</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  BYTE work[_MAX_SS];</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  f_fdisk(0, plist, work);    /* Divide physical drive 0 */</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;  f_mount(&amp;fs, &quot;0:&quot;, 0);      /* Register work area to the logical drive 0 */</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;  f_mkfs(&quot;0:&quot;, 0, 0);         /* Create FAT volume on the logical drive 0. 2nd argument is ignored. */</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;  f_mount(0, &quot;0:&quot;, 0);        /* Unregister work area from the logical drive 0 */</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;  f_mount(&amp;fs, &quot;1:&quot;, 0);      /* Register a work area to the logical drive 1 */</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;  f_mkfs(&quot;1:&quot;, 0, 0);         /* Create FAT volume on the logical drive 1. 2nd argument is ignored. */</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;  f_mount(0, &quot;1:&quot;, 0);        /* Unregister work area from the logical drive 1 */</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pdrv</td><td>Specifies the physical drive to be divided. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">part[]</td><td>Partition map table. It must have four items. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">work</td><td>Pointer to the function work area. The size must be at least _MAX_SS bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FR_OK</td><td></td></tr>
    <tr><td class="paramname">FR_DISK_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_READY</td><td></td></tr>
    <tr><td class="paramname">FR_WRITE_PROTECTED</td><td></td></tr>
    <tr><td class="paramname">FR_INVALID_PARAMETER</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Available when _FS_READOLNY == 0, _USE_MKFS == 1 and _MULTI_PARTITION == 1. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6c0c4cd695704aa6d952c90be81d9849"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a> f_forward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__filesystem.html#struct_f_i_l">FIL</a> *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="integer_8h.html#a36cb3b01d81ffd844bbbfb54003e06ec">UINT</a>(*)(const <a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> *, <a class="el" href="integer_8h.html#a36cb3b01d81ffd844bbbfb54003e06ec">UINT</a>)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="integer_8h.html#a36cb3b01d81ffd844bbbfb54003e06ec">UINT</a>&#160;</td>
          <td class="paramname"><em>btf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="integer_8h.html#a36cb3b01d81ffd844bbbfb54003e06ec">UINT</a> *&#160;</td>
          <td class="paramname"><em>bf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__filesystem.html#ga6c0c4cd695704aa6d952c90be81d9849" title="The f_forward function reads the file data and forward it to the data streaming device. ">f_forward()</a> function reads the data from the file and forward it to the outgoing stream without data buffer. This is suitable for small memory system because it does not require any data buffer at application module. The file pointer of the file object increases in number of bytes forwarded. In case of *bf is less than btf without error, it means the requested bytes could not be transferred due to end of file or stream goes busy during data transfer. <br />
 Examples(Audio playback): </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;/*------------------------------------------------------------------------*/</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;/* Sample code of data transfer function to be called back from f_forward */</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;/*------------------------------------------------------------------------*/</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;UINT out_stream (   /* Returns number of bytes sent or stream status */</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;const BYTE *p,  /* Pointer to the data block to be sent */</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;UINT btf        /* &gt;0: Transfer call (Number of bytes to be sent). 0: Sense call */</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;)</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;{</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;UINT cnt = 0;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160; if (btf == 0) {     /* Sense call */</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;     /* Return stream status (0: Busy, 1: Ready) */</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;     /* When once it returned ready to sense call, it must accept a byte at least */</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;     /* at subsequent transfer call, or f_forward will fail with FR_INT_ERR. */</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;     if (FIFO_READY) cnt = 1;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160; }</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160; else {              /* Transfer call */</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;     do {    /* Repeat while there is any data to be sent and the stream is ready */</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;         FIFO_PORT = *p++;</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;         cnt++;</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;     } while (cnt &lt; btf &amp;&amp; FIFO_READY);</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;  }</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;  return cnt;</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160; }</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;/*------------------------------------------------------------------------*/</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;/* Sample code using f_forward function                                   */</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;/*------------------------------------------------------------------------*/</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;FRESULT play_file (</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;  char *fn        /* Pointer to the audio file name to be played */</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;)</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;{</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;FRESULT rc;</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160; FIL fil;</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160; UINT dmy;</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160; /* Open the audio file in read only mode */</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160; rc = f_open(&amp;fil, fn, FA_READ);</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160; if (rc) return rc;</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160; /* Repeat until the file pointer reaches end of the file */</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160; while (rc == FR_OK &amp;&amp; fil.fptr &lt; fil.fsize) {</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160; /* any other processes... */</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160; /* Fill output stream periodicaly or on-demand */ </div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160; rc = f_forward(&amp;fil, out_stream, 1000, &amp;dmy);</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160; }</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160; /* Close the file and return */</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160; f_close(&amp;fil);</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160; return rc;</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160; }</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fp</td><td>Pointer to the open file object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Pointer to the user-defined data streaming function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">btf</td><td>Number of bytes to forward in range of UINT. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bf</td><td>Pointer to the UINT variable to return number of bytes forwarded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FR_OK</td><td></td></tr>
    <tr><td class="paramname">FR_DISK_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_INT_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_READY</td><td></td></tr>
    <tr><td class="paramname">FR_INVALID_OBJECT</td><td></td></tr>
    <tr><td class="paramname">FR_TIMEOUT</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Available when _USE_FORWARD == 1 and _FS_TINY == 1. </dd></dl>

</div>
</div>
<a class="anchor" id="gacb865a03dbac0031ac5cb8a031f7b71c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a> f_getcwd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="integer_8h.html#a36cb3b01d81ffd844bbbfb54003e06ec">UINT</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__filesystem.html#gacb865a03dbac0031ac5cb8a031f7b71c" title="The f_getcwd function retrieves the current directory. ">f_getcwd()</a> function retrieves full path name of the current directory of the current drive. When _VOLUMES is larger than 1, a logical drive number is added to top of the path name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buff</td><td>Pointer to the buffer to receive the current directory string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Size of the buffer in unit of TCHAR. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FR_OK</td><td></td></tr>
    <tr><td class="paramname">FR_DISK_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_INT_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_READY</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_ENABLED</td><td></td></tr>
    <tr><td class="paramname">FR_NO_FILESYSTEM</td><td></td></tr>
    <tr><td class="paramname">FR_TIMEOUT</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_ENOUGH_CORE</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Available when _FS_RPATH == 2. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0ff39f75a87cbda9cd6ea65d83f16cec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a> f_getfree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a> *&#160;</td>
          <td class="paramname"><em>nclst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__filesystem.html#struct_f_a_t_f_s">FATFS</a> **&#160;</td>
          <td class="paramname"><em>fatfs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__filesystem.html#ga0ff39f75a87cbda9cd6ea65d83f16cec" title="The f_getfree function gets number of the free clusters on the volume. ">f_getfree()</a> function gets number of free clusters on the volume. The member csize in the file system object indicates number of sectors per cluster, so that the free space in unit of sector can be calcurated with this information. When FSINFO structure on the FAT32 volume is not in sync, this function can return an incorrect free cluster count. To avoid this problem, FatFs can be forced full FAT scan by _FS_NOFSINFO option. <br />
 Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;   FATFS *fs;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;DWORD fre_clust, fre_sect, tot_sect;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160; /* Get volume information and free clusters of drive 1 */</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160; res = f_getfree(&quot;1:&quot;, &amp;fre_clust, &amp;fs);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160; if (res) die(res);</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160; /* Get total sectors and free sectors */</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160; tot_sect = (fs-&gt;n_fatent - 2) * fs-&gt;csize;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160; fre_sect = fre_clust * fs-&gt;csize;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160; /* Print the free space (assuming 512 bytes/sector) */</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160; printf(&quot;%10lu KiB total drive space.\n%10lu KiB available.\n&quot;,</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;        tot_sect / 2, fre_sect / 2);</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Pointer to the null-terminated string that specifies the logical drive. A null-string means the default drive. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nclst</td><td>Pointer to the DWORD variable to store number of free clusters. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fatfs</td><td>Pointer to pointer that to store a pointer to the corresponding file system object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FR_OK</td><td></td></tr>
    <tr><td class="paramname">FR_DISK_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_INT_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_READY</td><td></td></tr>
    <tr><td class="paramname">FR_INVALID_DRIVE</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_ENABLED</td><td></td></tr>
    <tr><td class="paramname">FR_NO_FILESYSTEM</td><td></td></tr>
    <tr><td class="paramname">FR_TIMEOUT</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Available when _FS_READONLY == 0 and _FS_MINIMIZE == 0. </dd></dl>

</div>
</div>
<a class="anchor" id="gac4ff40a674bcbfe40d81b1e8e54befc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a> f_getlabel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a> *&#160;</td>
          <td class="paramname"><em>vsn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;char str[12];</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;/* Get volume label of the default drive */</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;f_getlabel(&quot;&quot;, str, 0);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;/* Get volume label of the drive 2 */</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;f_getlabel(&quot;2:&quot;, str, 0);</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Pointer to the null-terminated string that specifies the logical drive. Null-string specifies the default drive. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">label</td><td>Pointer to the buffer to store the volume label. The buffer size must be at least 12 items. If the volume has no label, a null-string will be returned. Set null pointer if this information is not needed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vsn</td><td>Pointer to the DWORD variable to store the volume serial number. Set null pointer if this information is not needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FR_OK</td><td></td></tr>
    <tr><td class="paramname">FR_DISK_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_INT_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_READY</td><td></td></tr>
    <tr><td class="paramname">FR_INVALID_DRIVE</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_ENABLED</td><td></td></tr>
    <tr><td class="paramname">FR_NO_FILESYSTEM</td><td></td></tr>
    <tr><td class="paramname">FR_TIMEOUT</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Available when _USE_LABEL == 1. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0fa54bd310785ecdaed19dda8f60dac5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a>* f_gets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__filesystem.html#struct_f_i_l">FIL</a> *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__filesystem.html#ga0fa54bd310785ecdaed19dda8f60dac5" title="The f_gets reads a string from the file. ">f_gets()</a> function is a wrapper function of <a class="el" href="group__filesystem.html#gac4c3dcb6869ca252888eebabe39727b3" title="The f_read function reads data from a file. ">f_read()</a> function. The read operation continues until a '<br />
' is stored, reached end of the file or the buffer is filled with len - 1 characters. The read string is terminated with a '\0'. When no character to read or any error occured during read operation, it returns a null pointer. The status of EOF and error can be examined with <a class="el" href="group__filesystem.html#gaf0878582b1255b693b29dca3c6ecccf1" title="The f_eof function tests for end-of-file on a file. ">f_eof()</a> and <a class="el" href="group__filesystem.html#gad3c6dd79ef26a59629a6c8f6afe71fbf" title="The f_error tests for an error on a file. ">f_error()</a> macros. <br />
 When FatFs is configured to Unicode API (_LFN_UNICODE == 1), data types on the srting fuctions, <a class="el" href="group__filesystem.html#ga62a35ee79e4913c1e31ac706241be7da" title="The f_putc funciton puts a character to the file. ">f_putc()</a>, <a class="el" href="group__filesystem.html#ga9443c00129414fbfc16a5a13ad876ced" title="The f_puts function writes a string to the file. ">f_puts()</a>, <a class="el" href="group__filesystem.html#ga49cccab38cd84e2d3357fef2d1df21f9" title="The f_printf function writes formatted string to the file. ">f_printf()</a> and <a class="el" href="group__filesystem.html#ga0fa54bd310785ecdaed19dda8f60dac5" title="The f_gets reads a string from the file. ">f_gets()</a>, is also switched to Unicode. The character encoding on the file to be read/written via those functions is selected by _STRF_ENCODE option. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buff</td><td>Pointer to read buffer to store the read string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Size of the read buffer in unit of character. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fp</td><td>Pointer to the open file object structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">When</td><td>the function succeeded, buff will be returuned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Available when _USE_STRFUNC is 1 or 2. When it is set to 2, ''s contained in the file are stripped out. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5df0ac672ada972e89ef4b003e57f964"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a> f_lseek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__filesystem.html#struct_f_i_l">FIL</a> *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a>&#160;</td>
          <td class="paramname"><em>ofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__filesystem.html#ga5df0ac672ada972e89ef4b003e57f964" title="The f_lseek function moves the file read/write pointer of an open file object. It can also be used to...">f_lseek()</a> function moves the file read/write pointer of an open file. The offset can be specified in only origin from top of the file. When an offset beyond the file size is specified at write mode, the file size is expanded to the specified offset. The file data in the expanded area is undefined because no data is written to the file. This is suitable to pre-allocate a cluster chain quickly, for fast write operation. After the <a class="el" href="group__filesystem.html#ga5df0ac672ada972e89ef4b003e57f964" title="The f_lseek function moves the file read/write pointer of an open file object. It can also be used to...">f_lseek()</a> function succeeded, the current read/write pointer should be checked in order to make sure the read/write pointer has been moved correctry. In case of the current read/write pointer is not the expected value, either of followings has been occured. <br />
 </p><ul>
<li><code>End</code> of file. The specified ofs was clipped at end of the file because the file has been opened in read-only mode. </li>
<li><code>Disk</code> full. There is insufficient free space on the volume to expand the file. <br />
 Fast seek feature is enabled when _USE_FASTSEEK is set to 1 and the member cltbl in the file object is not NULL. This feature enables fast backward/long seek operations without FAT access by using CLMT (cluster link map table). The fast seek feature is also applied to <a class="el" href="group__filesystem.html#gac4c3dcb6869ca252888eebabe39727b3" title="The f_read function reads data from a file. ">f_read()</a>/f_write() function, however, the file size cannot be expanded by <a class="el" href="group__filesystem.html#gae6a4dfae8a9e308bdb2283a37ef680f2" title="The f_write writes data to a file. ">f_write()</a>/f_lseek() function. <br />
 The CLMT must be created in the user defined DWORD array prior to use the fast seek feature. To create the CLMT, set address of the DWORD array to the member cltbl in the file object, set the array size in unit of items into the first item and call the <a class="el" href="group__filesystem.html#ga5df0ac672ada972e89ef4b003e57f964" title="The f_lseek function moves the file read/write pointer of an open file object. It can also be used to...">f_lseek()</a> function with ofs = CREATE_LINKMAP. After the function succeeded and CLMT is created, no FAT access is occured at subsequent <a class="el" href="group__filesystem.html#gac4c3dcb6869ca252888eebabe39727b3" title="The f_read function reads data from a file. ">f_read()</a>/f_write()/f_lseek() function to the file. If the function failed with FR_NOT_ENOUGH_CORE, the given array size is insufficient for the file and number of items required is returned into the first item of the array. The required array size is (number of fragments + 1) * 2 items. For example, when the file is fragmented in 5, 12 items will be required for the CLMT. <br />
 Examples: <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;   /* Open file */</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;   fp = malloc(sizeof (FIL));</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;   res = f_open(fp, &quot;file.dat&quot;, FA_READ|FA_WRITE);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;   if (res) ...</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;      /* Move to offset of 5000 from top of the file */</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;   res = f_lseek(fp, 5000);</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;   /* Move to end of the file to append data */</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;   res = f_lseek(fp, f_size(fp));</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;   /* Forward 3000 bytes */</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;   res = f_lseek(fp, f_tell(fp) + 3000);</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;   /* Rewind 2000 bytes (take care on wraparound) */</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;   res = f_lseek(fp, f_tell(fp) - 2000);</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;   /* Cluster pre-allocation (to prevent buffer overrun on streaming write) */</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;   res = f_open(fp, recfile, FA_CREATE_NEW | FA_WRITE);   /* Create a file */</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;   res = f_lseek(fp, PRE_SIZE);             /* Expand file size (cluster pre-allocation) */</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;   if (res || f_tell(fp) != PRE_SIZE) ...   /* Check if the file has been expanded */</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;   res = f_lseek(fp, DATA_START);           /* Record data stream WITHOUT cluster allocation delay */</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;   ...                                      /* DATA_START and write block size should be aligned to sector boundary */</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;   res = f_truncate(fp);                    /* Truncate unused area */</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;   res = f_lseek(fp, 0);                    /* Put file header */</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;   ...</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;   res = f_close(fp);</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;/* Using fast seek feature */</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;   DWORD clmt[SZ_TBL];                    /* Cluster link map table buffer */</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;   res = f_lseek(fp, ofs1);               /* This is normal seek (cltbl is nulled on file open) */</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;   fp-&gt;cltbl = clmt;                      /* Enable fast seek feature (cltbl != NULL) */</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;   clmt[0] = SZ_TBL;                      /* Set table size */</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;   res = f_lseek(fp, CREATE_LINKMAP);     /* Create CLMT */</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;   ...</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;   res = f_lseek(fp, ofs2);               /* This is fast seek */</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fp</td><td>Pointer to the open file object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ofs</td><td>Byte offset from top of the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FR_OK</td><td></td></tr>
    <tr><td class="paramname">FR_DISK_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_INT_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_READY</td><td></td></tr>
    <tr><td class="paramname">FR_INVALID_OBJECT</td><td></td></tr>
    <tr><td class="paramname">FR_TIMEOUT</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Available when _FS_MINIMIZE &lt;= 2. </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ga4b4d38db58e89c526cfcf53200d719d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a> f_mkdir </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function creates a new directory. <br />
 Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;res = f_mkdir(&quot;sub1&quot;);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;if (res) die(res);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;res = f_mkdir(&quot;sub1/sub2&quot;);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;if (res) die(res);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;res = f_mkdir(&quot;sub1/sub2/sub3&quot;);</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;if (res) die(res);</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Pointer to the null-terminated string that specifies the directory name to create. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FR_OK</td><td></td></tr>
    <tr><td class="paramname">FR_DISK_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_INT_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_READY</td><td></td></tr>
    <tr><td class="paramname">FR_NO_PATH</td><td></td></tr>
    <tr><td class="paramname">FR_INVALID_NAME</td><td></td></tr>
    <tr><td class="paramname">FR_DENIED</td><td></td></tr>
    <tr><td class="paramname">FR_EXIST</td><td></td></tr>
    <tr><td class="paramname">FR_WRITE_PROTECTED</td><td></td></tr>
    <tr><td class="paramname">FR_INVALID_DRIVE</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_ENABLED</td><td></td></tr>
    <tr><td class="paramname">FR_NO_FILESYSTEM</td><td></td></tr>
    <tr><td class="paramname">FR_TIMEOUT</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_ENOUGH_CORE</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Available when _FS_READONLY == 0 and _FS_MINIMIZE == 0. </dd></dl>

</div>
</div>
<a class="anchor" id="ga799aff9594e708c8be357281cf85428b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a> f_mkfs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>&#160;</td>
          <td class="paramname"><em>sfd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="integer_8h.html#a36cb3b01d81ffd844bbbfb54003e06ec">UINT</a>&#160;</td>
          <td class="paramname"><em>au</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__filesystem.html#ga799aff9594e708c8be357281cf85428b" title="The f_mkfs fucntion creates an FAT file system on the logical drive. ">f_mkfs()</a> function creates an FAT volume on the specified logical drive. When FDISK format is specified, a primary partition occupies entire space of the physical drive is created and then an FAT volume is created on the partition. When SFD format is specified, the FAT volume starts from the first sector of the physical drive. <br />
 If the logical drive is bound to the specific partition (1-4) by multiple partition feature (_MULTI_PARTITION), the FAT volume is created into the partition. In this case, the second argument sfd is ignored. The physical drive must have been partitioned with <a class="el" href="group__filesystem.html#ga0c1bd3e3872abbda0e256e7c73da9f3b" title="The f_fdisk fucntion divides a physical drive. ">f_fdisk()</a> function or any other partitioning tools prior to create the FAT volume with this function. <br />
 Note that there are two partitioning rules, FDISK and SFD. The FDISK partitioning is usually used for harddisk, MMC, SDC, CFC and U Disk. It can divide a physical drive into one or more partitions with a partition table on the MBR. However Windows does not support multiple partition on the removable disk. The SFD is non-partitioned method. The FAT volume starts from the first sector on the physical drive without partition table. It is usually used for floppy disk, Microdrive, optical disk and any type of super-floppy media. <br />
 The FAT sub-type, FAT12/FAT16/FAT32, is determined by number of clusters on the volume and nothing else, according to the FAT specification issued by Microsoft. Thus which FAT sub-type is selected, is depends on the volume size and the specified cluster size. The cluster size affects read/write throughput and space usage efficiency. Larger cluster size increases the read/write throughput and decreases the space usage efficiency of the volume. <br />
 In case of the number of clusters gets near the FAT sub-type boundaries, the function can fail with FR_MKFS_ABORTED. <br />
 Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;/* Format the default drive */</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;int main (void)</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;{</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160; FATFS fs;      /* File system object (volume work area) */</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160; FIL fil;       /* File object */</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160; FRESULT res;   /* API result code */</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160; UINT bw;       /* Bytes written */</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160; /* Register work area */</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160; f_mount(&amp;fs, &quot;&quot;, 0);</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160; /* Create FAT volume with default cluster size */</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160; res = f_mkfs(&quot;&quot;, 0, 0);</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160; if (res) ...</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160; /* Create a file as new */</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160; res = f_open(&amp;fil, &quot;hello.txt&quot;, FA_CREATE_NEW | FA_WRITE);</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160; if (res) ...</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160; /* Write a message */</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160; f_write(&amp;fil, &quot;Hello, World!\r\n&quot;, 15, &amp;bw);</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160; if (bw != 15) ...</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160; /* Close the file */</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160; f_close(&amp;fil);</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160; /* Unregister work area */</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160; f_mount(0, &quot;&quot;, 0);</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Pointer to the null-terminated string that specifies the logical drive to be formatted. If there is no drive number, it means the default drive. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sfd</td><td>Specifies partitioning rule (FDISK(0) or SFD(1)). This argument will be ignored on some case. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">au</td><td>Specifies size of the allocation unit (cluter) in number of bytes or sectors. When the value is from 1 to 128, it specifies number of sectors. When the value is &gt;= _MIN_SS, it specifies number of bytes. If any invalid value, zero or not power of 2, is given, the cluster size is automatically determined depends on the volume size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FR_OK</td><td></td></tr>
    <tr><td class="paramname">FR_DISK_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_READY</td><td></td></tr>
    <tr><td class="paramname">FR_WRITE_PROTECTED</td><td></td></tr>
    <tr><td class="paramname">FR_INVALID_DRIVE</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_ENABLED</td><td></td></tr>
    <tr><td class="paramname">FR_MKFS_ABORTED</td><td></td></tr>
    <tr><td class="paramname">FR_INVALID_PARAMETER</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Available when _FS_READOLNY == 0 and _USE_MKFS == 1. </dd></dl>

</div>
</div>
<a class="anchor" id="ga16a934c2bbfa2160295810adc49d5509"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a> f_mount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__filesystem.html#struct_f_a_t_f_s">FATFS</a> *&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__filesystem.html#ga16a934c2bbfa2160295810adc49d5509" title="The f_mount fucntion registers/unregisters file system object to the FatFs module. ">f_mount()</a> function registers/unregisters a file system object used for the logical drive to the FatFs module as follows: <br />
 1.Determines the logical drive which specified by path. <br />
 2.Clears and unregisters the regsitered work area of the drive. <br />
 3.Clears and registers the new work area to the drive if fs is not NULL. <br />
 4.Performs volume mount process to the drive if forced mount is specified. <br />
 The file system object is the work area needed for each logical drive. It must be given to the logical drive with this function prior to use any other file functions except for <a class="el" href="group__filesystem.html#ga0c1bd3e3872abbda0e256e7c73da9f3b" title="The f_fdisk fucntion divides a physical drive. ">f_fdisk()</a> function. To unregister a work area, specify a NULL to the fs, and then the work area can be discarded. <br />
 If forced mount is not specified, this function always succeeds regardless of the physical drive status due to delayed mount feature. It only clears (de-initializes) the given work area and registers its address to the internal table. No activity of the physical drive in this function. It can also be used to force de-initialized the registered work area of a logical drive. The volume mount processes, initialize the corresponding physical drive, find the FAT volume in it and initialize the work area, is performed in the subsequent file access functions when either or both of following condition is true. <br />
</p><ul>
<li>File system object is not initialized. It is cleared by <a class="el" href="group__filesystem.html#ga16a934c2bbfa2160295810adc49d5509" title="The f_mount fucntion registers/unregisters file system object to the FatFs module. ">f_mount()</a>.</li>
<li>Physical drive is not initialized. It is de-initialized by system reset or media removal. <br />
 If the function with forced mount failed, it means that the file system object has been registered successfully but the volume is currently not ready to use. Mount process will also be attempted in subsequent file access functions. <br />
 If implementation of the disk I/O layer lacks media change detection, application program needs to perform a <a class="el" href="group__filesystem.html#ga16a934c2bbfa2160295810adc49d5509" title="The f_mount fucntion registers/unregisters file system object to the FatFs module. ">f_mount()</a> after each media change to force cleared the file system object.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fs</td><td>Pointer to the new file system object to be registered. Null pointer unregisters the registered file system object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Pointer to the null-terminated string that specifies the logical drive. The string with no drive number means the default drive. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opt</td><td>Initialization option.<ul>
<li>0: Do not mount now (to be mounted later),</li>
<li>1: Force mounted the volume to check if the FAT volume is available. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FR_OK</td><td></td></tr>
    <tr><td class="paramname">FR_INVALID_DRIVE</td><td></td></tr>
    <tr><td class="paramname">FR_DISK_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_READY</td><td></td></tr>
    <tr><td class="paramname">FR_NO_FILESYSTEM</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Always available. </dd></dl>

</div>
</div>
<a class="anchor" id="gaefdef7126128d99d0b3bd82c28e54d80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a> f_open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__filesystem.html#struct_f_i_l">FIL</a> *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="integer_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>After <a class="el" href="group__filesystem.html#gaefdef7126128d99d0b3bd82c28e54d80" title="The f_open function creates a file object to be used to access the file. ">f_open()</a> function succeeded, the file object is valid. The file object is used for subsequent read/write functions to identify the file. To close an open file, use <a class="el" href="group__filesystem.html#ga53882db20ef4323dcfd1874d7733ffc3" title="The f_close function closes an open file. ">f_close()</a> function. If the file is modified and not closed properly, the file data will be collapsed. <br />
 If duplicated file open is needed, read here carefully. However duplicated open of a file with write mode flag is always prohibited. <br />
 Before using any file function, a work area (file system object) must be registered to the logical drive with <a class="el" href="group__filesystem.html#ga16a934c2bbfa2160295810adc49d5509" title="The f_mount fucntion registers/unregisters file system object to the FatFs module. ">f_mount()</a> function. All API functions except for <a class="el" href="group__filesystem.html#ga0c1bd3e3872abbda0e256e7c73da9f3b" title="The f_fdisk fucntion divides a physical drive. ">f_fdisk()</a> function can work after this procedure. <br />
 Examples: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160; /* Read a text file and display it */</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160; FATFS FatFs;   /* Work area (file system object) for logical drive */</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160; int main (void)</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160; {</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  FIL fil;       /* File object */</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  char line[82]; /* Line buffer */</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  FRESULT fr;    /* FatFs return code */</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;   /* Register work area to the default drive */</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;   f_mount(&amp;FatFs, &quot;&quot;, 0);</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;   /* Open a text file */</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;   fr = f_open(&amp;fil, &quot;message.txt&quot;, FA_READ);</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;   if (fr) return (int)fr;</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;   /* Read all lines and display it */</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;   while (f_gets(line, sizeof line, &amp;fil))</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;       printf(line);</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    /* Close the file */</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;   f_close(&amp;fil);</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;   return 0;</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;}</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;/* Copy a file &quot;file.bin&quot; on the drive 1 to drive 0 */</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;int main (void)</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;{</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;   FATFS fs[2];         /* Work area (file system object) for logical drives */</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;   FIL fsrc, fdst;      /* File objects */</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;   BYTE buffer[4096];   /* File copy buffer */</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;   FRESULT fr;          /* FatFs function common result code */</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;   UINT br, bw;         /* File read/write count */</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;  /* Register work area for each logical drive */</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;   f_mount(&amp;fs[0], &quot;0:&quot;, 0);</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;   f_mount(&amp;fs[1], &quot;1:&quot;, 0);</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;   /* Open source file on the drive 1 */</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;   fr = f_open(&amp;fsrc, &quot;1:file.bin&quot;, FA_OPEN_EXISTING | FA_READ);</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;   if (fr) return (int)fr;</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;   /* Create destination file on the drive 0 */</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;   fr = f_open(&amp;fdst, &quot;0:file.bin&quot;, FA_CREATE_ALWAYS | FA_WRITE);</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;   if (fr) return (int)fr;</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;   /* Copy source to destination */</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;   for (;;) {</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;       fr = f_read(&amp;fsrc, buffer, sizeof buffer, &amp;br);  /* Read a chunk of source file */</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;       if (fr || br == 0) break; /* error or eof */</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;       fr = f_write(&amp;fdst, buffer, br, &amp;bw);            /* Write it to the destination file */</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;       if (fr || bw &lt; br) break; /* error or disk full */</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;   }</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;   /* Close open files */</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;   f_close(&amp;fsrc);</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;   f_close(&amp;fdst);</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;   /* Unregister work area prior to discard it */</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;   f_mount(NULL, &quot;0:&quot;, 0);</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;   f_mount(NULL, &quot;1:&quot;, 0);</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;   return (int)fr;</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;}</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">fp</td><td>Pointer to the blank file object structure to be created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Pointer to a null-terminated string that specifies the file name to open or create. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Mode flags that specifies the type of access and open method for the file. It is specified by a combination of following flags.<br />
<table class="doxtable">
<tr>
<th>Value </th><th>Description  </th></tr>
<tr>
<td>FA_READ </td><td>Specifies read access to the object. Data can be read from the file. Combine with FA_WRITE for read-write access. </td></tr>
<tr>
<td>FA_WRITE </td><td>Specifies write access to the object. Data can be written to the file. Combine with FA_READ for read-write access. </td></tr>
<tr>
<td>FA_OPEN_EXISTING </td><td>Opens the file. The function fails if the file is not existing. (Default) . </td></tr>
<tr>
<td>FA_OPEN_ALWAYS </td><td>Opens the file if it is existing. If not, a new file is created. To append data to the file, use <a class="el" href="group__filesystem.html#ga5df0ac672ada972e89ef4b003e57f964" title="The f_lseek function moves the file read/write pointer of an open file object. It can also be used to...">f_lseek()</a> function after file open in this method. </td></tr>
<tr>
<td>FA_CREATE_NEW </td><td>Creates a new file. The function fails with FR_EXIST if the file is existing. </td></tr>
<tr>
<td>FA_CREATE_NEW </td><td>Creates a new file. If the file is existing, it will be truncated and overwritten. <br />
 </td></tr>
</table>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FR_OK</td><td></td></tr>
    <tr><td class="paramname">FR_DISK_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_INT_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_READY</td><td></td></tr>
    <tr><td class="paramname">FR_NO_FILE</td><td></td></tr>
    <tr><td class="paramname">FR_NO_PATH</td><td></td></tr>
    <tr><td class="paramname">FR_INVALID_NAME</td><td></td></tr>
    <tr><td class="paramname">FR_DENIED</td><td></td></tr>
    <tr><td class="paramname">FR_EXIST</td><td></td></tr>
    <tr><td class="paramname">FR_INVALID_OBJECT</td><td></td></tr>
    <tr><td class="paramname">FR_WRITE_PROTECTED</td><td></td></tr>
    <tr><td class="paramname">FR_INVALID_DRIVE</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_ENABLED</td><td></td></tr>
    <tr><td class="paramname">FR_NO_FILESYSTEM</td><td></td></tr>
    <tr><td class="paramname">FR_TIMEOUT</td><td></td></tr>
    <tr><td class="paramname">FR_LOCKED</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_ENOUGH_CORE</td><td></td></tr>
    <tr><td class="paramname">FR_TOO_MANY_OPEN_FILES</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Always available. The mode flags, FA_WRITE, FA_CREATE_ALWAYS, FA_CREATE_NEW and FA_OPEN_ALWAYS, are not available when _FS_READONLY == 1. </dd></dl>

</div>
</div>
<a class="anchor" id="gab63b213c75f7335fbb63a1f3f70e5fc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a> f_opendir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__filesystem.html#struct_d_i_r">DIR</a> *&#160;</td>
          <td class="paramname"><em>dp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__filesystem.html#gab63b213c75f7335fbb63a1f3f70e5fc7" title="The f_opendir function opens a directory. ">f_opendir()</a> function opens an exsisting directory and creates a directory object for subsequent <a class="el" href="group__filesystem.html#gab39e82a110695de45f416f3149358012" title="The f_readdir function reads directory entries. ">f_readdir()</a> function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dp</td><td>Pointer to the blank directory object to create a new one. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Pointer to the null-terminated string that specifies the directory name to be opened. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FR_OK</td><td></td></tr>
    <tr><td class="paramname">FR_DISK_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_INT_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_READY</td><td></td></tr>
    <tr><td class="paramname">FR_NO_PATH</td><td></td></tr>
    <tr><td class="paramname">FR_INVALID_NAME</td><td></td></tr>
    <tr><td class="paramname">FR_INVALID_OBJECT</td><td></td></tr>
    <tr><td class="paramname">FR_INVALID_DRIVE</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_ENABLED</td><td></td></tr>
    <tr><td class="paramname">FR_NO_FILESYSTEM</td><td></td></tr>
    <tr><td class="paramname">FR_TIMEOUT</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_ENOUGH_CORE</td><td></td></tr>
    <tr><td class="paramname">FR_TOO_MANY_OPEN_FILES</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Available when _FS_MINIMIZE &lt;= 1. </dd></dl>

</div>
</div>
<a class="anchor" id="ga49cccab38cd84e2d3357fef2d1df21f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int f_printf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__filesystem.html#struct_f_i_l">FIL</a> *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__filesystem.html#ga49cccab38cd84e2d3357fef2d1df21f9" title="The f_printf function writes formatted string to the file. ">f_printf()</a> is a wrapper function of <a class="el" href="group__filesystem.html#gae6a4dfae8a9e308bdb2283a37ef680f2" title="The f_write writes data to a file. ">f_write()</a>. The format control directive is a sub-set of standard library shown as follows:</p><ul>
<li>Type: c C s S d D u U x X b B</li>
<li>Size: l L</li>
<li>Flag: 0 - <br />
 Example: <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;f_printf(&amp;fil, &quot;%d&quot;, 1234);            /* &quot;1234&quot; */</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;f_printf(&amp;fil, &quot;%6d,%3d%%&quot;, -200, 5);  /* &quot;  -200,  5%&quot; */</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;f_printf(&amp;fil, &quot;%ld&quot;, 12345L);         /* &quot;12345&quot; */</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;f_printf(&amp;fil, &quot;%06d&quot;, 25);            /* &quot;000025&quot; */</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;f_printf(&amp;fil, &quot;%06d&quot;, -25);           /* &quot;000-25&quot; */</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;f_printf(&amp;fil, &quot;%-6d&quot;, 25);            /* &quot;25    &quot; */</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;f_printf(&amp;fil, &quot;%u&quot;, -1);              /* &quot;65535&quot; or &quot;4294967295&quot; */</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;f_printf(&amp;fil, &quot;%04x&quot;, 0xAB3);         /* &quot;0ab3&quot; */</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;f_printf(&amp;fil, &quot;%08LX&quot;, 0x123ABCL);    /* &quot;00123ABC&quot; */</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;f_printf(&amp;fil, &quot;%016b&quot;, 0x550F);       /* &quot;0101010100001111&quot; */</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;f_printf(&amp;fil, &quot;%s&quot;, &quot;String&quot;);        /* &quot;String&quot; */</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;f_printf(&amp;fil, &quot;%8s&quot;, &quot;abc&quot;);          /* &quot;     abc&quot; */</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;f_printf(&amp;fil, &quot;%-8s&quot;, &quot;abc&quot;);         /* &quot;abc     &quot; */</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;f_printf(&amp;fil, &quot;%c&quot;, &#39;a&#39;);             /* &quot;a&quot; */</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;f_printf(&amp;fil, &quot;%f&quot;, 10.0);            /* f_printf lacks floating point support */</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fp</td><td>Pointer to the open file object structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>Pointer to the null terminated format string. The terminator charactor will not be written. ... Optional arguments... </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">When</td><td>the function succeeded, it returns number of characters written. When the function failed due to disk full or any error, an EOF (-1) will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Available when _FS_READONLY == 0 and _USE_STRFUNC is 1 or 2. When it is set to 2, '<br />
's contained in the output are converted to ''+'<br />
'. <br />
 When FatFs is configured to Unicode API (_LFN_UNICODE == 1), data types on the srting fuctions, <a class="el" href="group__filesystem.html#ga62a35ee79e4913c1e31ac706241be7da" title="The f_putc funciton puts a character to the file. ">f_putc()</a>, <a class="el" href="group__filesystem.html#ga9443c00129414fbfc16a5a13ad876ced" title="The f_puts function writes a string to the file. ">f_puts()</a>, <a class="el" href="group__filesystem.html#ga49cccab38cd84e2d3357fef2d1df21f9" title="The f_printf function writes formatted string to the file. ">f_printf()</a> and <a class="el" href="group__filesystem.html#ga0fa54bd310785ecdaed19dda8f60dac5" title="The f_gets reads a string from the file. ">f_gets()</a>, is also switched to Unicode. The character encoding on the file to be read/written via those functions is selected by _STRF_ENCODE option. </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ga62a35ee79e4913c1e31ac706241be7da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int f_putc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a>&#160;</td>
          <td class="paramname"><em>chr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__filesystem.html#struct_f_i_l">FIL</a> *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__filesystem.html#ga62a35ee79e4913c1e31ac706241be7da" title="The f_putc funciton puts a character to the file. ">f_putc()</a> function is a wrapper function of <a class="el" href="group__filesystem.html#gae6a4dfae8a9e308bdb2283a37ef680f2" title="The f_write writes data to a file. ">f_write()</a> function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">chr</td><td>A character to be put. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fp</td><td>Pointer to the open file object structuer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">When</td><td>the character was written successfuly, it returns number of characters written. When the function failed due to disk full or any error, an EOF (-1) will be returned. <br />
 When FatFs is configured to Unicode API (_LFN_UNICODE == 1), character encoding on the string fuctions, <a class="el" href="group__filesystem.html#ga62a35ee79e4913c1e31ac706241be7da" title="The f_putc funciton puts a character to the file. ">f_putc()</a>, <a class="el" href="group__filesystem.html#ga9443c00129414fbfc16a5a13ad876ced" title="The f_puts function writes a string to the file. ">f_puts()</a>, <a class="el" href="group__filesystem.html#ga49cccab38cd84e2d3357fef2d1df21f9" title="The f_printf function writes formatted string to the file. ">f_printf()</a> and <a class="el" href="group__filesystem.html#ga0fa54bd310785ecdaed19dda8f60dac5" title="The f_gets reads a string from the file. ">f_gets()</a>, is also switched to Unicode. The character encoding on the file to be read/written via those functions is selected by _STRF_ENCODE option. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Available when _FS_READONLY == 0 and _USE_STRFUNC is 1 or 2. When it is set to 2, a '<br />
' is converted to ''+'<br />
'. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9443c00129414fbfc16a5a13ad876ced"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int f_puts </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__filesystem.html#struct_f_i_l">FIL</a> *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__filesystem.html#ga9443c00129414fbfc16a5a13ad876ced" title="The f_puts function writes a string to the file. ">f_puts()</a> function is a wrapper function of <a class="el" href="group__filesystem.html#gae6a4dfae8a9e308bdb2283a37ef680f2" title="The f_write writes data to a file. ">f_write()</a> function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>Pointer to the null terminated string to be written. The terminator character will not be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fp</td><td>Pointer to the open file object structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">When</td><td>the function succeeded, it returns number of characters written. When the write operation is aborted due to disk full or any error, an EOF (-1) will be returned. <br />
 When FatFs is configured to Unicode API (_LFN_UNICODE == 1), character encoding on the srting fuctions, <a class="el" href="group__filesystem.html#ga62a35ee79e4913c1e31ac706241be7da" title="The f_putc funciton puts a character to the file. ">f_putc()</a>, <a class="el" href="group__filesystem.html#ga9443c00129414fbfc16a5a13ad876ced" title="The f_puts function writes a string to the file. ">f_puts()</a>, <a class="el" href="group__filesystem.html#ga49cccab38cd84e2d3357fef2d1df21f9" title="The f_printf function writes formatted string to the file. ">f_printf()</a> and <a class="el" href="group__filesystem.html#ga0fa54bd310785ecdaed19dda8f60dac5" title="The f_gets reads a string from the file. ">f_gets()</a>, is also switched to Unicode. The character encoding on the file to be read/written via those functions is selected by _STRF_ENCODE option. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Available when _FS_READONLY == 0 and _USE_STRFUNC is 1 or 2. When it is set to 2, '<br />
's contained in the string are converted to ''+'<br />
'. </dd></dl>

</div>
</div>
<a class="anchor" id="gac4c3dcb6869ca252888eebabe39727b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a> f_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__filesystem.html#struct_f_i_l">FIL</a> *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="integer_8h.html#a36cb3b01d81ffd844bbbfb54003e06ec">UINT</a>&#160;</td>
          <td class="paramname"><em>btr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="integer_8h.html#a36cb3b01d81ffd844bbbfb54003e06ec">UINT</a> *&#160;</td>
          <td class="paramname"><em>br</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The file read/write pointer of the file object advances number of bytes read. After the function succeeded, *br should be checked to detect end of the file. In case of *br is less than btr, it means the read/write pointer reached end of the file during read operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fp</td><td>Pointer to the open file object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buff</td><td>Pointer to the buffer to store read data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">btr</td><td>Number of bytes to read in range of UINT type. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">br</td><td>Pointer to the UINT variable to return number of bytes read. The value is always valid after the function call regardless of the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FR_OK</td><td></td></tr>
    <tr><td class="paramname">FR_DISK_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_INT_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_READY</td><td></td></tr>
    <tr><td class="paramname">FR_INVALID_OBJECT</td><td></td></tr>
    <tr><td class="paramname">FR_TIMEOUT</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Always available. </dd></dl>

</div>
</div>
<a class="anchor" id="gab39e82a110695de45f416f3149358012"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a> f_readdir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__filesystem.html#struct_d_i_r">DIR</a> *&#160;</td>
          <td class="paramname"><em>dp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__filesystem.html#struct_f_i_l_i_n_f_o">FILINFO</a> *&#160;</td>
          <td class="paramname"><em>fno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__filesystem.html#gab39e82a110695de45f416f3149358012" title="The f_readdir function reads directory entries. ">f_readdir()</a> function reads directory items, file and directory, in sequence. All items in the directory can be read by calling <a class="el" href="group__filesystem.html#gab39e82a110695de45f416f3149358012" title="The f_readdir function reads directory entries. ">f_readdir()</a> function repeatedly. When relative path feature is enabled (_FS_RPATH &gt;= 1), dot entries ("." and "..") are not filtered out and they will appear in the read items. When all directory items have been read and no item to read, a null string is returned into the fname[] without any error. When a null pointer is given to the fno, the read index of the directory object is rewinded. <br />
 When LFN feature is enabled, lfname and lfsize in the file information structure must be initialized with valid value prior to use it. The lfname is a pointer to the LFN read buffer. The lfsize is size of the LFN read buffer in unit of TCHAR. If the LFN is not needed, set a null pointer to the lfname and the LFN is not returned. A null string will be returned into the LFN read buffer in case of following conditions. <br />
</p><ul>
<li>The directory item has no LFN information.</li>
<li>Either the size of read buffer or LFN working buffer is insufficient for the LFN.</li>
<li>The LFN contains any Unicode character that cannot be converted to OEM code. (not the case at Unicode API cfg.) <br />
 When the directory item has no LFN information, lower case characters can be contained in the fname[]. <br />
 Sample Code: <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160; FRESULT scan_files (</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160; char* path        /* Start node to be scanned (also used as work area) */</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;)</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;{</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  FRESULT res;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  FILINFO fno;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  DIR dir;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  int i;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  char *fn;   /* This function assumes non-Unicode configuration */</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  #if _USE_LFN</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;  static char lfn[_MAX_LFN + 1];   /* Buffer to store the LFN */</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;  fno.lfname = lfn;</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;  fno.lfsize = sizeof lfn;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;  #endif</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;  res = f_opendir(&amp;dir, path);      /* Open the directory */</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;  if (res == FR_OK) {</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;     i = strlen(path);</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;     for (;;) {</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;         res = f_readdir(&amp;dir, &amp;fno);                   /* Read a directory item */</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;         if (res != FR_OK || fno.fname[0] == 0) break;  /* Break on error or end of dir */</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;         if (fno.fname[0] == &#39;.&#39;) continue;             /* Ignore dot entry */</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;  #if _USE_LFN</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;          fn = *fno.lfname ? fno.lfname : fno.fname;</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;  #else</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;          fn = fno.fname;</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;  #endif</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;          if (fno.fattrib &amp; AM_DIR) {                    /* It is a directory */</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;             sprintf(&amp;path[i], &quot;/%s&quot;, fn);</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;             res = scan_files(path);</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;             path[i] = 0;</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;             if (res != FR_OK) break;</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;         } else {                                       /* It is a file. */</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;             printf(&quot;%s/%s\n&quot;, path, fn);</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;         }</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;     }</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;     f_closedir(&amp;dir)</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160; }</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;  return res;</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;}</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dp</td><td>Pointer to the open directory object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fno</td><td>Pointer to the file information structure to store the read item. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FR_OK</td><td></td></tr>
    <tr><td class="paramname">FR_DISK_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_INT_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_READY</td><td></td></tr>
    <tr><td class="paramname">FR_INVALID_OBJECT</td><td></td></tr>
    <tr><td class="paramname">FR_TIMEOUT</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_ENOUGH_CORE</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Available when _FS_MINIMIZE &lt;= 1. </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ga2d0ceea336edd9b05754c8684ea8a72f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a> f_rename </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *&#160;</td>
          <td class="paramname"><em>old_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *&#160;</td>
          <td class="paramname"><em>new_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Renames a file or sub-directory and can also move it to other directory within the same logical drive. Do not rename open objects or directry table can be broken. <br />
 Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;/* Rename an object */</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;f_rename(&quot;oldname.txt&quot;, &quot;newname.txt&quot;);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;/* Rename and move an object to other directory */</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;f_rename(&quot;oldname.txt&quot;, &quot;dir1/newname.txt&quot;);</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">old_name</td><td>Pointer to a null-terminated string that specifies an existing file or sub-directory to be renamed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_name</td><td>Pointer to a null-terminated string that specifies the new object name. The drive number specified in this string is ignored and one determined by old_name is used instead. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FR_OK</td><td></td></tr>
    <tr><td class="paramname">FR_DISK_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_INT_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_READY</td><td></td></tr>
    <tr><td class="paramname">FR_NO_FILE</td><td></td></tr>
    <tr><td class="paramname">FR_NO_PATH</td><td></td></tr>
    <tr><td class="paramname">FR_INVALID_NAME</td><td></td></tr>
    <tr><td class="paramname">FR_DENIED</td><td></td></tr>
    <tr><td class="paramname">FR_EXIST</td><td></td></tr>
    <tr><td class="paramname">FR_EXIST</td><td></td></tr>
    <tr><td class="paramname">FR_WRITE_PROTECTED</td><td></td></tr>
    <tr><td class="paramname">FR_INVALID_DRIVE</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_ENABLED</td><td></td></tr>
    <tr><td class="paramname">FR_NO_FILESYSTEM</td><td></td></tr>
    <tr><td class="paramname">FR_TIMEOUT</td><td></td></tr>
    <tr><td class="paramname">FR_LOCKED</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_ENOUGH_CORE</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Available when _FS_READONLY == 0 and _FS_MINIMIZE == 0. </dd></dl>

<p><div id="dynsection-2" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-2-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-2-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-2-content" class="dyncontent" style="display:none;">
<div class="center"><img src="group__filesystem_ga2d0ceea336edd9b05754c8684ea8a72f_icgraph.png" border="0" usemap="#group__filesystem_ga2d0ceea336edd9b05754c8684ea8a72f_icgraph" alt=""/></div>
<map name="group__filesystem_ga2d0ceea336edd9b05754c8684ea8a72f_icgraph" id="group__filesystem_ga2d0ceea336edd9b05754c8684ea8a72f_icgraph">
<area shape="rect" id="node2" href="group___f_o_t_a.html#ga02aaeb14e249d60489d2f887a46f26bc" title="This function Validates the firmware in the Sdcard. " alt="" coords="128,5,296,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaa82bca64e28bc0d656a7999dd0eadec7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a> f_setlabel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When the string has a drive number, the volume label will be set to the volume specified by the drive number. If not, the label will be set to the default drive. If the given string is a null-string, the volume label on the volume will be removed. The format of the volume label is similar to the short file name but there are some differences shown below:</p><ul>
<li>11 bytes or less in length as local character code. LFN extention is not applied to the volume label.</li>
<li>Cannot contain period.</li>
<li>Can contain spaces anywhere in the volume label. Trailing spaces are truncated off. <br />
 Example: <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;/* Set volume label to the default drive */</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;f_setlabel(&quot;DATA DISK&quot;);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;/* Set volume label to the drive 2 */</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;f_setlabel(&quot;2:DISK 3 OF 4&quot;);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;/* Remove volume label of the drive 2 */</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;f_setlabel(&quot;2:&quot;);</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">label</td><td>Pointer to the null-terminated string that specifies the logical drive. Null-string specifies the default drive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FR_OK</td><td></td></tr>
    <tr><td class="paramname">FR_DISK_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_INT_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_READY</td><td></td></tr>
    <tr><td class="paramname">FR_INVALID_NAME</td><td></td></tr>
    <tr><td class="paramname">FR_WRITE_PROTECTED</td><td></td></tr>
    <tr><td class="paramname">FR_INVALID_DRIVE</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_ENABLED</td><td></td></tr>
    <tr><td class="paramname">FR_NO_FILESYSTEM</td><td></td></tr>
    <tr><td class="paramname">FR_TIMEOUT</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Available when _FS_READONLY == 0 and _USE_LABEL == 1. </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ga5c1a803b666f1cc92b2f9363d877a82e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a> f_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__filesystem.html#struct_f_i_l">FIL</a> *&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In this revision, the <a class="el" href="group__filesystem.html#ga5c1a803b666f1cc92b2f9363d877a82e" title="The f_size function gets the size of a file. ">f_size()</a> function is implemented as a macro.<br />
 #define <a class="el" href="ff_8h.html#a26f33722c5bf1aa3cd6f0290a83eb2bc">f_size(fp)</a> ((fp)-&gt;fsize) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fp</td><td>Pointer to the open file object structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Returns</td><td>the size of the file in unit of byte. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Always available. </dd></dl>

</div>
</div>
<a class="anchor" id="gabe1f60daab5c7d11170c334fb832c798"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a> f_stat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__filesystem.html#struct_f_i_l_i_n_f_o">FILINFO</a> *&#160;</td>
          <td class="paramname"><em>fno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__filesystem.html#gabe1f60daab5c7d11170c334fb832c798" title="The f_stat function checks the existence of a file or sub-directory. ">f_stat()</a> function checks the existence of a file or sub-directory. If not exist, the function returns with FR_NO_FILE. If exist, the function returns with FR_OK and the informations of the object, file size, timestamp, attribute and SFN, are stored to the file information structure. For details of the file information, refer to the <a class="el" href="group__filesystem.html#struct_f_i_l_i_n_f_o">FILINFO</a> structure and <a class="el" href="group__filesystem.html#gab39e82a110695de45f416f3149358012" title="The f_readdir function reads directory entries. ">f_readdir()</a> function. <br />
 When LFN feature is enabled, lfname in the file information structure must be NULLed prior to use it. <br />
 Examples: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;FRESULT fr;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;FILINFO fno;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;printf(&quot;Test for &#39;file.txt&#39;...\n&quot;);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;#if _USE_LFN</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;fno.lfname = 0;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;#endif</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;fr = f_stat(&quot;file.txt&quot;, &amp;fno);</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;switch (fr) {</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;case FR_OK:</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    printf(&quot;Size: %u\n&quot;, fno.fsize);</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    printf(&quot;Timestamp: %u/%02u/%02u, %02u:%02u\n&quot;,</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;             (fno.fdate &gt;&gt; 9) + 1980, fno.fdate &gt;&gt; 5 &amp; 15, fno.fdate &amp; 31,</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;             fno.ftime &gt;&gt; 11, fno.ftime &gt;&gt; 5 &amp; 63);</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    printf(&quot;Attributes: %c%c%c%c%c\n&quot;,</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;             (fno.fattrib &amp; AM_DIR) ? &#39;D&#39; : &#39;-&#39;,</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;             (fno.fattrib &amp; AM_RDO) ? &#39;R&#39; : &#39;-&#39;,</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;             (fno.fattrib &amp; AM_HID) ? &#39;H&#39; : &#39;-&#39;,</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;             (fno.fattrib &amp; AM_SYS) ? &#39;S&#39; : &#39;-&#39;,</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;             (fno.fattrib &amp; AM_ARC) ? &#39;A&#39; : &#39;-&#39;);</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160; break;</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160; case FR_NO_FILE:</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    printf(&quot;It is not exist.\n&quot;);</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    break;</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160; default:</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    printf(&quot;An error occured. (%d)\n&quot;, fr);</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160; }</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Pointer to the null-terminated string that specifies the object to get its information. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fno</td><td>Pointer to the blank <a class="el" href="group__filesystem.html#struct_f_i_l_i_n_f_o">FILINFO</a> structure to store the information of the object. Set null pointer if it is not needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FR_OK</td><td></td></tr>
    <tr><td class="paramname">FR_DISK_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_INT_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_READY</td><td></td></tr>
    <tr><td class="paramname">FR_NO_FILE</td><td></td></tr>
    <tr><td class="paramname">FR_NO_PATH</td><td></td></tr>
    <tr><td class="paramname">FR_INVALID_NAME</td><td></td></tr>
    <tr><td class="paramname">FR_INVALID_DRIVE</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_ENABLED</td><td></td></tr>
    <tr><td class="paramname">FR_NO_FILESYSTEM</td><td></td></tr>
    <tr><td class="paramname">FR_TIMEOUT</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_ENOUGH_CORE</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Available when _FS_MINIMIZE == 0. </dd></dl>

<p><div id="dynsection-3" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-3-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-3-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-3-content" class="dyncontent" style="display:none;">
<div class="center"><img src="group__filesystem_gabe1f60daab5c7d11170c334fb832c798_icgraph.png" border="0" usemap="#group__filesystem_gabe1f60daab5c7d11170c334fb832c798_icgraph" alt=""/></div>
<map name="group__filesystem_gabe1f60daab5c7d11170c334fb832c798_icgraph" id="group__filesystem_gabe1f60daab5c7d11170c334fb832c798_icgraph">
<area shape="rect" id="node2" href="group___f_o_t_a.html#gaa17c22be08c000fec0331fab53040c26" title="This function Triggers an firmware update from Sdcard. " alt="" coords="108,5,271,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gad69c7246b122ba56a134939ee0eaf847"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a> f_sync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__filesystem.html#struct_f_i_l">FIL</a> *&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__filesystem.html#gad69c7246b122ba56a134939ee0eaf847" title="The f_sync function flushes the cached information of a writing file. ">f_sync()</a> function performs the same process as <a class="el" href="group__filesystem.html#ga53882db20ef4323dcfd1874d7733ffc3" title="The f_close function closes an open file. ">f_close()</a> function but the file is left opened and can continue read/write/seek operations to the file. This is suitable for the applications that open files for a long time in write mode, such as data logger. Performing <a class="el" href="group__filesystem.html#gad69c7246b122ba56a134939ee0eaf847" title="The f_sync function flushes the cached information of a writing file. ">f_sync()</a> function of periodic or immediataly after <a class="el" href="group__filesystem.html#gae6a4dfae8a9e308bdb2283a37ef680f2" title="The f_write writes data to a file. ">f_write()</a> function can minimize the risk of data loss due to a sudden blackout or an unintentional media removal. <br />
 However there is no sense in <a class="el" href="group__filesystem.html#gad69c7246b122ba56a134939ee0eaf847" title="The f_sync function flushes the cached information of a writing file. ">f_sync()</a> function immediataly before <a class="el" href="group__filesystem.html#ga53882db20ef4323dcfd1874d7733ffc3" title="The f_close function closes an open file. ">f_close()</a> function because it performs <a class="el" href="group__filesystem.html#gad69c7246b122ba56a134939ee0eaf847" title="The f_sync function flushes the cached information of a writing file. ">f_sync()</a> function in it. In other words, the differnce between those functions is that the file object is invalidated or not. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fp</td><td>Pointer to the open file object to be flushed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FR_OK</td><td></td></tr>
    <tr><td class="paramname">FR_DISK_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_INT_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_READY</td><td></td></tr>
    <tr><td class="paramname">FR_INVALID_OBJECT</td><td></td></tr>
    <tr><td class="paramname">FR_TIMEOUT</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Available when _FS_READONLY == 0. </dd></dl>

</div>
</div>
<a class="anchor" id="ga091c830b8b17e19267dac539f9093128"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a> f_tell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__filesystem.html#struct_f_i_l">FIL</a> *&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In this revision, the <a class="el" href="group__filesystem.html#ga091c830b8b17e19267dac539f9093128" title="The f_tell function gets the current read/write pointer of a file. ">f_tell()</a> function is implemented as a macro. <br />
 #define <a class="el" href="ff_8h.html#a5e1daca7ce13cdc277e42185f7f9124f">f_tell(fp)</a> ((fp)-&gt;fptr) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fp</td><td>Pointer to the open file object structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Returns</td><td>current read/write pointer of the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Always available. </dd></dl>

</div>
</div>
<a class="anchor" id="ga691a27b40c348f7c84b42e911636f38a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a> f_truncate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__filesystem.html#struct_f_i_l">FIL</a> *&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__filesystem.html#ga691a27b40c348f7c84b42e911636f38a" title="The f_truncate function truncates the file size. ">f_truncate()</a> function truncates the file size to the current file read/write pointer. This function has no effect if the file read/write pointer is already pointing end of the file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fp</td><td>Pointer to the open file object to be truncated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FR_OK</td><td></td></tr>
    <tr><td class="paramname">FR_DISK_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_INT_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_READY</td><td></td></tr>
    <tr><td class="paramname">FR_INVALID_OBJECT</td><td></td></tr>
    <tr><td class="paramname">FR_TIMEOUT</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Available when _FS_READONLY == 0 and _FS_MINIMIZE == 0. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2858167fcd0bced48e9be434b3895efe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a> f_unlink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If condition of the object to be removed is applicable to the following terms, the function will be rejected. <br />
</p><ul>
<li>The file/sub-directory must not have read-only attribute (AM_RDO), or the function will be rejected with FR_DENIED.</li>
<li>The sub-directory must be empty and must not be current directory, or the function will be rejected with FR_DENIED.</li>
<li>The file/sub-directory must not be opened, or the FAT volume can be collapsed. It can be rejected with FR_LOCKED when file lock feature is enabled. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Pointer to the null-terminated string that specifies an object to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FR_OK</td><td></td></tr>
    <tr><td class="paramname">FR_DISK_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_INT_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_READY</td><td></td></tr>
    <tr><td class="paramname">FR_NO_FILE</td><td></td></tr>
    <tr><td class="paramname">FR_NO_PATH</td><td></td></tr>
    <tr><td class="paramname">FR_INVALID_NAME</td><td></td></tr>
    <tr><td class="paramname">FR_DENIED</td><td></td></tr>
    <tr><td class="paramname">FR_EXIST</td><td></td></tr>
    <tr><td class="paramname">FR_WRITE_PROTECTED</td><td></td></tr>
    <tr><td class="paramname">FR_INVALID_DRIVE</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_ENABLED</td><td></td></tr>
    <tr><td class="paramname">FR_NO_FILESYSTEM</td><td></td></tr>
    <tr><td class="paramname">FR_TIMEOUT</td><td></td></tr>
    <tr><td class="paramname">FR_LOCKED</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_ENOUGH_CORE</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Available when _FS_READONLY == 0 and _FS_MINIMIZE == 0. </dd></dl>
</li>
</ul>

<p><div id="dynsection-4" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-4-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-4-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-4-content" class="dyncontent" style="display:none;">
<div class="center"><img src="group__filesystem_ga2858167fcd0bced48e9be434b3895efe_icgraph.png" border="0" usemap="#group__filesystem_ga2858167fcd0bced48e9be434b3895efe_icgraph" alt=""/></div>
<map name="group__filesystem_ga2858167fcd0bced48e9be434b3895efe_icgraph" id="group__filesystem_ga2858167fcd0bced48e9be434b3895efe_icgraph">
<area shape="rect" id="node2" href="group___f_o_t_a.html#ga02aaeb14e249d60489d2f887a46f26bc" title="This function Validates the firmware in the Sdcard. " alt="" coords="120,5,288,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaafaa718d1a487e12a8f0087173dba0b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a> f_utime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ff_8h.html#a03bdb8ce5895c7e261aadc2529637546">TCHAR</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__filesystem.html#struct_f_i_l_i_n_f_o">FILINFO</a> *&#160;</td>
          <td class="paramname"><em>fno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__filesystem.html#gaafaa718d1a487e12a8f0087173dba0b9" title="The f_utime function changes the timestamp of a file or sub-directory. ">f_utime()</a> function changes the timestamp of a file or sub-directory <br />
 Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;FRESULT set_timestamp (</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  char *obj,     /* Pointer to the file name */</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  int year,</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  int month,</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  int mday,</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  int hour,</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  int min,</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  int sec</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;)</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;{</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  FILINFO fno;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;  fno.fdate = (WORD)(((year - 1980) * 512U) | month * 32U | mday);</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;  fno.ftime = (WORD)(hour * 2048U | min * 32U | sec / 2U);</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;   return f_utime(obj, &amp;fno);</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;}</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Pointer to the null-terminated string that specifies an object to be changed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fno</td><td>Pointer to the file information structure that has a timestamp to be set in member fdate and ftime. Do not care any other members. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FR_OK</td><td></td></tr>
    <tr><td class="paramname">FR_DISK_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_INT_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_READY</td><td></td></tr>
    <tr><td class="paramname">FR_NO_FILE</td><td></td></tr>
    <tr><td class="paramname">FR_NO_PATH</td><td></td></tr>
    <tr><td class="paramname">FR_INVALID_NAME</td><td></td></tr>
    <tr><td class="paramname">FR_WRITE_PROTECTED</td><td></td></tr>
    <tr><td class="paramname">FR_INVALID_DRIVE</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_ENABLED</td><td></td></tr>
    <tr><td class="paramname">FR_NO_FILESYSTEM</td><td></td></tr>
    <tr><td class="paramname">FR_TIMEOUT</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_ENOUGH_CORE</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Available when _FS_READONLY == 0 and _FS_MINIMIZE == 0. </dd></dl>

</div>
</div>
<a class="anchor" id="gae6a4dfae8a9e308bdb2283a37ef680f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__filesystem.html#ga49d0171ecbd362cda5680a0d360db44c">FRESULT</a> f_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__filesystem.html#struct_f_i_l">FIL</a> *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="integer_8h.html#a36cb3b01d81ffd844bbbfb54003e06ec">UINT</a>&#160;</td>
          <td class="paramname"><em>btw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="integer_8h.html#a36cb3b01d81ffd844bbbfb54003e06ec">UINT</a> *&#160;</td>
          <td class="paramname"><em>bw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The read/write pointer of the file object advances number of bytes written. After the function succeeded, *bw should be checked to detect the disk full. In case of *bw is less than btw, it means the volume got full during the write operation. The function can take a time when the volume is full or close to full. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fp</td><td>Pointer to the open file object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buff</td><td>Pointer to the data to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">btw</td><td>Specifies number of bytes to write in range of UINT type. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bw</td><td>Pointer to the UINT variable to return the number of bytes written. The value is always valid after the function call regardless of the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FR_OK</td><td></td></tr>
    <tr><td class="paramname">FR_DISK_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_INT_ERR</td><td></td></tr>
    <tr><td class="paramname">FR_NOT_READY</td><td></td></tr>
    <tr><td class="paramname">FR_INVALID_OBJECT</td><td></td></tr>
    <tr><td class="paramname">FR_TIMEOUT</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Available when _FS_READONLY == 0. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf58b536abfd30f77213f4ecaf2ac52f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integer_8h.html#ad342ac907eb044443153a22f964bf0af">DWORD</a> get_fattime </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__filesystem.html#gaf58b536abfd30f77213f4ecaf2ac52f5" title="The get_fattime function gets current time. ">get_fattime()</a> function shall return any valid time even if the system does not support a real time clock. If a zero is returned, the file will not have a valid timestamp. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pdrv</td><td>Physical drive number to identify the target device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buff</td><td>Pointer to the byte array to be written. The size of data to be written is sector size * count bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sector</td><td>Start sector number in 32-bit LBA. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of sectors to write in range of from 1 to 128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Currnet</td><td>time is returned with packed into a DWORD value. The bit field is as follows: <br />
 </td></tr>
    <tr><td class="paramname">bit31:25</td><td><br />
 Year origin from the 1980 (0..127) </td></tr>
    <tr><td class="paramname">bit24:21</td><td><br />
 Month (1..12) </td></tr>
    <tr><td class="paramname">bit20:16</td><td><br />
 Day of the month(1..31) </td></tr>
    <tr><td class="paramname">bit15:11</td><td><br />
 Hour (0..23) </td></tr>
    <tr><td class="paramname">bit10:5</td><td><br />
 Minute (0..59) </td></tr>
    <tr><td class="paramname">bit4:0</td><td><br />
 Second / 2 (0..29) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is not needed when _FS_READONLY == 1. </dd></dl>

</div>
</div>
</div><!-- contents -->
	<hr size="1" />
	All rights reserved. The use is subject to the XDK SDK EULA by Bosch Connected Devices and Solutions GmbH. 
	<hr size="1" />
	<address style="align: right;">
		<small>This documentation file has been automatically generated on Thu Mar 14 2019 19:12:49 by <a href="http://www.doxygen.org/index.html">doxygen</a> 1.8.8</small>
	</address>
</body>
</html>